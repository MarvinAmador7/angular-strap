{"version":3,"sources":["angular-strap.js","tooltip/tooltip.js","helpers/compiler.js","collapse/collapse.js","typeahead/typeahead.js","timepicker/timepicker.js","popover/popover.js","tab/tab.js","scrollspy/scrollspy.js","select/select.js","datepicker/datepicker.js","modal/modal.js","navbar/navbar.js","helpers/raf.js","helpers/parse-options.js","helpers/dimensions.js","helpers/debounce.js","helpers/date-parser.js","helpers/date-formatter.js","dropdown/dropdown.js","aside/aside.js","button/button.js","alert/alert.js","affix/affix.js","module.js"],"names":["prefixEvent","undefined","templateUrl","options","cache","$templateCache","then","element","res","fetchTemplate","template","fetchPromises","bsCompilerService","$inject","$http","get","angular","module","defaults","this","animation","data","compile","controller","console","controllerAs","resolve","copy","locals","bindToController","forEach","value","isString","$injector","key","invoke","transformTemplate","identity","extend","$template","when","$q","all","templateEl","Error","findElement","contentTemplate","templates","contentEl","removeAttr","html","replace","next","remove","outerHTML","link","scope","trim","contents","linkFn","invokeCtrl","children","instance","ctrl","isObject","arguments","apply","target","provider","placement","titleTemplate","trigger","keyboard","show","title","type","delay","autoClose","bsEnabled","viewport","selector","padding","$get","isTouch","TooltipFactory","$tooltip","$scope","$rootScope","$new","split","enterAnimateCallback","$emit","leaveAnimateCallback","_tipToHide","evt","preventDefault","destroyTipElement","triggers","nodeName","on","toggle","enter","unbindTriggerEvents","length","$onFocusElementMouseDown","off","i","bindKeyboardEvents","tipElement","$onKeyUp","unbindKeyboardEvents","_autoCloseEventsBinded","bindAutoCloseEvents","$timeout","$body","hide","unbindAutoCloseEvents","stopEventPropagation","event","getPosition","$element","elRect","getBoundingClientRect","rect","p","width","height","top","left","dimensions","offset","el","scroll","outerDims","isBody","document","documentElement","scrollTop","body","prop","clientWidth","innerHeight","position","actualWidth","actualHeight","marginLeft","isNaN","setOffset","using","parseInt","props","css","right","marginTop","tip","offsetHeight","getViewportAdjustedDelta","delta","offsetWidth","isVertical","arrowDelta","replaceArrow","arrowOffsetPosition","viewportDimensions","$viewport","topEdgeOffset","bottomEdgeOffset","viewportPadding","test","leftEdgeOffset","rightEdgeOffset","dimension","isHorizontal","$arrow","clearTimeout","timeout","$isShown","tipScope","$destroy","$$phase","$options","config","$promise","$bsCompiler","toLowerCase","$id","attr","map","parseFloat","$sce","trustAsHtml","$setEnabled","$$postDigest","id","$hide","setEnabled","isEnabled","hoverState","compileData","promise","tipContainer","init","container","bindTriggerEvents","isElement","destroy","focus","parent","after","lastChild","display","visibility","clonedElement","addClass","prefixClass","safeDigest","version","prepend","$$rAF","$applyPlacement","$animate","leave","_blur","blur","autoPlace","autoToken","elementPosition","tipWidth","tipHeight","viewportPosition","originalPlacement","removeClass","tipPosition","getCalculatedOffset","applyPlacement","stopPropagation","directive","$root","$digest","restrict","query","querySelectorAll","tooltip","transclusion","falseValueRegExp","isDefined","dataTarget","hasOwnProperty","oldValue","$observe","newValue","bsTooltip","bsShow","$watch","match","setViewport","$on","minLength","filter","limit","autoSelect","comparator","trimValue","$typeahead","parentScope","$resetMatches","$window","$matches","activate","$activeIndex","select","index","$select","matches","$isVisible","update","$render","equals","$onMouseDown","keyCode","isUndefined","$onKeyDown","TypeaheadFactory","array","isFunction","$filter","expression","results","postLink","require","bsOptions","parsedOptions","$parseOptions","typeahead","watchOptions","watchedOptions","$watchCollection","values","$match","ngModel","$modelValue","valuesFn","selectMode","$setViewValue","$viewValue","substring","displayValue","slice","$formatters","push","modelValue","selected","val","label","toString","useNative","timeType","timeFormat","timezone","modelTimeFormat","autoclose","minTime","maxTime","Infinity","hourStep","minuteStep","secondStep","roundDisplay","iconUp","iconDown","arrowBehavior","isNative","$timepicker","timepickerFactory","formatDate","format","viewDate","hour","startDate","getHours","meridian","coeff","selRange","end","start","setSelectionRange","collapse","selectionStart","moveStart","selectionEnd","moveEnd","focusElement","_init","floorMinutes","time","floor","lang","selectedIndex","date","defaultDate","second","getSeconds","millisecond","getMilliseconds","$dateValue","hoursFormat","$dateFormatter","timeSeparator","minute","minutesFormat","secondsFormat","showSeconds","$iconUp","$moveIndex","$switchMeridian","switchMeridian","isDate","getMinutes","getTime","$build","keep","Date","setHours","setMinutes","setSeconds","midIndex","hours","disabled","minutes","$date","seconds","rows","$isDisabled","showAM","$isSelected","isAM","selectedTime","$arrowAction","$setTimeByStep","newDate","targetDate","targetEl","triggerHandler","hoursLength","minutesLength","sepLength","lateralMove","count","selectRange","incr","isSeconds","isMeridian","secondsLength","createSelection","createTextRange","_destroy","_show","_hide","navigator","userAgent","isMaxValid","isValid","parsedTime","isMinValid","setFullYear","$setValidity","$parsers","unshift","viewValue","getTimeFormattedString","timepicker","dateParser","$dateParser","validateAgainstMinMaxTime","timezoneOffsetAdjust","NaN","parse","content","$popover","PopoverFactory","requestAnimationFrame","bsPopover","popover","self","navClass","activeClass","$activeClass","$panes","$activePaneChangeListeners","$push","pane","$active","$attrs","$navClass","$remove","active","activeIndex","indexOf","splice","$setActive","name","fn","$pane","$tab","transclude","ngModelCtrl","bsTabsCtrl","attrs","bsActivePane","parsedBsActivePane","assign","$parse","controllers","render","$isActive","spies","debounce","$document","windowEl","bodyEl","throttle","ScrollSpyFactory","scrollEl","isWindowSpy","scrollId","$$count","$scrollspy","unbindViewContentLoaded","unbindIncludeContentLoaded","trackedElements","sortedElements","activeTarget","debouncedCheckOffsets","viewportHeight","debouncedCheckPosition","throttledCheckPosition","checkPositionWithEventLoop","checkOffsets","checkPosition","docEl","$activateElement","offsetTop","setTimeout","activeElement","source","$getTrackedElement","targetElement","querySelector","trackedElement","b","trackElement","toDelete","untrackElement","scrollspy","childEl","child","multiple","allNoneButtons","sort","caretHtml","placeholder","allText","noneText","maxLength","maxLengthHtml","iconCheckmark","SelectFactory","$isMultiple","$showAllNoneButtons","$iconCheckmark","$allText","$activate","$selectNone","$updateActiveIndex","a","$apply","isArray","$selectScrollFix","$isIE","stopImmediatePropagation","ua","tagName","e","dataMultiple","inputEl","addEventListener","join","$getIndex","$isEmpty","dateType","dateFormat","modelDateFormat","dayFormat","monthFormat","yearFormat","monthTitleFormat","yearTitleFormat","strictFormat","minDate","maxDate","startView","minView","startWeek","daysOfWeekDisabled","iconLeft","iconRight","DatepickerFactory","$datepicker","pickerViews","views","$iconLeft","$iconRight","$picker","$views","$mode","datepickerViews","$selectPane","$toggleMode","setMode","updateDisabledDates","disabledDateRanges","dateRanges","year","getFullYear","month","getDate","mode","pristine","call","$updateSelected","built","$setDisabledEl","isDisabled","steps","getUTCFullYear","getUTCMonth","UTC","getUTCDate","shiftKey","altKey","onKeyDown","previousValue","normalizeDateRanges","ranges","disabledRanges","datepicker","parsedDate","getDateFormattedString","strict","validateAgainstMinMaxDate","disabledDates","size","arrays","mod","n","m","arr","weekDaysMin","weekdaysShort","weekDaysLabelsHtml","picker","weekDaysLabels","concat","getMonth","firstDayOfMonth","firstDayOfMonthOffset","getTimezoneOffset","firstDate","firstDateOffset","build","days","day","daylightSavingAdjust","isToday","toDateString","today","muted","showLabels","labels","isSelected","getDay","months","lastDate","actualMonth","firstYear","years","actualYear","Array","prototype","setYear","backdrop","bodyElement","backdropCount","dialogBaseZindex","ModalFactory","$modal","unbindBackdropEvents","modalElement","hideOnBackdropClick","backdropElement","preventEventDefault","modalScope","$show","bottom","destroyModalElement","z-index","backdropBaseZindex","customClass","minor","backdropAnimation","bindBackdropEvents","defaultPrevented","which","modalClass","bsModal","modal","routeAttr","$navbar","liElements","li","liElement","pattern","path","RegExp","regexp","dot","cancelAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","rafSupported","raf","timer","cancel","supported","$values","valueName","keyName","displayFn","valueFn","ParseOptionsFactory","groupByFn","factory","offsetParent","docElement","ownerDocument","outer","window","getComputedStyle","extra","currentStyle","boxRect","style","curPosition","curLeft","curCSSTop","curTop","calculatePosition","curElem","curCSSLeft","curOffset","offsetParentRect","offsetParentEl","offsetParentElement","func","immediate","args","context","callNow","leading","wait","trailing","$localeProvider","milliseconds","ParseDate","noop","indexOfCaseInsensitive","len","str","DateParserFactory","proto","isNumeric","toDate","regExpMap","sss","$locale","dateFilter","mm","literalRegex","formatParts","escapedLiteralFormat","dateElements","keys","escapedFormat","isFormatStringLiteral","part","trimLiteralEscapeChars","dateRegexParts","escapeReservedSymbols","text","re","abstractRegex","buildDateParseRegex","setMapForFormat","buildDateAbstractRegex","buildDateParseValuesMap","Object","valuesMatch","keyIndex","valueKey","valuesFunctionMap","valueFunction","valuesRegex","exec","setFnMap","setMap","HH","H","hh","h","EEEE","EEE","DATETIME_FORMATS","SHORTDAY","dd","d","MMMM","MMM","SHORTMONTH","MM","M","DAY","yyyy","yy","y","MONTH","ss","s","setDate","setMonth","regex","$format","regExpForFormat","baseDate","formatRegex","formatSetMap","fromDate","getDateForAttribute","substr","getTimeForAttribute","undo","getDefaultLocale","getDatetimeFormat","splitTimeFormat","service","allowMultiple","startCollapsed","activeIndexes","$targets","activeItems","activateItem","$collapse","$viewChangeListeners","$registerToggle","$toggles","$unregisterToggle","$unregisterTarget","deactivateItem","fixActiveItemIndexes","disallowToggle","isActive","$activeIndexes","bsCollapseCtrl","bsCollapseToggle","$registerTarget","action","matchesSelector","DropdownFactory","$dropdown","onBodyClick","items","parentEl","hasClass","tAttrs","nextSibling","nodeType","parentNode","removeChild","bsDropdown","dropdown","AsideFactory","$aside","bsAside","aside","$button","constantValueRegExp","isInput","trueValue","falseValue","hasExoticValues","checked","bind","toggleEvent","toggleClass","duration","dismissable","AlertFactory","$alert","bsAlert","alert","AffixFactory","$affix","inlineStyles","reset","initialOffsetTop","getRequiredAffixClass","_unpin","getScrollTop","scrollHeight","getScrollHeight","offsetBottom","elementHeight","initialAffixTop","pageYOffset","affixed","unpin","$parseOffsets","affix","setWidth","offsetUnpin","$onResize","$debouncedOnResize","initialPosition","affixTarget","option"],"mappings":"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","file":"angular-strap.min.js","sourcesContent":["(function(window, document, undefined) {\n'use strict';\n\n// Source: tooltip/tooltip.js\nangular.module('mgcrea.ngStrap.tooltip', ['mgcrea.ngStrap.core', 'mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$tooltip', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      customClass: '',\n      prefixClass: 'tooltip',\n      prefixEvent: 'tooltip',\n      container: false,\n      target: false,\n      placement: 'top',\n      templateUrl: 'tooltip/tooltip.tpl.html',\n      template: '',\n      titleTemplate: false,\n      trigger: 'hover focus',\n      keyboard: false,\n      html: false,\n      show: false,\n      title: '',\n      type: '',\n      delay: 0,\n      autoClose: false,\n      bsEnabled: true,\n      viewport: {\n        selector: 'body',\n        padding: 0\n      }\n    };\n\n    this.$get = function ($window, $rootScope, $bsCompiler, $q, $templateCache, $http, $animate, $sce, dimensions, $$rAF, $timeout) {\n\n      var isTouch = 'createTouch' in $window.document;\n      var $body = angular.element($window.document);\n\n      function TooltipFactory(element, config) {\n\n        var $tooltip = {};\n\n        // Common vars\n        var options = $tooltip.$options = angular.extend({}, defaults, config);\n        var promise = $tooltip.$promise = $bsCompiler.compile(options);\n        var scope = $tooltip.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n\n        var nodeName = element[0].nodeName.toLowerCase();\n        if (options.delay && angular.isString(options.delay)) {\n          var split = options.delay.split(',').map(parseFloat);\n          options.delay = split.length > 1 ? {show: split[0], hide: split[1]} : split[0];\n        }\n\n        // Store $id to identify the triggering element in events\n        // give priority to options.id, otherwise, try to use\n        // element id if defined\n        $tooltip.$id = options.id || element.attr('id') || '';\n\n        // Support scope as string options\n        if (options.title) {\n          scope.title = $sce.trustAsHtml(options.title);\n        }\n\n        // Provide scope helpers\n        scope.$setEnabled = function (isEnabled) {\n          scope.$$postDigest(function () {\n            $tooltip.setEnabled(isEnabled);\n          });\n        };\n        scope.$hide = function () {\n          scope.$$postDigest(function () {\n            $tooltip.hide();\n          });\n        };\n        scope.$show = function () {\n          scope.$$postDigest(function () {\n            $tooltip.show();\n          });\n        };\n        scope.$toggle = function () {\n          scope.$$postDigest(function () {\n            $tooltip.toggle();\n          });\n        };\n        // Publish isShown as a protected var on scope\n        $tooltip.$isShown = scope.$isShown = false;\n\n        // Private vars\n        var timeout;\n        var hoverState;\n\n        // Fetch, compile then initialize tooltip\n        var compileData;\n        var tipElement;\n        var tipContainer;\n        var tipScope;\n        promise.then(function (data) {\n          compileData = data;\n          $tooltip.init();\n        });\n\n        $tooltip.init = function () {\n\n          // Options: delay\n          if (options.delay && angular.isNumber(options.delay)) {\n            options.delay = {\n              show: options.delay,\n              hide: options.delay\n            };\n          }\n\n          // Replace trigger on touch devices ?\n          // if(isTouch && options.trigger === defaults.trigger) {\n          //   options.trigger.replace(/hover/g, 'click');\n          // }\n\n          // Options : container\n          if (options.container === 'self') {\n            tipContainer = element;\n          } else if (angular.isElement(options.container)) {\n            tipContainer = options.container;\n          } else if (options.container) {\n            tipContainer = findElement(options.container);\n          }\n\n          // Options: trigger\n          bindTriggerEvents();\n\n          // Options: target\n          if (options.target) {\n            options.target = angular.isElement(options.target) ? options.target : findElement(options.target);\n          }\n\n          // Options: show\n          if (options.show) {\n            scope.$$postDigest(function () {\n              if (options.trigger === 'focus') {\n                element[0].focus();\n              } else {\n                $tooltip.show();\n              }\n            });\n          }\n\n        };\n\n        $tooltip.destroy = function () {\n\n          // Unbind events\n          unbindTriggerEvents();\n\n          // Remove element\n          destroyTipElement();\n\n          // Destroy scope\n          scope.$destroy();\n\n        };\n\n        $tooltip.enter = function () {\n\n          clearTimeout(timeout);\n          hoverState = 'in';\n          if (!options.delay || !options.delay.show) {\n            return $tooltip.show();\n          }\n\n          timeout = setTimeout(function () {\n            if (hoverState === 'in') $tooltip.show();\n          }, options.delay.show);\n\n        };\n\n        $tooltip.show = function () {\n          if (!options.bsEnabled || $tooltip.$isShown) return;\n\n          scope.$emit(options.prefixEvent + '.show.before', $tooltip);\n          var parent;\n          var after;\n          if (options.container) {\n            parent = tipContainer;\n            if (tipContainer[0].lastChild) {\n              after = angular.element(tipContainer[0].lastChild);\n            } else {\n              after = null;\n            }\n          } else {\n            parent = null;\n            after = element;\n          }\n\n\n          // Hide any existing tipElement\n          if (tipElement) destroyTipElement();\n          // Fetch a cloned element linked from template\n          tipScope = $tooltip.$scope.$new();\n          tipElement = $tooltip.$element = compileData.link(tipScope, function (clonedElement, scope) {});\n\n          // Set the initial positioning.  Make the tooltip invisible\n          // so IE doesn't try to focus on it off screen.\n          tipElement.css({top: '-9999px', left: '-9999px', right: 'auto', display: 'block', visibility: 'hidden'});\n\n          // Options: animation\n          if (options.animation) tipElement.addClass(options.animation);\n          // Options: type\n          if (options.type) tipElement.addClass(options.prefixClass + '-' + options.type);\n          // Options: custom classes\n          if (options.customClass) tipElement.addClass(options.customClass);\n\n          // Append the element, without any animations.  If we append\n          // using $animate.enter, some of the animations cause the placement\n          // to be off due to the transforms.\n          if (after) {\n            after.after(tipElement);\n          } else {\n            parent.prepend(tipElement);\n          }\n\n          $tooltip.$isShown = scope.$isShown = true;\n          safeDigest(scope);\n\n          // Now, apply placement\n          $tooltip.$applyPlacement();\n\n          // Once placed, animate it.\n          // Support v1.2+ $animate\n          // https://github.com/angular/angular.js/issues/11713\n          if (angular.version.minor <= 2) {\n            $animate.enter(tipElement, parent, after, enterAnimateCallback);\n          } else {\n            $animate.enter(tipElement, parent, after).then(enterAnimateCallback);\n          }\n          safeDigest(scope);\n\n          $$rAF(function () {\n            // Once the tooltip is placed and the animation starts, make the tooltip visible\n            if (tipElement) tipElement.css({visibility: 'visible'});\n\n            // Bind events\n            if (options.keyboard) {\n              if (options.trigger !== 'focus') {\n                $tooltip.focus();\n              }\n              bindKeyboardEvents();\n            }\n          });\n\n          if (options.autoClose) {\n            bindAutoCloseEvents();\n          }\n\n        };\n\n        function enterAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.show', $tooltip);\n        }\n\n        $tooltip.leave = function () {\n\n          clearTimeout(timeout);\n          hoverState = 'out';\n          if (!options.delay || !options.delay.hide) {\n            return $tooltip.hide();\n          }\n          timeout = setTimeout(function () {\n            if (hoverState === 'out') {\n              $tooltip.hide();\n            }\n          }, options.delay.hide);\n\n        };\n\n        var _blur;\n        var _tipToHide;\n        $tooltip.hide = function (blur) {\n\n          if (!$tooltip.$isShown) return;\n          scope.$emit(options.prefixEvent + '.hide.before', $tooltip);\n\n          // store blur value for leaveAnimateCallback to use\n          _blur = blur;\n\n          // store current tipElement reference to use\n          // in leaveAnimateCallback\n          _tipToHide = tipElement;\n\n          // Support v1.2+ $animate\n          // https://github.com/angular/angular.js/issues/11713\n          if (angular.version.minor <= 2) {\n            $animate.leave(tipElement, leaveAnimateCallback);\n          } else {\n            $animate.leave(tipElement).then(leaveAnimateCallback);\n          }\n\n          $tooltip.$isShown = scope.$isShown = false;\n          safeDigest(scope);\n\n          // Unbind events\n          if (options.keyboard && tipElement !== null) {\n            unbindKeyboardEvents();\n          }\n\n          if (options.autoClose && tipElement !== null) {\n            unbindAutoCloseEvents();\n          }\n        };\n\n        function leaveAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.hide', $tooltip);\n\n          // check if current tipElement still references\n          // the same element when hide was called\n          if (tipElement === _tipToHide) {\n            // Allow to blur the input when hidden, like when pressing enter key\n            if (_blur && options.trigger === 'focus') {\n              return element[0].blur();\n            }\n\n            // clean up child scopes\n            destroyTipElement();\n          }\n        }\n\n        $tooltip.toggle = function (evt) {\n          if (evt) { evt.preventDefault(); }\n          if ($tooltip.$isShown) {\n            $tooltip.leave();\n          } else {\n            $tooltip.enter();\n          }\n        };\n\n        $tooltip.focus = function () {\n          tipElement[0].focus();\n        };\n\n        $tooltip.setEnabled = function (isEnabled) {\n          options.bsEnabled = isEnabled;\n        };\n\n        $tooltip.setViewport = function (viewport) {\n          options.viewport = viewport;\n        };\n\n        // Protected methods\n\n        $tooltip.$applyPlacement = function () {\n          if (!tipElement) return;\n\n          // Determine if we're doing an auto or normal placement\n          var placement = options.placement;\n          var autoToken = /\\s?auto?\\s?/i;\n          var autoPlace = autoToken.test(placement);\n\n          if (autoPlace) {\n            placement = placement.replace(autoToken, '') || defaults.placement;\n          }\n\n          // Need to add the position class before we get\n          // the offsets\n          tipElement.addClass(options.placement);\n\n          // Get the position of the target element\n          // and the height and width of the tooltip so we can center it.\n          var elementPosition = getPosition();\n          var tipWidth = tipElement.prop('offsetWidth');\n          var tipHeight = tipElement.prop('offsetHeight');\n\n          // Refresh viewport position\n          $tooltip.$viewport = options.viewport && findElement(options.viewport.selector || options.viewport);\n\n          // If we're auto placing, we need to check the positioning\n          if (autoPlace) {\n            var originalPlacement = placement;\n            var viewportPosition = getPosition($tooltip.$viewport);\n\n            if (/bottom/.test(originalPlacement) && elementPosition.bottom + tipHeight > viewportPosition.bottom) {\n              placement = originalPlacement.replace('bottom', 'top');\n            } else if (/top/.test(originalPlacement) && elementPosition.top - tipHeight < viewportPosition.top) {\n              placement = originalPlacement.replace('top', 'bottom');\n            }\n\n            if (/left/.test(originalPlacement) && elementPosition.left - tipWidth < viewportPosition.left) {\n              placement = placement.replace('left', 'right');\n            } else if (/right/.test(originalPlacement) && elementPosition.right + tipWidth > viewportPosition.width) {\n              placement = placement.replace('right', 'left');\n            }\n\n            tipElement.removeClass(originalPlacement).addClass(placement);\n          }\n\n          // Get the tooltip's top and left coordinates to center it with this directive.\n          var tipPosition = getCalculatedOffset(placement, elementPosition, tipWidth, tipHeight);\n          applyPlacement(tipPosition, placement);\n        };\n\n        $tooltip.$onKeyUp = function (evt) {\n          if (evt.which === 27 && $tooltip.$isShown) {\n            $tooltip.hide();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusKeyUp = function (evt) {\n          if (evt.which === 27) {\n            element[0].blur();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusElementMouseDown = function (evt) {\n          evt.preventDefault();\n          evt.stopPropagation();\n          // Some browsers do not auto-focus buttons (eg. Safari)\n          if ($tooltip.$isShown) {\n            element[0].blur();\n          } else {\n            element[0].focus();\n          }\n        };\n\n        // bind/unbind events\n        function bindTriggerEvents() {\n          var triggers = options.trigger.split(' ');\n          angular.forEach(triggers, function (trigger) {\n            if (trigger === 'click' || trigger === 'contextmenu') {\n              element.on(trigger, $tooltip.toggle);\n            } else if (trigger !== 'manual') {\n              element.on(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.on(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              if (nodeName === 'button' && trigger !== 'hover') {\n                element.on(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n              }\n            }\n          });\n        }\n\n        function unbindTriggerEvents() {\n          var triggers = options.trigger.split(' ');\n          for (var i = triggers.length; i--;) {\n            var trigger = triggers[i];\n            if (trigger === 'click' || trigger === 'contextmenu') {\n              element.off(trigger, $tooltip.toggle);\n            } else if (trigger !== 'manual') {\n              element.off(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.off(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              if (nodeName === 'button' && trigger !== 'hover') {\n                element.off(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n              }\n            }\n          }\n        }\n\n        function bindKeyboardEvents() {\n          if (options.trigger !== 'focus') {\n            tipElement.on('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.on('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        function unbindKeyboardEvents() {\n          if (options.trigger !== 'focus') {\n            tipElement.off('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.off('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        var _autoCloseEventsBinded = false;\n        function bindAutoCloseEvents() {\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function () {\n            // Stop propagation when clicking inside tooltip\n            tipElement.on('click', stopEventPropagation);\n\n            // Hide when clicking outside tooltip\n            $body.on('click', $tooltip.hide);\n\n            _autoCloseEventsBinded = true;\n          }, 0, false);\n        }\n\n        function unbindAutoCloseEvents() {\n          if (_autoCloseEventsBinded) {\n            tipElement.off('click', stopEventPropagation);\n            $body.off('click', $tooltip.hide);\n            _autoCloseEventsBinded = false;\n          }\n        }\n\n        function stopEventPropagation(event) {\n          event.stopPropagation();\n        }\n\n        // Private methods\n\n        function getPosition($element) {\n          $element = $element || (options.target || element);\n\n          var el = $element[0];\n          var isBody = el.tagName === 'BODY';\n\n          var elRect = el.getBoundingClientRect();\n          var rect = {};\n\n          // IE8 has issues with angular.extend and using elRect directly.\n          // By coping the values of elRect into a new object, we can continue to use extend\n          /* eslint-disable guard-for-in */\n          for (var p in elRect) {\n            // DO NOT use hasOwnProperty when inspecting the return of getBoundingClientRect.\n            rect[p] = elRect[p];\n          }\n          /* eslint-enable guard-for-in */\n\n          if (rect.width === null) {\n            // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093\n            rect = angular.extend({}, rect, {width: elRect.right - elRect.left, height: elRect.bottom - elRect.top});\n          }\n          var elOffset = isBody ? {top: 0, left: 0} : dimensions.offset(el);\n          var scroll = {scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.prop('scrollTop') || 0};\n          var outerDims = isBody ? {width: document.documentElement.clientWidth, height: $window.innerHeight} : null;\n\n          return angular.extend({}, rect, scroll, outerDims, elOffset);\n        }\n\n        function getCalculatedOffset(placement, position, actualWidth, actualHeight) {\n          var offset;\n          var split = placement.split('-');\n\n          switch (split[0]) {\n            case 'right':\n              offset = {\n                top: position.top + position.height / 2 - actualHeight / 2,\n                left: position.left + position.width\n              };\n              break;\n            case 'bottom':\n              offset = {\n                top: position.top + position.height,\n                left: position.left + position.width / 2 - actualWidth / 2\n              };\n              break;\n            case 'left':\n              offset = {\n                top: position.top + position.height / 2 - actualHeight / 2,\n                left: position.left - actualWidth\n              };\n              break;\n            default:\n              offset = {\n                top: position.top - actualHeight,\n                left: position.left + position.width / 2 - actualWidth / 2\n              };\n              break;\n          }\n\n          if (!split[1]) {\n            return offset;\n          }\n\n          // Add support for corners @todo css\n          if (split[0] === 'top' || split[0] === 'bottom') {\n            switch (split[1]) {\n              case 'left':\n                offset.left = position.left;\n                break;\n              case 'right':\n                offset.left = position.left + position.width - actualWidth;\n                break;\n              default:\n                break;\n            }\n          } else if (split[0] === 'left' || split[0] === 'right') {\n            switch (split[1]) {\n              case 'top':\n                offset.top = position.top - actualHeight + position.height;\n                break;\n              case 'bottom':\n                offset.top = position.top;\n                break;\n              default:\n                break;\n            }\n          }\n\n          return offset;\n        }\n\n        function applyPlacement(offset, placement) {\n          var tip = tipElement[0];\n          var width = tip.offsetWidth;\n          var height = tip.offsetHeight;\n\n          // manually read margins because getBoundingClientRect includes difference\n          var marginTop = parseInt(dimensions.css(tip, 'margin-top'), 10);\n          var marginLeft = parseInt(dimensions.css(tip, 'margin-left'), 10);\n\n          // we must check for NaN for ie 8/9\n          if (isNaN(marginTop)) marginTop = 0;\n          if (isNaN(marginLeft)) marginLeft = 0;\n\n          offset.top = offset.top + marginTop;\n          offset.left = offset.left + marginLeft;\n\n          // dimensions setOffset doesn't round pixel values\n          // so we use setOffset directly with our own function\n          dimensions.setOffset(tip, angular.extend({\n            using: function (props) {\n              tipElement.css({\n                top: Math.round(props.top) + 'px',\n                left: Math.round(props.left) + 'px',\n                right: ''\n              });\n            }\n          }, offset), 0);\n\n          // check to see if placing tip in new offset caused the tip to resize itself\n          var actualWidth = tip.offsetWidth;\n          var actualHeight = tip.offsetHeight;\n\n          if (placement === 'top' && actualHeight !== height) {\n            offset.top = offset.top + height - actualHeight;\n          }\n\n          // If it's an exotic placement, exit now instead of\n          // applying a delta and changing the arrow\n          if (/top-left|top-right|bottom-left|bottom-right/.test(placement)) return;\n\n          var delta = getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);\n\n          if (delta.left) {\n            offset.left += delta.left;\n          } else {\n            offset.top += delta.top;\n          }\n\n          dimensions.setOffset(tip, offset);\n\n          if (/top|right|bottom|left/.test(placement)) {\n            var isVertical = /top|bottom/.test(placement);\n            var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight;\n            var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';\n\n            replaceArrow(arrowDelta, tip[arrowOffsetPosition], isVertical);\n          }\n        }\n\n        // @source https://github.com/twbs/bootstrap/blob/v3.3.5/js/tooltip.js#L380\n        function getViewportAdjustedDelta(placement, position, actualWidth, actualHeight) {\n          var delta = {top: 0, left: 0};\n          if (!$tooltip.$viewport) return delta;\n\n          var viewportPadding = options.viewport && options.viewport.padding || 0;\n          var viewportDimensions = getPosition($tooltip.$viewport);\n\n          if (/right|left/.test(placement)) {\n            var topEdgeOffset = position.top - viewportPadding - viewportDimensions.scroll;\n            var bottomEdgeOffset = position.top + viewportPadding - viewportDimensions.scroll + actualHeight;\n            if (topEdgeOffset < viewportDimensions.top) { // top overflow\n              delta.top = viewportDimensions.top - topEdgeOffset;\n            } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow\n              delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;\n            }\n          } else {\n            var leftEdgeOffset = position.left - viewportPadding;\n            var rightEdgeOffset = position.left + viewportPadding + actualWidth;\n            if (leftEdgeOffset < viewportDimensions.left) { // left overflow\n              delta.left = viewportDimensions.left - leftEdgeOffset;\n            } else if (rightEdgeOffset > viewportDimensions.right) { // right overflow\n              delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;\n            }\n          }\n\n          return delta;\n        }\n\n        function replaceArrow(delta, dimension, isHorizontal) {\n          var $arrow = findElement('.tooltip-arrow, .arrow', tipElement[0]);\n\n          $arrow.css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')\n                .css(isHorizontal ? 'top' : 'left', '');\n        }\n\n        function destroyTipElement() {\n          // Cancel pending callbacks\n          clearTimeout(timeout);\n\n          if ($tooltip.$isShown && tipElement !== null) {\n            if (options.autoClose) {\n              unbindAutoCloseEvents();\n            }\n\n            if (options.keyboard) {\n              unbindKeyboardEvents();\n            }\n          }\n\n          if (tipScope) {\n            tipScope.$destroy();\n            tipScope = null;\n          }\n\n          if (tipElement) {\n            tipElement.remove();\n            tipElement = $tooltip.$element = null;\n          }\n        }\n\n        return $tooltip;\n\n      }\n\n      // Helper functions\n\n      function safeDigest(scope) {\n        /* eslint-disable no-unused-expressions */\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n        /* eslint-enable no-unused-expressions */\n      }\n\n      function findElement(query, element) {\n        return angular.element((element || document).querySelectorAll(query));\n      }\n\n      return TooltipFactory;\n\n    };\n\n  })\n\n  .directive('bsTooltip', function ($window, $location, $sce, $tooltip, $$rAF) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n\n        var tooltip;\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'titleTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'backdropAnimation', 'type', 'customClass', 'id'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\n            options[key] = false;\n          }\n        });\n\n        // should not parse target attribute (anchor tag), only data-target #1454\n        var dataTarget = element.attr('data-target');\n        if (angular.isDefined(dataTarget)) {\n          if (falseValueRegExp.test(dataTarget)) {\n            options.target = false;\n          } else {\n            options.target = dataTarget;\n          }\n        }\n\n        // overwrite inherited title value when no value specified\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\n        if (!scope.hasOwnProperty('title')) {\n          scope.title = '';\n        }\n\n        // Observe scope attributes for change\n        attr.$observe('title', function (newValue) {\n          if (angular.isDefined(newValue) || !scope.hasOwnProperty('title')) {\n            var oldValue = scope.title;\n            scope.title = $sce.trustAsHtml(newValue);\n            if (angular.isDefined(oldValue)) {\n              $$rAF(function () {\n                if (tooltip) tooltip.$applyPlacement();\n              });\n            }\n          }\n        });\n\n        attr.$observe('disabled', function (newValue) {\n          if (newValue && tooltip.$isShown) {\n            tooltip.hide();\n          }\n        });\n\n        // Support scope as an object\n        if (attr.bsTooltip) {\n          scope.$watch(attr.bsTooltip, function (newValue, oldValue) {\n            if (angular.isObject(newValue)) {\n              angular.extend(scope, newValue);\n            } else {\n              scope.title = newValue;\n            }\n            if (angular.isDefined(oldValue)) {\n              $$rAF(function () {\n                if (tooltip) tooltip.$applyPlacement();\n              });\n            }\n          }, true);\n        }\n\n        // Visibility binding support\n        if (attr.bsShow) {\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\n            if (!tooltip || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(tooltip),?/i);\n            if (newValue === true) {\n              tooltip.show();\n            } else {\n              tooltip.hide();\n            }\n          });\n        }\n\n        // Enabled binding support\n        if (attr.bsEnabled) {\n          scope.$watch(attr.bsEnabled, function (newValue, oldValue) {\n            // console.warn('scope.$watch(%s)', attr.bsEnabled, newValue, oldValue);\n            if (!tooltip || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(tooltip),?/i);\n            if (newValue === false) {\n              tooltip.setEnabled(false);\n            } else {\n              tooltip.setEnabled(true);\n            }\n          });\n        }\n\n        // Viewport support\n        if (attr.viewport) {\n          scope.$watch(attr.viewport, function (newValue) {\n            if (!tooltip || !angular.isDefined(newValue)) return;\n            tooltip.setViewport(newValue);\n          });\n        }\n\n        // Initialize popover\n        tooltip = $tooltip(element, options);\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (tooltip) tooltip.destroy();\n          options = null;\n          tooltip = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: typeahead/typeahead.js\nangular.module('mgcrea.ngStrap.typeahead', ['mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions'])\n\n  .provider('$typeahead', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'typeahead',\n      prefixEvent: '$typeahead',\n      placement: 'bottom-left',\n      templateUrl: 'typeahead/typeahead.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      minLength: 1,\n      filter: 'bsAsyncFilter',\n      limit: 6,\n      autoSelect: false,\n      comparator: '',\n      trimValue: true\n    };\n\n    this.$get = function ($window, $rootScope, $tooltip, $$rAF, $timeout) {\n\n      function TypeaheadFactory(element, controller, config) {\n\n        var $typeahead = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $typeahead = $tooltip(element, options);\n        var parentScope = config.scope;\n        var scope = $typeahead.$scope;\n\n        scope.$resetMatches = function () {\n          scope.$matches = [];\n          scope.$activeIndex = options.autoSelect ? 0 : -1; // If set to 0, the first match will be highlighted\n        };\n        scope.$resetMatches();\n\n        scope.$activate = function (index) {\n          scope.$$postDigest(function () {\n            $typeahead.activate(index);\n          });\n        };\n\n        scope.$select = function (index, evt) {\n          scope.$$postDigest(function () {\n            $typeahead.select(index);\n          });\n        };\n\n        scope.$isVisible = function () {\n          return $typeahead.$isVisible();\n        };\n\n        // Public methods\n\n        $typeahead.update = function (matches) {\n          scope.$matches = matches;\n          if (scope.$activeIndex >= matches.length) {\n            scope.$activeIndex = options.autoSelect ? 0 : -1;\n          }\n\n          // wrap in a $timeout so the results are updated\n          // before repositioning\n          safeDigest(scope);\n          $$rAF($typeahead.$applyPlacement);\n        };\n\n        $typeahead.activate = function (index) {\n          scope.$activeIndex = index;\n        };\n\n        $typeahead.select = function (index) {\n          if (index === -1) return;\n          var value = scope.$matches[index].value;\n          // console.log('$setViewValue', value);\n          controller.$setViewValue(value);\n          controller.$render();\n          scope.$resetMatches();\n          if (parentScope) parentScope.$digest();\n          // Emit event\n          scope.$emit(options.prefixEvent + '.select', value, index, $typeahead);\n        };\n\n        // Protected methods\n\n        $typeahead.$isVisible = function () {\n          if (!options.minLength || !controller) {\n            return !!scope.$matches.length;\n          }\n          // minLength support\n          return scope.$matches.length && angular.isString(controller.$viewValue) && controller.$viewValue.length >= options.minLength;\n        };\n\n        $typeahead.$getIndex = function (value) {\n          var index;\n          for (index = scope.$matches.length; index--;) {\n            if (angular.equals(scope.$matches[index].value, value)) break;\n          }\n          return index;\n        };\n\n        $typeahead.$onMouseDown = function (evt) {\n          // Prevent blur on mousedown\n          evt.preventDefault();\n          evt.stopPropagation();\n        };\n\n        $typeahead.$onKeyDown = function (evt) {\n          if (!/(38|40|13)/.test(evt.keyCode)) return;\n\n          // Let ngSubmit pass if the typeahead tip is hidden or no option is selected\n          if ($typeahead.$isVisible() && !(evt.keyCode === 13 && scope.$activeIndex === -1)) {\n            evt.preventDefault();\n            evt.stopPropagation();\n          }\n\n          // Select with enter\n          if (evt.keyCode === 13 && scope.$matches.length) {\n            $typeahead.select(scope.$activeIndex);\n          }\n\n          // Navigate with keyboard\n          else if (evt.keyCode === 38 && scope.$activeIndex > 0) scope.$activeIndex--;\n          else if (evt.keyCode === 40 && scope.$activeIndex < scope.$matches.length - 1) scope.$activeIndex++;\n          else if (angular.isUndefined(scope.$activeIndex)) scope.$activeIndex = 0;\n          scope.$digest();\n        };\n\n        // Overrides\n\n        var show = $typeahead.show;\n        $typeahead.show = function () {\n          show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed immediately.\n          $timeout(function () {\n            if ($typeahead.$element) {\n              $typeahead.$element.on('mousedown', $typeahead.$onMouseDown);\n              if (options.keyboard) {\n                if (element) element.on('keydown', $typeahead.$onKeyDown);\n              }\n            }\n          }, 0, false);\n        };\n\n        var hide = $typeahead.hide;\n        $typeahead.hide = function () {\n          if ($typeahead.$element) $typeahead.$element.off('mousedown', $typeahead.$onMouseDown);\n          if (options.keyboard) {\n            if (element) element.off('keydown', $typeahead.$onKeyDown);\n          }\n          if (!options.autoSelect) {\n            $typeahead.activate(-1);\n          }\n          hide();\n        };\n\n        return $typeahead;\n\n      }\n\n      // Helper functions\n\n      function safeDigest(scope) {\n        /* eslint-disable no-unused-expressions */\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n        /* eslint-enable no-unused-expressions */\n      }\n\n      TypeaheadFactory.defaults = defaults;\n      return TypeaheadFactory;\n\n    };\n\n  })\n\n  .filter('bsAsyncFilter', function ($filter) {\n    return function (array, expression, comparator) {\n      if (array && angular.isFunction(array.then)) {\n        return array.then(function (results) {\n          return $filter('filter')(results, expression, comparator);\n        });\n      }\n      return $filter('filter')(array, expression, comparator);\n    };\n  })\n\n  .directive('bsTypeahead', function ($window, $parse, $q, $typeahead, $parseOptions) {\n\n    var defaults = $typeahead.defaults;\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = {\n          scope: scope\n        };\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'filter', 'limit', 'minLength', 'watchOptions', 'selectMode', 'autoSelect', 'comparator', 'id', 'prefixEvent', 'prefixClass'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'trimValue'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\n        });\n\n        // Disable browser autocompletion\n        if (!element.attr('autocomplete')) element.attr('autocomplete', 'off');\n\n        // Build proper bsOptions\n        var filter = options.filter || defaults.filter;\n        var limit = options.limit || defaults.limit;\n        var comparator = options.comparator || defaults.comparator;\n\n        var bsOptions = attr.bsOptions;\n        if (filter) bsOptions += ' | ' + filter + ':$viewValue';\n        if (comparator) bsOptions += ':' + comparator;\n        if (limit) bsOptions += ' | limitTo:' + limit;\n        var parsedOptions = $parseOptions(bsOptions);\n\n        // Initialize typeahead\n        var typeahead = $typeahead(element, controller, options);\n\n        // Watch options on demand\n        if (options.watchOptions) {\n          // Watch bsOptions values before filtering for changes, drop function calls\n          var watchedOptions = parsedOptions.$match[7].replace(/\\|.+/, '').replace(/\\(.*\\)/g, '').trim();\n          scope.$watchCollection(watchedOptions, function (newValue, oldValue) {\n            // console.warn('scope.$watch(%s)', watchedOptions, newValue, oldValue);\n            parsedOptions.valuesFn(scope, controller).then(function (values) {\n              typeahead.update(values);\n              controller.$render();\n            });\n          });\n        }\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\n          // console.warn('$watch', element.attr('ng-model'), newValue);\n          scope.$modelValue = newValue; // Publish modelValue on scope for custom templates\n          parsedOptions.valuesFn(scope, controller)\n            .then(function (values) {\n              // Prevent input with no future prospect if selectMode is truthy\n              // @TODO test selectMode\n              if (options.selectMode && !values.length && newValue.length > 0) {\n                controller.$setViewValue(controller.$viewValue.substring(0, controller.$viewValue.length - 1));\n                return;\n              }\n              if (values.length > limit) values = values.slice(0, limit);\n              typeahead.update(values);\n              // Queue a new rendering that will leverage collection loading\n              controller.$render();\n            });\n        });\n\n        // modelValue -> $formatters -> viewValue\n        controller.$formatters.push(function (modelValue) {\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n          var displayValue = parsedOptions.displayValue(modelValue);\n\n          // If we can determine the displayValue, use that\n          if (displayValue) {\n            return displayValue;\n          }\n\n          // If there's no display value, attempt to use the modelValue.\n          // If the model is an object not much we can do\n          if (modelValue && typeof modelValue !== 'object') {\n            return modelValue;\n          }\n          return '';\n        });\n\n        // Model rendering in view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          if (controller.$isEmpty(controller.$viewValue)) {\n            return element.val('');\n          }\n          var index = typeahead.$getIndex(controller.$modelValue);\n          var selected = index !== -1 ? typeahead.$scope.$matches[index].label : controller.$viewValue;\n          selected = angular.isObject(selected) ? parsedOptions.displayValue(selected) : selected;\n          var value = selected ? selected.toString().replace(/<(?:.|\\n)*?>/gm, '') : '';\n          element.val(options.trimValue === false ? value : value.trim());\n        };\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (typeahead) typeahead.destroy();\n          options = null;\n          typeahead = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: timepicker/timepicker.js\nangular.module('mgcrea.ngStrap.timepicker', ['mgcrea.ngStrap.helpers.dateParser', 'mgcrea.ngStrap.helpers.dateFormatter', 'mgcrea.ngStrap.tooltip'])\n\n  .provider('$timepicker', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      // uncommenting the following line will break backwards compatability\n      // prefixEvent: 'timepicker',\n      prefixClass: 'timepicker',\n      placement: 'bottom-left',\n      templateUrl: 'timepicker/timepicker.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      // lang: $locale.id,\n      useNative: true,\n      timeType: 'date',\n      timeFormat: 'shortTime',\n      timezone: null,\n      modelTimeFormat: null,\n      autoclose: false,\n      minTime: -Infinity,\n      maxTime: +Infinity,\n      length: 5,\n      hourStep: 1,\n      minuteStep: 5,\n      secondStep: 5,\n      roundDisplay: false,\n      iconUp: 'glyphicon glyphicon-chevron-up',\n      iconDown: 'glyphicon glyphicon-chevron-down',\n      arrowBehavior: 'pager'\n    };\n\n    this.$get = function ($window, $document, $rootScope, $sce, $dateFormatter, $tooltip, $timeout) {\n\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n      if (!defaults.lang) {\n        defaults.lang = $dateFormatter.getDefaultLocale();\n      }\n\n      function timepickerFactory(element, controller, config) {\n\n        var $timepicker = $tooltip(element, angular.extend({}, defaults, config));\n        var parentScope = config.scope;\n        var options = $timepicker.$options;\n        var scope = $timepicker.$scope;\n\n        var lang = options.lang;\n        var formatDate = function (date, format, timezone) {\n          return $dateFormatter.formatDate(date, format, lang, timezone);\n        };\n\n        function floorMinutes(time) {\n          // coeff used to floor current time to nearest minuteStep interval\n          var coeff = 1000 * 60 * options.minuteStep;\n          return new Date(Math.floor(time.getTime() / coeff) * coeff);\n        }\n\n        // View vars\n\n        var selectedIndex = 0;\n        var defaultDate = options.roundDisplay ? floorMinutes(new Date()) : new Date();\n        var startDate = controller.$dateValue || defaultDate;\n        var viewDate = {\n          hour: startDate.getHours(),\n          meridian: startDate.getHours() < 12,\n          minute: startDate.getMinutes(),\n          second: startDate.getSeconds(),\n          millisecond: startDate.getMilliseconds()\n        };\n\n        var format = $dateFormatter.getDatetimeFormat(options.timeFormat, lang);\n\n        var hoursFormat = $dateFormatter.hoursFormat(format);\n        var timeSeparator = $dateFormatter.timeSeparator(format);\n        var minutesFormat = $dateFormatter.minutesFormat(format);\n        var secondsFormat = $dateFormatter.secondsFormat(format);\n        var showSeconds = $dateFormatter.showSeconds(format);\n        var showAM = $dateFormatter.showAM(format);\n\n        scope.$iconUp = options.iconUp;\n        scope.$iconDown = options.iconDown;\n\n        // Scope methods\n\n        scope.$select = function (date, index) {\n          $timepicker.select(date, index);\n        };\n        scope.$moveIndex = function (value, index) {\n          $timepicker.$moveIndex(value, index);\n        };\n        scope.$switchMeridian = function (date) {\n          $timepicker.switchMeridian(date);\n        };\n\n        // Public methods\n\n        $timepicker.update = function (date) {\n          // console.warn('$timepicker.update() newValue=%o', date);\n          if (angular.isDate(date) && !isNaN(date.getTime())) {\n            $timepicker.$date = date;\n            angular.extend(viewDate, {\n              hour: date.getHours(),\n              minute: date.getMinutes(),\n              second: date.getSeconds(),\n              millisecond: date.getMilliseconds()\n            });\n            $timepicker.$build();\n          } else if (!$timepicker.$isBuilt) {\n            $timepicker.$build();\n          }\n        };\n\n        $timepicker.select = function (date, index, keep) {\n          // console.warn('$timepicker.select', date, scope.$mode);\n          if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) controller.$dateValue = new Date(1970, 0, 1);\n          if (!angular.isDate(date)) date = new Date(date);\n          if (index === 0) controller.$dateValue.setHours(date.getHours());\n          else if (index === 1) controller.$dateValue.setMinutes(date.getMinutes());\n          else if (index === 2) controller.$dateValue.setSeconds(date.getSeconds());\n          controller.$setViewValue(angular.copy(controller.$dateValue));\n          controller.$render();\n          if (options.autoclose && !keep) {\n            $timeout(function () {\n              $timepicker.hide(true);\n            });\n          }\n        };\n\n        $timepicker.switchMeridian = function (date) {\n          if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) {\n            return;\n          }\n          var hours = (date || controller.$dateValue).getHours();\n          controller.$dateValue.setHours(hours < 12 ? hours + 12 : hours - 12);\n          controller.$setViewValue(angular.copy(controller.$dateValue));\n          controller.$render();\n        };\n\n        // Protected methods\n\n        $timepicker.$build = function () {\n          // console.warn('$timepicker.$build() viewDate=%o', viewDate);\n          var i;\n          var midIndex = scope.midIndex = parseInt(options.length / 2, 10);\n          var hours = [];\n          var hour;\n          for (i = 0; i < options.length; i++) {\n            hour = new Date(1970, 0, 1, viewDate.hour - (midIndex - i) * options.hourStep);\n            hours.push({\n              date: hour,\n              label: formatDate(hour, hoursFormat),\n              selected: $timepicker.$date && $timepicker.$isSelected(hour, 0),\n              disabled: $timepicker.$isDisabled(hour, 0)\n            });\n          }\n          var minutes = [];\n          var minute;\n          for (i = 0; i < options.length; i++) {\n            minute = new Date(1970, 0, 1, 0, viewDate.minute - (midIndex - i) * options.minuteStep);\n            minutes.push({\n              date: minute,\n              label: formatDate(minute, minutesFormat),\n              selected: $timepicker.$date && $timepicker.$isSelected(minute, 1),\n              disabled: $timepicker.$isDisabled(minute, 1)\n            });\n          }\n          var seconds = [];\n          var second;\n          for (i = 0; i < options.length; i++) {\n            second = new Date(1970, 0, 1, 0, 0, viewDate.second - (midIndex - i) * options.secondStep);\n            seconds.push({\n              date: second,\n              label: formatDate(second, secondsFormat),\n              selected: $timepicker.$date && $timepicker.$isSelected(second, 2),\n              disabled: $timepicker.$isDisabled(second, 2)\n            });\n          }\n\n          var rows = [];\n          for (i = 0; i < options.length; i++) {\n            if (showSeconds) {\n              rows.push([hours[i], minutes[i], seconds[i]]);\n            } else {\n              rows.push([hours[i], minutes[i]]);\n            }\n          }\n          scope.rows = rows;\n          scope.showSeconds = showSeconds;\n          scope.showAM = showAM;\n          scope.isAM = ($timepicker.$date || hours[midIndex].date).getHours() < 12;\n          scope.timeSeparator = timeSeparator;\n          $timepicker.$isBuilt = true;\n        };\n\n        $timepicker.$isSelected = function (date, index) {\n          if (!$timepicker.$date) return false;\n          else if (index === 0) {\n            return date.getHours() === $timepicker.$date.getHours();\n          } else if (index === 1) {\n            return date.getMinutes() === $timepicker.$date.getMinutes();\n          } else if (index === 2) {\n            return date.getSeconds() === $timepicker.$date.getSeconds();\n          }\n        };\n\n        $timepicker.$isDisabled = function (date, index) {\n          var selectedTime;\n          if (index === 0) {\n            selectedTime = date.getTime() + viewDate.minute * 6e4 + viewDate.second * 1e3;\n          } else if (index === 1) {\n            selectedTime = date.getTime() + viewDate.hour * 36e5 + viewDate.second * 1e3;\n          } else if (index === 2) {\n            selectedTime = date.getTime() + viewDate.hour * 36e5 + viewDate.minute * 6e4;\n          }\n          return selectedTime < options.minTime * 1 || selectedTime > options.maxTime * 1;\n        };\n\n        scope.$arrowAction = function (value, index) {\n          if (options.arrowBehavior === 'picker') {\n            $timepicker.$setTimeByStep(value, index);\n          } else {\n            $timepicker.$moveIndex(value, index);\n          }\n        };\n\n        $timepicker.$setTimeByStep = function (value, index) {\n          var newDate = new Date($timepicker.$date || startDate);\n          var hours = newDate.getHours();\n          var minutes = newDate.getMinutes();\n          var seconds = newDate.getSeconds();\n          if (index === 0) {\n            newDate.setHours(hours - (parseInt(options.hourStep, 10) * value));\n          } else if (index === 1) {\n            newDate.setMinutes(minutes - (parseInt(options.minuteStep, 10) * value));\n          } else if (index === 2) {\n            newDate.setSeconds(seconds - (parseInt(options.secondStep, 10) * value));\n          }\n          $timepicker.select(newDate, index, true);\n        };\n\n        $timepicker.$moveIndex = function (value, index) {\n          var targetDate;\n          if (index === 0) {\n            targetDate = new Date(1970, 0, 1, viewDate.hour + (value * options.length), viewDate.minute, viewDate.second);\n            angular.extend(viewDate, {\n              hour: targetDate.getHours()\n            });\n          } else if (index === 1) {\n            targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute + (value * options.length * options.minuteStep), viewDate.second);\n            angular.extend(viewDate, {\n              minute: targetDate.getMinutes()\n            });\n          } else if (index === 2) {\n            targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute, viewDate.second + (value * options.length * options.secondStep));\n            angular.extend(viewDate, {\n              second: targetDate.getSeconds()\n            });\n          }\n          $timepicker.$build();\n        };\n\n        $timepicker.$onMouseDown = function (evt) {\n          // Prevent blur on mousedown on .dropdown-menu\n          if (evt.target.nodeName.toLowerCase() !== 'input') evt.preventDefault();\n          evt.stopPropagation();\n          // Emulate click for mobile devices\n          if (isTouch) {\n            var targetEl = angular.element(evt.target);\n            if (targetEl[0].nodeName.toLowerCase() !== 'button') {\n              targetEl = targetEl.parent();\n            }\n            targetEl.triggerHandler('click');\n          }\n        };\n\n        $timepicker.$onKeyDown = function (evt) {\n          if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          // Close on enter\n          if (evt.keyCode === 13) {\n            $timepicker.hide(true);\n            return;\n          }\n\n          // Navigate with keyboard\n          var newDate = new Date($timepicker.$date);\n          var hours = newDate.getHours();\n          var hoursLength = formatDate(newDate, hoursFormat).length;\n          var minutes = newDate.getMinutes();\n          var minutesLength = formatDate(newDate, minutesFormat).length;\n          var seconds = newDate.getSeconds();\n          var secondsLength = formatDate(newDate, secondsFormat).length;\n          var sepLength = 1;\n          var lateralMove = /(37|39)/.test(evt.keyCode);\n          var count = 2 + showSeconds * 1 + showAM * 1;\n\n          // Navigate indexes (left, right)\n          if (lateralMove) {\n            if (evt.keyCode === 37) selectedIndex = selectedIndex < 1 ? count - 1 : selectedIndex - 1;\n            else if (evt.keyCode === 39) selectedIndex = selectedIndex < count - 1 ? selectedIndex + 1 : 0;\n          }\n\n          // Update values (up, down)\n          var selectRange = [0, hoursLength];\n          var incr = 0;\n          if (evt.keyCode === 38) incr = -1;\n          if (evt.keyCode === 40) incr = +1;\n          var isSeconds = selectedIndex === 2 && showSeconds;\n          var isMeridian = selectedIndex === 2 && !showSeconds || selectedIndex === 3 && showSeconds;\n          if (selectedIndex === 0) {\n            newDate.setHours(hours + incr * parseInt(options.hourStep, 10));\n            // re-calculate hours length because we have changed hours value\n            hoursLength = formatDate(newDate, hoursFormat).length;\n            selectRange = [0, hoursLength];\n          } else if (selectedIndex === 1) {\n            newDate.setMinutes(minutes + incr * parseInt(options.minuteStep, 10));\n            // re-calculate minutes length because we have changes minutes value\n            minutesLength = formatDate(newDate, minutesFormat).length;\n            selectRange = [hoursLength + sepLength, minutesLength];\n          } else if (isSeconds) {\n            newDate.setSeconds(seconds + incr * parseInt(options.secondStep, 10));\n            // re-calculate seconds length because we have changes seconds value\n            secondsLength = formatDate(newDate, secondsFormat).length;\n            selectRange = [hoursLength + sepLength + minutesLength + sepLength, secondsLength];\n          } else if (isMeridian) {\n            if (!lateralMove) $timepicker.switchMeridian();\n            selectRange = [hoursLength + sepLength + minutesLength + sepLength + (secondsLength + sepLength) * showSeconds, 2];\n          }\n          $timepicker.select(newDate, selectedIndex, true);\n          createSelection(selectRange[0], selectRange[1]);\n          parentScope.$digest();\n        };\n\n        // Private\n\n        function createSelection(start, length) {\n          var end = start + length;\n          if (element[0].createTextRange) {\n            var selRange = element[0].createTextRange();\n            selRange.collapse(true);\n            selRange.moveStart('character', start);\n            selRange.moveEnd('character', end);\n            selRange.select();\n          } else if (element[0].setSelectionRange) {\n            element[0].setSelectionRange(start, end);\n          } else if (angular.isUndefined(element[0].selectionStart)) {\n            element[0].selectionStart = start;\n            element[0].selectionEnd = end;\n          }\n        }\n\n        function focusElement() {\n          element[0].focus();\n        }\n\n        // Overrides\n\n        var _init = $timepicker.init;\n        $timepicker.init = function () {\n          if (isNative && options.useNative) {\n            element.prop('type', 'time');\n            element.css('-webkit-appearance', 'textfield');\n            return;\n          } else if (isTouch) {\n            element.prop('type', 'text');\n            element.attr('readonly', 'true');\n            element.on('click', focusElement);\n          }\n          _init();\n        };\n\n        var _destroy = $timepicker.destroy;\n        $timepicker.destroy = function () {\n          if (isNative && options.useNative) {\n            element.off('click', focusElement);\n          }\n          _destroy();\n        };\n\n        var _show = $timepicker.show;\n        $timepicker.show = function () {\n          if ((!isTouch && element.attr('readonly')) || element.attr('disabled')) return;\n          _show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function () {\n            if ($timepicker.$element) $timepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\n            if (options.keyboard) {\n              if (element) element.on('keydown', $timepicker.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var _hide = $timepicker.hide;\n        $timepicker.hide = function (blur) {\n          if (!$timepicker.$isShown) return;\n          if ($timepicker.$element) $timepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\n          if (options.keyboard) {\n            if (element) element.off('keydown', $timepicker.$onKeyDown);\n          }\n          _hide(blur);\n        };\n\n        return $timepicker;\n\n      }\n\n      timepickerFactory.defaults = defaults;\n      return timepickerFactory;\n\n    };\n\n  })\n\n\n  .directive('bsTimepicker', function ($window, $parse, $q, $dateFormatter, $dateParser, $timepicker) {\n\n    var defaults = $timepicker.defaults;\n    var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = {\n          scope: scope\n        };\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'autoclose', 'timeType', 'timeFormat', 'timezone', 'modelTimeFormat', 'useNative', 'hourStep', 'minuteStep', 'secondStep', 'length', 'arrowBehavior', 'iconUp', 'iconDown', 'roundDisplay', 'id', 'prefixClass', 'prefixEvent'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'autoclose', 'useNative', 'roundDisplay'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\n            options[key] = false;\n          }\n        });\n\n\n        // Initialize timepicker\n        if (isNative && (options.useNative || defaults.useNative)) options.timeFormat = 'HH:mm';\n        var timepicker = $timepicker(element, controller, options);\n        options = timepicker.$options;\n\n        var lang = options.lang;\n        var formatDate = function (date, format, timezone) {\n          return $dateFormatter.formatDate(date, format, lang, timezone);\n        };\n\n        // Visibility binding support\n        if (attr.bsShow) {\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\n            if (!timepicker || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(timepicker),?/i);\n            if (newValue === true) {\n              timepicker.show();\n            } else {\n              timepicker.hide();\n            }\n          });\n        }\n\n        // Initialize parser\n        var dateParser = $dateParser({\n          format: options.timeFormat,\n          lang: lang\n        });\n\n        // Observe attributes for changes\n        angular.forEach(['minTime', 'maxTime'], function (key) {\n          // console.warn('attr.$observe(%s)', key, attr[key]);\n          if (angular.isDefined(attr[key])) {\n            attr.$observe(key, function (newValue) {\n              timepicker.$options[key] = dateParser.getTimeForAttribute(key, newValue);\n              if (!isNaN(timepicker.$options[key])) timepicker.$build();\n              validateAgainstMinMaxTime(controller.$dateValue);\n            });\n          }\n        });\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', attr.ngModel, newValue, oldValue, controller.$dateValue);\n          timepicker.update(controller.$dateValue);\n        }, true);\n\n        function validateAgainstMinMaxTime(parsedTime) {\n          if (!angular.isDate(parsedTime)) return;\n          var isMinValid = isNaN(options.minTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) >= options.minTime;\n          var isMaxValid = isNaN(options.maxTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) <= options.maxTime;\n          var isValid = isMinValid && isMaxValid;\n          controller.$setValidity('date', isValid);\n          controller.$setValidity('min', isMinValid);\n          controller.$setValidity('max', isMaxValid);\n          // Only update the model when we have a valid date\n          if (!isValid) {\n            return;\n          }\n          controller.$dateValue = parsedTime;\n        }\n\n        // viewValue -> $parsers -> modelValue\n        controller.$parsers.unshift(function (viewValue) {\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\n          var date;\n          // Null values should correctly reset the model value & validity\n          if (!viewValue) {\n            // BREAKING CHANGE:\n            // return null (not undefined) when input value is empty, so angularjs 1.3\n            // ngModelController can go ahead and run validators, like ngRequired\n            controller.$setValidity('date', true);\n            return null;\n          }\n          var parsedTime = angular.isDate(viewValue) ? viewValue : dateParser.parse(viewValue, controller.$dateValue);\n          if (!parsedTime || isNaN(parsedTime.getTime())) {\n            controller.$setValidity('date', false);\n            // Return undefined, causes ngModelController to\n            // invalidate model value\n            return undefined;\n          }\n          validateAgainstMinMaxTime(parsedTime);\n\n          if (options.timeType === 'string') {\n            date = dateParser.timezoneOffsetAdjust(parsedTime, options.timezone, true);\n            return formatDate(date, options.modelTimeFormat || options.timeFormat);\n          }\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\n          if (options.timeType === 'number') {\n            return date.getTime();\n          } else if (options.timeType === 'unix') {\n            return date.getTime() / 1000;\n          } else if (options.timeType === 'iso') {\n            return date.toISOString();\n          }\n          return new Date(date);\n        });\n\n        // modelValue -> $formatters -> viewValue\n        controller.$formatters.push(function (modelValue) {\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n          var date;\n          if (angular.isUndefined(modelValue) || modelValue === null) {\n            date = NaN;\n          } else if (angular.isDate(modelValue)) {\n            date = modelValue;\n          } else if (options.timeType === 'string') {\n            date = dateParser.parse(modelValue, null, options.modelTimeFormat);\n          } else if (options.timeType === 'unix') {\n            date = new Date(modelValue * 1000);\n          } else {\n            date = new Date(modelValue);\n          }\n          // Setup default value?\n          // if(isNaN(date.getTime())) date = new Date(new Date().setMinutes(0) + 36e5);\n          controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\n          return getTimeFormattedString();\n        });\n\n        // viewValue -> element\n        controller.$render = function () {\n          // console.warn('$render(\"%s\"): viewValue=%o', element.attr('ng-model'), controller.$viewValue);\n          element.val(getTimeFormattedString());\n        };\n\n        function getTimeFormattedString() {\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.timeFormat);\n        }\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (timepicker) timepicker.destroy();\n          options = null;\n          timepicker = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: popover/popover.js\nangular.module('mgcrea.ngStrap.popover', ['mgcrea.ngStrap.tooltip'])\n\n  .provider('$popover', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      customClass: '',\n      // uncommenting the next two lines will break backwards compatability\n      // prefixClass: 'popover',\n      // prefixEvent: 'popover',\n      container: false,\n      target: false,\n      placement: 'right',\n      templateUrl: 'popover/popover.tpl.html',\n      contentTemplate: false,\n      trigger: 'click',\n      keyboard: true,\n      html: false,\n      title: '',\n      content: '',\n      delay: 0,\n      autoClose: false\n    };\n\n    this.$get = function ($tooltip) {\n\n      function PopoverFactory(element, config) {\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        var $popover = $tooltip(element, options);\n\n        // Support scope as string options [/*title, */content]\n        if (options.content) {\n          $popover.$scope.content = options.content;\n        }\n\n        return $popover;\n\n      }\n\n      return PopoverFactory;\n\n    };\n\n  })\n\n  .directive('bsPopover', function ($window, $sce, $popover) {\n\n    var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr) {\n\n        var popover;\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'customClass', 'autoClose', 'id', 'prefixClass', 'prefixEvent'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'autoClose'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\n        });\n\n        // should not parse target attribute (anchor tag), only data-target #1454\n        var dataTarget = element.attr('data-target');\n        if (angular.isDefined(dataTarget)) {\n          if (falseValueRegExp.test(dataTarget)) {\n            options.target = false;\n          } else {\n            options.target = dataTarget;\n          }\n        }\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content'], function (key) {\n          if (attr[key]) {\n            attr.$observe(key, function (newValue, oldValue) {\n              scope[key] = $sce.trustAsHtml(newValue);\n              if (angular.isDefined(oldValue)) {\n                requestAnimationFrame(function () {\n                  if (popover) popover.$applyPlacement();\n                });\n              }\n            });\n          }\n        });\n\n        // Support scope as an object\n        if (attr.bsPopover) {\n          scope.$watch(attr.bsPopover, function (newValue, oldValue) {\n            if (angular.isObject(newValue)) {\n              angular.extend(scope, newValue);\n            } else {\n              scope.content = newValue;\n            }\n            if (angular.isDefined(oldValue)) {\n              requestAnimationFrame(function () {\n                if (popover) popover.$applyPlacement();\n              });\n            }\n          }, true);\n        }\n\n        // Visibility binding support\n        if (attr.bsShow) {\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\n            if (!popover || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(popover),?/i);\n            if (newValue === true) {\n              popover.show();\n            } else {\n              popover.hide();\n            }\n          });\n        }\n\n        // Viewport support\n        if (attr.viewport) {\n          scope.$watch(attr.viewport, function (newValue) {\n            if (!popover || !angular.isDefined(newValue)) return;\n            popover.setViewport(newValue);\n          });\n        }\n\n        // Initialize popover\n        popover = $popover(element, options);\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (popover) popover.destroy();\n          options = null;\n          popover = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: tab/tab.js\nangular.module('mgcrea.ngStrap.tab', [])\n\n  .provider('$tab', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      template: 'tab/tab.tpl.html',\n      navClass: 'nav-tabs',\n      activeClass: 'active'\n    };\n\n    var controller = this.controller = function ($scope, $element, $attrs) {\n      var self = this;\n\n      // Attributes options\n      self.$options = angular.copy(defaults);\n      angular.forEach(['animation', 'navClass', 'activeClass'], function (key) {\n        if (angular.isDefined($attrs[key])) self.$options[key] = $attrs[key];\n      });\n\n      // Publish options on scope\n      $scope.$navClass = self.$options.navClass;\n      $scope.$activeClass = self.$options.activeClass;\n\n      self.$panes = $scope.$panes = [];\n\n      // Please use $activePaneChangeListeners if you use `bsActivePane`\n      // Because we removed `ngModel` as default, we rename viewChangeListeners to\n      // activePaneChangeListeners to make more sense.\n      self.$activePaneChangeListeners = self.$viewChangeListeners = [];\n\n      self.$push = function (pane) {\n        if (angular.isUndefined(self.$panes.$active)) {\n          $scope.$setActive(pane.name || 0);\n        }\n        self.$panes.push(pane);\n      };\n\n      self.$remove = function (pane) {\n        var index = self.$panes.indexOf(pane);\n        var active = self.$panes.$active;\n        var activeIndex;\n        if (angular.isString(active)) {\n          activeIndex = self.$panes.map(function (pane) {\n            return pane.name;\n          }).indexOf(active);\n        } else {\n          activeIndex = self.$panes.$active;\n        }\n\n        // remove pane from $panes array\n        self.$panes.splice(index, 1);\n\n        if (index < activeIndex) {\n          // we removed a pane before the active pane, so we need to\n          // decrement the active pane index\n          activeIndex--;\n        } else if (index === activeIndex && activeIndex === self.$panes.length) {\n          // we remove the active pane and it was the one at the end,\n          // so select the previous one\n          activeIndex--;\n        }\n        if (activeIndex >= 0 && activeIndex < self.$panes.length) {\n          self.$setActive(self.$panes[activeIndex].name || activeIndex);\n        } else {\n          self.$setActive();\n        }\n      };\n\n      self.$setActive = $scope.$setActive = function (value) {\n        self.$panes.$active = value;\n        self.$activePaneChangeListeners.forEach(function (fn) {\n          fn();\n        });\n      };\n\n      self.$isActive = $scope.$isActive = function ($pane, $index) {\n        return self.$panes.$active === $pane.name || self.$panes.$active === $index;\n      };\n\n    };\n\n    this.$get = function () {\n      var $tab = {};\n      $tab.defaults = defaults;\n      $tab.controller = controller;\n      return $tab;\n    };\n\n  })\n\n  .directive('bsTabs', function ($window, $animate, $tab, $parse) {\n\n    var defaults = $tab.defaults;\n\n    return {\n      require: ['?ngModel', 'bsTabs'],\n      transclude: true,\n      scope: true,\n      controller: ['$scope', '$element', '$attrs', $tab.controller],\n      templateUrl: function (element, attr) {\n        return attr.template || defaults.template;\n      },\n      link: function postLink(scope, element, attrs, controllers) {\n\n        var ngModelCtrl = controllers[0];\n        var bsTabsCtrl = controllers[1];\n\n        // 'ngModel' does interfere with form validation\n        // and status, use `bsActivePane` instead to avoid it\n        if (ngModelCtrl) {\n\n          // Update the modelValue following\n          bsTabsCtrl.$activePaneChangeListeners.push(function () {\n            ngModelCtrl.$setViewValue(bsTabsCtrl.$panes.$active);\n          });\n\n          // modelValue -> $formatters -> viewValue\n          ngModelCtrl.$formatters.push(function (modelValue) {\n            // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n            bsTabsCtrl.$setActive(modelValue);\n            return modelValue;\n          });\n\n        }\n\n        if (attrs.bsActivePane) {\n          // adapted from angularjs ngModelController bindings\n          // https://github.com/angular/angular.js/blob/v1.3.1/src%2Fng%2Fdirective%2Finput.js#L1730\n          var parsedBsActivePane = $parse(attrs.bsActivePane);\n\n          // Update bsActivePane value with change\n          bsTabsCtrl.$activePaneChangeListeners.push(function () {\n            parsedBsActivePane.assign(scope, bsTabsCtrl.$panes.$active);\n          });\n\n          // watch bsActivePane for value changes\n          scope.$watch(attrs.bsActivePane, function (newValue, oldValue) {\n            bsTabsCtrl.$setActive(newValue);\n          }, true);\n        }\n      }\n    };\n\n  })\n\n  .directive('bsPane', function ($window, $animate, $sce) {\n\n    return {\n      require: ['^?ngModel', '^bsTabs'],\n      scope: true,\n      link: function postLink(scope, element, attrs, controllers) {\n\n        // var ngModelCtrl = controllers[0];\n        var bsTabsCtrl = controllers[1];\n\n        // Add base class\n        element.addClass('tab-pane');\n\n        // Observe title attribute for change\n        attrs.$observe('title', function (newValue, oldValue) {\n          scope.title = $sce.trustAsHtml(newValue);\n        });\n\n        // Save tab name into scope\n        scope.name = attrs.name;\n\n        // Add animation class\n        if (bsTabsCtrl.$options.animation) {\n          element.addClass(bsTabsCtrl.$options.animation);\n        }\n\n        attrs.$observe('disabled', function (newValue, oldValue) {\n          scope.disabled = scope.$eval(newValue);\n        });\n\n        // Push pane to parent bsTabs controller\n        bsTabsCtrl.$push(scope);\n\n        // remove pane from tab controller when pane is destroyed\n        scope.$on('$destroy', function () {\n          bsTabsCtrl.$remove(scope);\n        });\n\n        function render() {\n          var index = bsTabsCtrl.$panes.indexOf(scope);\n          $animate[bsTabsCtrl.$isActive(scope, index) ? 'addClass' : 'removeClass'](element, bsTabsCtrl.$options.activeClass);\n        }\n\n        bsTabsCtrl.$activePaneChangeListeners.push(function () {\n          render();\n        });\n        render();\n\n      }\n    };\n\n  });\n\n// Source: scrollspy/scrollspy.js\nangular.module('mgcrea.ngStrap.scrollspy', ['mgcrea.ngStrap.helpers.debounce', 'mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$scrollspy', function () {\n\n    // Pool of registered spies\n    var spies = this.$$spies = {};\n\n    var defaults = this.defaults = {\n      debounce: 150,\n      throttle: 100,\n      offset: 100\n    };\n\n    this.$get = function ($window, $document, $rootScope, dimensions, debounce, throttle) {\n\n      var windowEl = angular.element($window);\n      var docEl = angular.element($document.prop('documentElement'));\n      var bodyEl = angular.element($window.document.body);\n\n      // Helper functions\n\n      function nodeName(element, name) {\n        return element[0].nodeName && element[0].nodeName.toLowerCase() === name.toLowerCase();\n      }\n\n      function ScrollSpyFactory(config) {\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        if (!options.element) options.element = bodyEl;\n        var isWindowSpy = nodeName(options.element, 'body');\n        var scrollEl = isWindowSpy ? windowEl : options.element;\n        var scrollId = isWindowSpy ? 'window' : options.id;\n\n        // Use existing spy\n        if (spies[scrollId]) {\n          spies[scrollId].$$count++;\n          return spies[scrollId];\n        }\n\n        var $scrollspy = {};\n\n        // Private vars\n        var unbindViewContentLoaded;\n        var unbindIncludeContentLoaded;\n        var trackedElements = $scrollspy.$trackedElements = [];\n        var sortedElements = [];\n        var activeTarget;\n        var debouncedCheckPosition;\n        var throttledCheckPosition;\n        var debouncedCheckOffsets;\n        /* eslint-disable no-unused-vars */\n        var viewportHeight;\n        /* eslint-enable no-unused-vars */\n        var scrollTop;\n\n        $scrollspy.init = function () {\n\n          // Setup internal ref counter\n          this.$$count = 1;\n\n          // Bind events\n          debouncedCheckPosition = debounce(this.checkPosition, options.debounce);\n          throttledCheckPosition = throttle(this.checkPosition, options.throttle);\n          scrollEl.on('click', this.checkPositionWithEventLoop);\n          windowEl.on('resize', debouncedCheckPosition);\n          scrollEl.on('scroll', throttledCheckPosition);\n\n          debouncedCheckOffsets = debounce(this.checkOffsets, options.debounce);\n          unbindViewContentLoaded = $rootScope.$on('$viewContentLoaded', debouncedCheckOffsets);\n          unbindIncludeContentLoaded = $rootScope.$on('$includeContentLoaded', debouncedCheckOffsets);\n          debouncedCheckOffsets();\n\n          // Register spy for reuse\n          if (scrollId) {\n            spies[scrollId] = $scrollspy;\n          }\n\n        };\n\n        $scrollspy.destroy = function () {\n\n          // Check internal ref counter\n          this.$$count--;\n          if (this.$$count > 0) {\n            return;\n          }\n\n          // Unbind events\n          scrollEl.off('click', this.checkPositionWithEventLoop);\n          windowEl.off('resize', debouncedCheckPosition);\n          scrollEl.off('scroll', throttledCheckPosition);\n          unbindViewContentLoaded();\n          unbindIncludeContentLoaded();\n          if (scrollId) {\n            delete spies[scrollId];\n          }\n        };\n\n        $scrollspy.checkPosition = function () {\n\n          // Not ready yet\n          if (!sortedElements.length) return;\n\n          // Calculate the scroll position\n          scrollTop = (isWindowSpy ? $window.pageYOffset : scrollEl.prop('scrollTop')) || 0;\n\n          // Calculate the viewport height for use by the components\n          viewportHeight = Math.max($window.innerHeight, docEl.prop('clientHeight'));\n\n          // Activate first element if scroll is smaller\n          if (scrollTop < sortedElements[0].offsetTop && activeTarget !== sortedElements[0].target) {\n            return $scrollspy.$activateElement(sortedElements[0]);\n          }\n\n          // Activate proper element\n          for (var i = sortedElements.length; i--;) {\n            if (angular.isUndefined(sortedElements[i].offsetTop) || sortedElements[i].offsetTop === null) continue;\n            if (activeTarget === sortedElements[i].target) continue;\n            if (scrollTop < sortedElements[i].offsetTop) continue;\n            if (sortedElements[i + 1] && scrollTop > sortedElements[i + 1].offsetTop) continue;\n            return $scrollspy.$activateElement(sortedElements[i]);\n          }\n\n        };\n\n        $scrollspy.checkPositionWithEventLoop = function () {\n          // IE 9 throws an error if we use 'this' instead of '$scrollspy'\n          // in this setTimeout call\n          setTimeout($scrollspy.checkPosition, 1);\n        };\n\n        // Protected methods\n\n        $scrollspy.$activateElement = function (element) {\n          if (activeTarget) {\n            var activeElement = $scrollspy.$getTrackedElement(activeTarget);\n            if (activeElement) {\n              activeElement.source.removeClass('active');\n              if (nodeName(activeElement.source, 'li') && nodeName(activeElement.source.parent().parent(), 'li')) {\n                activeElement.source.parent().parent().removeClass('active');\n              }\n            }\n          }\n          activeTarget = element.target;\n          element.source.addClass('active');\n          if (nodeName(element.source, 'li') && nodeName(element.source.parent().parent(), 'li')) {\n            element.source.parent().parent().addClass('active');\n          }\n        };\n\n        $scrollspy.$getTrackedElement = function (target) {\n          return trackedElements.filter(function (obj) {\n            return obj.target === target;\n          })[0];\n        };\n\n        // Track offsets behavior\n\n        $scrollspy.checkOffsets = function () {\n\n          angular.forEach(trackedElements, function (trackedElement) {\n            var targetElement = document.querySelector(trackedElement.target);\n            trackedElement.offsetTop = targetElement ? dimensions.offset(targetElement).top : null;\n            if (options.offset && trackedElement.offsetTop !== null) trackedElement.offsetTop -= options.offset * 1;\n          });\n\n          sortedElements = trackedElements\n          .filter(function (el) {\n            return el.offsetTop !== null;\n          })\n          .sort(function (a, b) {\n            return a.offsetTop - b.offsetTop;\n          });\n\n          debouncedCheckPosition();\n\n        };\n\n        $scrollspy.trackElement = function (target, source) {\n          trackedElements.push({target: target, source: source});\n        };\n\n        $scrollspy.untrackElement = function (target, source) {\n          var toDelete;\n          for (var i = trackedElements.length; i--;) {\n            if (trackedElements[i].target === target && trackedElements[i].source === source) {\n              toDelete = i;\n              break;\n            }\n          }\n          trackedElements.splice(toDelete, 1);\n        };\n\n        $scrollspy.activate = function (i) {\n          trackedElements[i].addClass('active');\n        };\n\n        // Initialize plugin\n\n        $scrollspy.init();\n        return $scrollspy;\n\n      }\n\n      return ScrollSpyFactory;\n\n    };\n\n  })\n\n  .directive('bsScrollspy', function ($rootScope, debounce, dimensions, $scrollspy) {\n\n    return {\n      restrict: 'EAC',\n      link: function postLink(scope, element, attr) {\n\n        var options = {scope: scope};\n        angular.forEach(['offset', 'target'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        var scrollspy = $scrollspy(options);\n        scrollspy.trackElement(options.target, element);\n\n        scope.$on('$destroy', function () {\n          if (scrollspy) {\n            scrollspy.untrackElement(options.target, element);\n            scrollspy.destroy();\n          }\n          options = null;\n          scrollspy = null;\n        });\n\n      }\n    };\n\n  })\n\n\n  .directive('bsScrollspyList', function ($rootScope, debounce, dimensions, $scrollspy) {\n\n    return {\n      restrict: 'A',\n      compile: function postLink(element, attr) {\n        var children = element[0].querySelectorAll('li > a[href]');\n        angular.forEach(children, function (child) {\n          var childEl = angular.element(child);\n          childEl.parent().attr('bs-scrollspy', '').attr('data-target', childEl.attr('href'));\n        });\n      }\n\n    };\n\n  });\n\n// Source: select/select.js\nangular.module('mgcrea.ngStrap.select', ['mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions'])\n\n  .provider('$select', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'select',\n      prefixEvent: '$select',\n      placement: 'bottom-left',\n      templateUrl: 'select/select.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      multiple: false,\n      allNoneButtons: false,\n      sort: true,\n      caretHtml: '&nbsp;<span class=\"caret\"></span>',\n      placeholder: 'Choose among the following...',\n      allText: 'All',\n      noneText: 'None',\n      maxLength: 3,\n      maxLengthHtml: 'selected',\n      iconCheckmark: 'glyphicon glyphicon-ok'\n    };\n\n    this.$get = function ($window, $document, $rootScope, $tooltip, $timeout) {\n\n      // var bodyEl = angular.element($window.document.body);\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n\n      function SelectFactory(element, controller, config) {\n\n        var $select = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $select = $tooltip(element, options);\n        var scope = $select.$scope;\n\n        scope.$matches = [];\n        if (options.multiple) {\n          scope.$activeIndex = [];\n        } else {\n          scope.$activeIndex = -1;\n        }\n        scope.$isMultiple = options.multiple;\n        scope.$showAllNoneButtons = options.allNoneButtons && options.multiple;\n        scope.$iconCheckmark = options.iconCheckmark;\n        scope.$allText = options.allText;\n        scope.$noneText = options.noneText;\n\n        scope.$activate = function (index) {\n          scope.$$postDigest(function () {\n            $select.activate(index);\n          });\n        };\n\n        scope.$select = function (index, evt) {\n          scope.$$postDigest(function () {\n            $select.select(index);\n          });\n        };\n\n        scope.$isVisible = function () {\n          return $select.$isVisible();\n        };\n\n        scope.$isActive = function (index) {\n          return $select.$isActive(index);\n        };\n\n        scope.$selectAll = function () {\n          for (var i = 0; i < scope.$matches.length; i++) {\n            if (!scope.$isActive(i)) {\n              scope.$select(i);\n            }\n          }\n        };\n\n        scope.$selectNone = function () {\n          for (var i = 0; i < scope.$matches.length; i++) {\n            if (scope.$isActive(i)) {\n              scope.$select(i);\n            }\n          }\n        };\n\n        // Public methods\n\n        $select.update = function (matches) {\n          scope.$matches = matches;\n          $select.$updateActiveIndex();\n        };\n\n        $select.activate = function (index) {\n          if (options.multiple) {\n            if ($select.$isActive(index)) {\n              scope.$activeIndex.splice(scope.$activeIndex.indexOf(index), 1);\n            } else {\n              scope.$activeIndex.push(index);\n            }\n            if (options.sort) scope.$activeIndex.sort(function (a, b) { return a - b; }); // use numeric sort instead of default sort\n          } else {\n            scope.$activeIndex = index;\n          }\n          return scope.$activeIndex;\n        };\n\n        $select.select = function (index) {\n          var value = scope.$matches[index].value;\n          scope.$apply(function () {\n            $select.activate(index);\n            if (options.multiple) {\n              controller.$setViewValue(scope.$activeIndex.map(function (index) {\n                if (angular.isUndefined(scope.$matches[index])) {\n                  return null;\n                }\n                return scope.$matches[index].value;\n              }));\n            } else {\n              controller.$setViewValue(value);\n              // Hide if single select\n              $select.hide();\n            }\n          });\n          // Emit event\n          scope.$emit(options.prefixEvent + '.select', value, index, $select);\n        };\n\n        // Protected methods\n\n        $select.$updateActiveIndex = function () {\n          if (options.multiple) {\n            if (angular.isArray(controller.$modelValue)) {\n              scope.$activeIndex = controller.$modelValue.map(function (value) {\n                return $select.$getIndex(value);\n              });\n            } else {\n              scope.$activeIndex = [];\n            }\n          } else {\n            if (angular.isDefined(controller.$modelValue) && scope.$matches.length) {\n              scope.$activeIndex = $select.$getIndex(controller.$modelValue);\n            } else {\n              scope.$activeIndex = -1;\n            }\n          }\n        };\n\n        $select.$isVisible = function () {\n          if (!options.minLength || !controller) {\n            return scope.$matches.length;\n          }\n          // minLength support\n          return scope.$matches.length && controller.$viewValue.length >= options.minLength;\n        };\n\n        $select.$isActive = function (index) {\n          if (options.multiple) {\n            return scope.$activeIndex.indexOf(index) !== -1;\n          }\n          return scope.$activeIndex === index;\n        };\n\n        $select.$getIndex = function (value) {\n          var index;\n          for (index = scope.$matches.length; index--;) {\n            if (angular.equals(scope.$matches[index].value, value)) break;\n          }\n          return index;\n        };\n\n        $select.$onMouseDown = function (evt) {\n          // Prevent blur on mousedown on .dropdown-menu\n          evt.preventDefault();\n          evt.stopPropagation();\n          // Emulate click for mobile devices\n          if (isTouch) {\n            var targetEl = angular.element(evt.target);\n            targetEl.triggerHandler('click');\n          }\n        };\n\n        $select.$onKeyDown = function (evt) {\n          if (!/(9|13|38|40)/.test(evt.keyCode)) return;\n          // Let tab propagate\n          if (evt.keyCode !== 9) {\n            evt.preventDefault();\n            evt.stopPropagation();\n          }\n\n          // release focus on tab\n          if (options.multiple && evt.keyCode === 9) {\n            return $select.hide();\n          }\n\n          // Select with enter\n          if (!options.multiple && (evt.keyCode === 13 || evt.keyCode === 9)) {\n            return $select.select(scope.$activeIndex);\n          }\n\n          if (!options.multiple) {\n            // Navigate with keyboard\n            if (evt.keyCode === 38 && scope.$activeIndex > 0) scope.$activeIndex--;\n            else if (evt.keyCode === 38 && scope.$activeIndex < 0) scope.$activeIndex = scope.$matches.length - 1;\n            else if (evt.keyCode === 40 && scope.$activeIndex < scope.$matches.length - 1) scope.$activeIndex++;\n            else if (angular.isUndefined(scope.$activeIndex)) scope.$activeIndex = 0;\n            scope.$digest();\n          }\n        };\n\n        $select.$isIE = function () {\n          var ua = $window.navigator.userAgent;\n          return ua.indexOf('MSIE ') > 0 || ua.indexOf('Trident/') > 0 || ua.indexOf('Edge/') > 0;\n        };\n\n        $select.$selectScrollFix = function (e) {\n          if ($document[0].activeElement.tagName === 'UL') {\n            e.preventDefault();\n            e.stopImmediatePropagation();\n            e.target.focus();\n          }\n        };\n\n        // Overrides\n\n        var _show = $select.show;\n        $select.show = function () {\n          _show();\n          if (options.multiple) {\n            $select.$element.addClass('select-multiple');\n          }\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function () {\n            $select.$element.on(isTouch ? 'touchstart' : 'mousedown', $select.$onMouseDown);\n            if (options.keyboard) {\n              element.on('keydown', $select.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var _hide = $select.hide;\n        $select.hide = function () {\n          if (!options.multiple && angular.isUndefined(controller.$modelValue)) {\n            scope.$activeIndex = -1;\n          }\n          $select.$element.off(isTouch ? 'touchstart' : 'mousedown', $select.$onMouseDown);\n          if (options.keyboard) {\n            element.off('keydown', $select.$onKeyDown);\n          }\n          _hide(true);\n        };\n\n        return $select;\n\n      }\n\n      SelectFactory.defaults = defaults;\n      return SelectFactory;\n\n    };\n\n  })\n\n  .directive('bsSelect', function ($window, $parse, $q, $select, $parseOptions) {\n\n    var defaults = $select.defaults;\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = {scope: scope, placeholder: defaults.placeholder};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'placeholder', 'allNoneButtons', 'maxLength', 'maxLengthHtml', 'allText', 'noneText', 'iconCheckmark', 'autoClose', 'id', 'sort', 'caretHtml', 'prefixClass', 'prefixEvent'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'allNoneButtons', 'sort'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\n            options[key] = false;\n          }\n        });\n\n        // Only parse data-multiple. Angular sets existence attributes to true (multiple/required/etc), they apply this\n        // to data-multiple as well for some reason, so we'll parse this ourselves and disregard multiple\n        var dataMultiple = element.attr('data-multiple');\n        if (angular.isDefined(dataMultiple)) {\n          if (falseValueRegExp.test(dataMultiple)) {\n            options.multiple = false;\n          } else {\n            options.multiple = dataMultiple;\n          }\n        }\n\n        // Add support for select markup\n        if (element[0].nodeName.toLowerCase() === 'select') {\n          var inputEl = element;\n          inputEl.css('display', 'none');\n          element = angular.element('<button type=\"button\" class=\"btn btn-default\"></button>');\n          inputEl.after(element);\n        }\n\n        // Build proper bsOptions\n        var parsedOptions = $parseOptions(attr.bsOptions);\n\n        // Initialize select\n        var select = $select(element, controller, options);\n\n        if (select.$isIE()) {\n          element[0].addEventListener('blur', select.$selectScrollFix);\n        }\n\n        // Watch bsOptions values before filtering for changes\n        var watchedOptions = parsedOptions.$match[7].replace(/\\|.+/, '').trim();\n        scope.$watch(watchedOptions, function (newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', watchedOptions, newValue, oldValue);\n          parsedOptions.valuesFn(scope, controller)\n          .then(function (values) {\n            select.update(values);\n            controller.$render();\n          });\n        }, true);\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', attr.ngModel, newValue, oldValue);\n          select.$updateActiveIndex();\n          controller.$render();\n        }, true);\n\n        // Model rendering in view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          var selected;\n          var index;\n          if (options.multiple && angular.isArray(controller.$modelValue)) {\n            selected = controller.$modelValue.map(function (value) {\n              index = select.$getIndex(value);\n              return index !== -1 ? select.$scope.$matches[index].label : false;\n            }).filter(angular.isDefined);\n            if (selected.length > (options.maxLength || defaults.maxLength)) {\n              selected = selected.length + ' ' + (options.maxLengthHtml || defaults.maxLengthHtml);\n            } else {\n              selected = selected.join(', ');\n            }\n          } else {\n            index = select.$getIndex(controller.$modelValue);\n            selected = index !== -1 ? select.$scope.$matches[index].label : false;\n          }\n          element.html((selected ? selected : options.placeholder) + (options.caretHtml ? options.caretHtml : defaults.caretHtml));\n        };\n\n        if (options.multiple) {\n          controller.$isEmpty = function (value) {\n            return !value || value.length === 0;\n          };\n        }\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (select) select.destroy();\n          options = null;\n          select = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: datepicker/datepicker.js\nangular.module('mgcrea.ngStrap.datepicker', [\n  'mgcrea.ngStrap.helpers.dateParser',\n  'mgcrea.ngStrap.helpers.dateFormatter',\n  'mgcrea.ngStrap.tooltip'])\n\n  .provider('$datepicker', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      // Uncommenting the following line will break backwards compatability\n      // prefixEvent: 'datepicker',\n      prefixClass: 'datepicker',\n      placement: 'bottom-left',\n      templateUrl: 'datepicker/datepicker.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      // lang: $locale.id,\n      useNative: false,\n      dateType: 'date',\n      dateFormat: 'shortDate',\n      timezone: null,\n      modelDateFormat: null,\n      dayFormat: 'dd',\n      monthFormat: 'MMM',\n      yearFormat: 'yyyy',\n      monthTitleFormat: 'MMMM yyyy',\n      yearTitleFormat: 'yyyy',\n      strictFormat: false,\n      autoclose: false,\n      minDate: -Infinity,\n      maxDate: +Infinity,\n      startView: 0,\n      minView: 0,\n      startWeek: 0,\n      daysOfWeekDisabled: '',\n      iconLeft: 'glyphicon glyphicon-chevron-left',\n      iconRight: 'glyphicon glyphicon-chevron-right'\n    };\n\n    this.$get = function ($window, $document, $rootScope, $sce, $dateFormatter, datepickerViews, $tooltip, $timeout) {\n\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n      if (!defaults.lang) defaults.lang = $dateFormatter.getDefaultLocale();\n\n      function DatepickerFactory(element, controller, config) {\n\n        var $datepicker = $tooltip(element, angular.extend({}, defaults, config));\n        var parentScope = config.scope;\n        var options = $datepicker.$options;\n        var scope = $datepicker.$scope;\n        if (options.startView) options.startView -= options.minView;\n\n        // View vars\n\n        var pickerViews = datepickerViews($datepicker);\n        $datepicker.$views = pickerViews.views;\n        var viewDate = pickerViews.viewDate;\n        scope.$mode = options.startView;\n        scope.$iconLeft = options.iconLeft;\n        scope.$iconRight = options.iconRight;\n        var $picker = $datepicker.$views[scope.$mode];\n\n        // Scope methods\n\n        scope.$select = function (date) {\n          $datepicker.select(date);\n        };\n        scope.$selectPane = function (value) {\n          $datepicker.$selectPane(value);\n        };\n        scope.$toggleMode = function () {\n          $datepicker.setMode((scope.$mode + 1) % $datepicker.$views.length);\n        };\n\n        // Public methods\n\n        $datepicker.update = function (date) {\n          // console.warn('$datepicker.update() newValue=%o', date);\n          if (angular.isDate(date) && !isNaN(date.getTime())) {\n            $datepicker.$date = date;\n            $picker.update.call($picker, date);\n          }\n          // Build only if pristine\n          $datepicker.$build(true);\n        };\n\n        $datepicker.updateDisabledDates = function (dateRanges) {\n          options.disabledDateRanges = dateRanges;\n          for (var i = 0, l = scope.rows.length; i < l; i++) {\n            angular.forEach(scope.rows[i], $datepicker.$setDisabledEl);\n          }\n        };\n\n        $datepicker.select = function (date, keep) {\n          // console.warn('$datepicker.select', date, scope.$mode);\n          if (!angular.isDate(controller.$dateValue)) controller.$dateValue = new Date(date);\n          if (!scope.$mode || keep) {\n            controller.$setViewValue(angular.copy(date));\n            controller.$render();\n            if (options.autoclose && !keep) {\n              $timeout(function () { $datepicker.hide(true); });\n            }\n          } else {\n            angular.extend(viewDate, {year: date.getFullYear(), month: date.getMonth(), date: date.getDate()});\n            $datepicker.setMode(scope.$mode - 1);\n            $datepicker.$build();\n          }\n        };\n\n        $datepicker.setMode = function (mode) {\n          // console.warn('$datepicker.setMode', mode);\n          scope.$mode = mode;\n          $picker = $datepicker.$views[scope.$mode];\n          $datepicker.$build();\n        };\n\n        // Protected methods\n\n        $datepicker.$build = function (pristine) {\n          // console.warn('$datepicker.$build() viewDate=%o', viewDate);\n          if (pristine === true && $picker.built) return;\n          if (pristine === false && !$picker.built) return;\n          $picker.build.call($picker);\n        };\n\n        $datepicker.$updateSelected = function () {\n          for (var i = 0, l = scope.rows.length; i < l; i++) {\n            angular.forEach(scope.rows[i], updateSelected);\n          }\n        };\n\n        $datepicker.$isSelected = function (date) {\n          return $picker.isSelected(date);\n        };\n\n        $datepicker.$setDisabledEl = function (el) {\n          el.disabled = $picker.isDisabled(el.date);\n        };\n\n        $datepicker.$selectPane = function (value) {\n          var steps = $picker.steps;\n          // set targetDate to first day of month to avoid problems with\n          // date values rollover. This assumes the viewDate does not\n          // depend on the day of the month\n          var targetDate = new Date(Date.UTC(viewDate.year + ((steps.year || 0) * value), viewDate.month + ((steps.month || 0) * value), 1));\n          angular.extend(viewDate, {year: targetDate.getUTCFullYear(), month: targetDate.getUTCMonth(), date: targetDate.getUTCDate()});\n          $datepicker.$build();\n        };\n\n        $datepicker.$onMouseDown = function (evt) {\n          // Prevent blur on mousedown on .dropdown-menu\n          evt.preventDefault();\n          evt.stopPropagation();\n          // Emulate click for mobile devices\n          if (isTouch) {\n            var targetEl = angular.element(evt.target);\n            if (targetEl[0].nodeName.toLowerCase() !== 'button') {\n              targetEl = targetEl.parent();\n            }\n            targetEl.triggerHandler('click');\n          }\n        };\n\n        $datepicker.$onKeyDown = function (evt) {\n          if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          if (evt.keyCode === 13) {\n            if (!scope.$mode) {\n              $datepicker.hide(true);\n            } else {\n              scope.$apply(function () { $datepicker.setMode(scope.$mode - 1); });\n            }\n            return;\n          }\n\n          // Navigate with keyboard\n          $picker.onKeyDown(evt);\n          parentScope.$digest();\n        };\n\n        // Private\n\n        function updateSelected(el) {\n          el.selected = $datepicker.$isSelected(el.date);\n        }\n\n        function focusElement() {\n          element[0].focus();\n        }\n\n        // Overrides\n\n        var _init = $datepicker.init;\n        $datepicker.init = function () {\n          if (isNative && options.useNative) {\n            element.prop('type', 'date');\n            element.css('-webkit-appearance', 'textfield');\n            return;\n          } else if (isTouch) {\n            element.prop('type', 'text');\n            element.attr('readonly', 'true');\n            element.on('click', focusElement);\n          }\n          _init();\n        };\n\n        var _destroy = $datepicker.destroy;\n        $datepicker.destroy = function () {\n          if (isNative && options.useNative) {\n            element.off('click', focusElement);\n          }\n          _destroy();\n        };\n\n        var _show = $datepicker.show;\n        $datepicker.show = function () {\n          if ((!isTouch && element.attr('readonly')) || element.attr('disabled')) return;\n          _show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function () {\n            // if $datepicker is no longer showing, don't setup events\n            if (!$datepicker.$isShown) return;\n            $datepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);\n            if (options.keyboard) {\n              element.on('keydown', $datepicker.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var _hide = $datepicker.hide;\n        $datepicker.hide = function (blur) {\n          if (!$datepicker.$isShown) return;\n          $datepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);\n          if (options.keyboard) {\n            element.off('keydown', $datepicker.$onKeyDown);\n          }\n          _hide(blur);\n        };\n\n        return $datepicker;\n\n      }\n\n      DatepickerFactory.defaults = defaults;\n      return DatepickerFactory;\n\n    };\n\n  })\n\n  .directive('bsDatepicker', function ($window, $parse, $q, $dateFormatter, $dateParser, $datepicker) {\n\n    // var defaults = $datepicker.defaults;\n    var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'autoclose', 'dateType', 'dateFormat', 'timezone', 'modelDateFormat', 'dayFormat', 'strictFormat', 'startWeek', 'startDate', 'useNative', 'lang', 'startView', 'minView', 'iconLeft', 'iconRight', 'daysOfWeekDisabled', 'id', 'prefixClass', 'prefixEvent'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'autoclose', 'useNative'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\n            options[key] = false;\n          }\n        });\n\n        // Initialize datepicker\n        var datepicker = $datepicker(element, controller, options);\n        options = datepicker.$options;\n        // Set expected iOS format\n        if (isNative && options.useNative) options.dateFormat = 'yyyy-MM-dd';\n\n        var lang = options.lang;\n\n        var formatDate = function (date, format) {\n          return $dateFormatter.formatDate(date, format, lang);\n        };\n\n        var dateParser = $dateParser({format: options.dateFormat, lang: lang, strict: options.strictFormat});\n\n        // Visibility binding support\n        if (attr.bsShow) {\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\n            if (!datepicker || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(datepicker),?/i);\n            if (newValue === true) {\n              datepicker.show();\n            } else {\n              datepicker.hide();\n            }\n          });\n        }\n\n        // Observe attributes for changes\n        angular.forEach(['minDate', 'maxDate'], function (key) {\n          // console.warn('attr.$observe(%s)', key, attr[key]);\n          if (angular.isDefined(attr[key])) {\n            attr.$observe(key, function (newValue) {\n              // console.warn('attr.$observe(%s)=%o', key, newValue);\n              datepicker.$options[key] = dateParser.getDateForAttribute(key, newValue);\n              // Build only if dirty\n              if (!isNaN(datepicker.$options[key])) datepicker.$build(false);\n              validateAgainstMinMaxDate(controller.$dateValue);\n            });\n          }\n        });\n\n        // Observe date format\n        if (angular.isDefined(attr.dateFormat)) {\n          attr.$observe('dateFormat', function (newValue) {\n            datepicker.$options.dateFormat = newValue;\n          });\n        }\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\n          datepicker.update(controller.$dateValue);\n        }, true);\n\n        // Normalize undefined/null/empty array,\n        // so that we don't treat changing from undefined->null as a change.\n        function normalizeDateRanges(ranges) {\n          if (!ranges || !ranges.length) return null;\n          return ranges;\n        }\n\n        if (angular.isDefined(attr.disabledDates)) {\n          scope.$watch(attr.disabledDates, function (disabledRanges, previousValue) {\n            disabledRanges = normalizeDateRanges(disabledRanges);\n            previousValue = normalizeDateRanges(previousValue);\n\n            if (disabledRanges) {\n              datepicker.updateDisabledDates(disabledRanges);\n            }\n          });\n        }\n\n        function validateAgainstMinMaxDate(parsedDate) {\n          if (!angular.isDate(parsedDate)) return;\n          var isMinValid = isNaN(datepicker.$options.minDate) || parsedDate.getTime() >= datepicker.$options.minDate;\n          var isMaxValid = isNaN(datepicker.$options.maxDate) || parsedDate.getTime() <= datepicker.$options.maxDate;\n          var isValid = isMinValid && isMaxValid;\n          controller.$setValidity('date', isValid);\n          controller.$setValidity('min', isMinValid);\n          controller.$setValidity('max', isMaxValid);\n          // Only update the model when we have a valid date\n          if (isValid) controller.$dateValue = parsedDate;\n        }\n\n        // viewValue -> $parsers -> modelValue\n        controller.$parsers.unshift(function (viewValue) {\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\n          var date;\n          // Null values should correctly reset the model value & validity\n          if (!viewValue) {\n            controller.$setValidity('date', true);\n            // BREAKING CHANGE:\n            // return null (not undefined) when input value is empty, so angularjs 1.3\n            // ngModelController can go ahead and run validators, like ngRequired\n            return null;\n          }\n          var parsedDate = dateParser.parse(viewValue, controller.$dateValue);\n          if (!parsedDate || isNaN(parsedDate.getTime())) {\n            controller.$setValidity('date', false);\n            // return undefined, causes ngModelController to\n            // invalidate model value\n            return;\n          }\n          validateAgainstMinMaxDate(parsedDate);\n\n          if (options.dateType === 'string') {\n            date = dateParser.timezoneOffsetAdjust(parsedDate, options.timezone, true);\n            return formatDate(date, options.modelDateFormat || options.dateFormat);\n          }\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\n          if (options.dateType === 'number') {\n            return date.getTime();\n          } else if (options.dateType === 'unix') {\n            return date.getTime() / 1000;\n          } else if (options.dateType === 'iso') {\n            return date.toISOString();\n          }\n          return new Date(date);\n        });\n\n        // modelValue -> $formatters -> viewValue\n        controller.$formatters.push(function (modelValue) {\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n          var date;\n          if (angular.isUndefined(modelValue) || modelValue === null) {\n            date = NaN;\n          } else if (angular.isDate(modelValue)) {\n            date = modelValue;\n          } else if (options.dateType === 'string') {\n            date = dateParser.parse(modelValue, null, options.modelDateFormat);\n          } else if (options.dateType === 'unix') {\n            date = new Date(modelValue * 1000);\n          } else {\n            date = new Date(modelValue);\n          }\n          // Setup default value?\n          // if (isNaN(date.getTime())) {\n          //   var today = new Date();\n          //   date = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0, 0);\n          // }\n          controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\n          return getDateFormattedString();\n        });\n\n        // viewValue -> element\n        controller.$render = function () {\n          // console.warn('$render(\"%s\"): viewValue=%o', element.attr('ng-model'), controller.$viewValue);\n          element.val(getDateFormattedString());\n        };\n\n        function getDateFormattedString() {\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.dateFormat);\n        }\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (datepicker) datepicker.destroy();\n          options = null;\n          datepicker = null;\n        });\n\n      }\n    };\n\n  })\n\n  .provider('datepickerViews', function () {\n\n    // var defaults = this.defaults = {\n    //   dayFormat: 'dd',\n    //   daySplit: 7\n    // };\n\n    // Split array into smaller arrays\n    function split(arr, size) {\n      var arrays = [];\n      while (arr.length > 0) {\n        arrays.push(arr.splice(0, size));\n      }\n      return arrays;\n    }\n\n    // Modulus operator\n    function mod(n, m) {\n      return ((n % m) + m) % m;\n    }\n\n    this.$get = function ($dateFormatter, $dateParser, $sce) {\n\n      return function (picker) {\n\n        var scope = picker.$scope;\n        var options = picker.$options;\n\n        var lang = options.lang;\n        var formatDate = function (date, format) {\n          return $dateFormatter.formatDate(date, format, lang);\n        };\n        var dateParser = $dateParser({format: options.dateFormat, lang: lang, strict: options.strictFormat});\n\n        var weekDaysMin = $dateFormatter.weekdaysShort(lang);\n        var weekDaysLabels = weekDaysMin.slice(options.startWeek).concat(weekDaysMin.slice(0, options.startWeek));\n        var weekDaysLabelsHtml = $sce.trustAsHtml('<th class=\"dow text-center\">' + weekDaysLabels.join('</th><th class=\"dow text-center\">') + '</th>');\n\n        var startDate = picker.$date || (options.startDate ? dateParser.getDateForAttribute('startDate', options.startDate) : new Date());\n        var viewDate = {year: startDate.getFullYear(), month: startDate.getMonth(), date: startDate.getDate()};\n\n        var views = [{\n          format: options.dayFormat,\n          split: 7,\n          steps: {month: 1},\n          update: function (date, force) {\n            if (!this.built || force || date.getFullYear() !== viewDate.year || date.getMonth() !== viewDate.month) {\n              angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n              picker.$build();\n            } else if (date.getDate() !== viewDate.date || date.getDate() === 1) {\n                // chaging picker current month will cause viewDate.date to be set to first day of the month,\n                // in $datepicker.$selectPane, so picker would not update selected day display if\n                // user picks first day of the new month.\n                // As a workaround, we are always forcing update when picked date is first day of month.\n              viewDate.date = picker.$date.getDate();\n              picker.$updateSelected();\n            }\n          },\n          build: function () {\n            var firstDayOfMonth = new Date(viewDate.year, viewDate.month, 1);\n            var firstDayOfMonthOffset = firstDayOfMonth.getTimezoneOffset();\n            var firstDate = new Date(+firstDayOfMonth - mod(firstDayOfMonth.getDay() - options.startWeek, 7) * 864e5);\n            var firstDateOffset = firstDate.getTimezoneOffset();\n            var today = dateParser.timezoneOffsetAdjust(new Date(), options.timezone).toDateString();\n              // Handle daylight time switch\n            if (firstDateOffset !== firstDayOfMonthOffset) firstDate = new Date(+firstDate + (firstDateOffset - firstDayOfMonthOffset) * 60e3);\n            var days = [];\n            var day;\n            for (var i = 0; i < 42; i++) { // < 7 * 6\n              day = dateParser.daylightSavingAdjust(new Date(firstDate.getFullYear(), firstDate.getMonth(), firstDate.getDate() + i));\n              days.push({date: day, isToday: day.toDateString() === today, label: formatDate(day, this.format), selected: picker.$date && this.isSelected(day), muted: day.getMonth() !== viewDate.month, disabled: this.isDisabled(day)});\n            }\n            scope.title = formatDate(firstDayOfMonth, options.monthTitleFormat);\n            scope.showLabels = true;\n            scope.labels = weekDaysLabelsHtml;\n            scope.rows = split(days, this.split);\n            this.built = true;\n          },\n          isSelected: function (date) {\n            return picker.$date && date.getFullYear() === picker.$date.getFullYear() && date.getMonth() === picker.$date.getMonth() && date.getDate() === picker.$date.getDate();\n          },\n          isDisabled: function (date) {\n            var time = date.getTime();\n\n              // Disabled because of min/max date.\n            if (time < options.minDate || time > options.maxDate) return true;\n\n              // Disabled due to being a disabled day of the week\n            if (options.daysOfWeekDisabled.indexOf(date.getDay()) !== -1) return true;\n\n              // Disabled because of disabled date range.\n            if (options.disabledDateRanges) {\n              for (var i = 0; i < options.disabledDateRanges.length; i++) {\n                if (time >= options.disabledDateRanges[i].start && time <= options.disabledDateRanges[i].end) {\n                  return true;\n                }\n              }\n            }\n\n            return false;\n          },\n          onKeyDown: function (evt) {\n            if (!picker.$date) {\n              return;\n            }\n            var actualTime = picker.$date.getTime();\n            var newDate;\n\n            if (evt.keyCode === 37) newDate = new Date(actualTime - 1 * 864e5);\n              else if (evt.keyCode === 38) newDate = new Date(actualTime - 7 * 864e5);\n              else if (evt.keyCode === 39) newDate = new Date(actualTime + 1 * 864e5);\n              else if (evt.keyCode === 40) newDate = new Date(actualTime + 7 * 864e5);\n\n            if (!this.isDisabled(newDate)) picker.select(newDate, true);\n          }\n        }, {\n          name: 'month',\n          format: options.monthFormat,\n          split: 4,\n          steps: {year: 1},\n          update: function (date, force) {\n            if (!this.built || date.getFullYear() !== viewDate.year) {\n              angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n              picker.$build();\n            } else if (date.getMonth() !== viewDate.month) {\n              angular.extend(viewDate, {month: picker.$date.getMonth(), date: picker.$date.getDate()});\n              picker.$updateSelected();\n            }\n          },\n          build: function () {\n            // var firstMonth = new Date(viewDate.year, 0, 1);\n            var months = [];\n            var month;\n            for (var i = 0; i < 12; i++) {\n              month = new Date(viewDate.year, i, 1);\n              months.push({date: month, label: formatDate(month, this.format), selected: picker.$isSelected(month), disabled: this.isDisabled(month)});\n            }\n            scope.title = formatDate(month, options.yearTitleFormat);\n            scope.showLabels = false;\n            scope.rows = split(months, this.split);\n            this.built = true;\n          },\n          isSelected: function (date) {\n            return picker.$date && date.getFullYear() === picker.$date.getFullYear() && date.getMonth() === picker.$date.getMonth();\n          },\n          isDisabled: function (date) {\n            var lastDate = +new Date(date.getFullYear(), date.getMonth() + 1, 0);\n            return lastDate < options.minDate || date.getTime() > options.maxDate;\n          },\n          onKeyDown: function (evt) {\n            if (!picker.$date) {\n              return;\n            }\n            var actualMonth = picker.$date.getMonth();\n            var newDate = new Date(picker.$date);\n\n            if (evt.keyCode === 37) newDate.setMonth(actualMonth - 1);\n              else if (evt.keyCode === 38) newDate.setMonth(actualMonth - 4);\n              else if (evt.keyCode === 39) newDate.setMonth(actualMonth + 1);\n              else if (evt.keyCode === 40) newDate.setMonth(actualMonth + 4);\n\n            if (!this.isDisabled(newDate)) picker.select(newDate, true);\n          }\n        }, {\n          name: 'year',\n          format: options.yearFormat,\n          split: 4,\n          steps: {year: 12},\n          update: function (date, force) {\n            if (!this.built || force || parseInt(date.getFullYear() / 20, 10) !== parseInt(viewDate.year / 20, 10)) {\n              angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n              picker.$build();\n            } else if (date.getFullYear() !== viewDate.year) {\n              angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n              picker.$updateSelected();\n            }\n          },\n          build: function () {\n            var firstYear = viewDate.year - viewDate.year % (this.split * 3);\n            var years = [];\n            var year;\n            for (var i = 0; i < 12; i++) {\n              year = new Date(firstYear + i, 0, 1);\n              years.push({date: year, label: formatDate(year, this.format), selected: picker.$isSelected(year), disabled: this.isDisabled(year)});\n            }\n            scope.title = years[0].label + '-' + years[years.length - 1].label;\n            scope.showLabels = false;\n            scope.rows = split(years, this.split);\n            this.built = true;\n          },\n          isSelected: function (date) {\n            return picker.$date && date.getFullYear() === picker.$date.getFullYear();\n          },\n          isDisabled: function (date) {\n            var lastDate = +new Date(date.getFullYear() + 1, 0, 0);\n            return lastDate < options.minDate || date.getTime() > options.maxDate;\n          },\n          onKeyDown: function (evt) {\n            if (!picker.$date) {\n              return;\n            }\n            var actualYear = picker.$date.getFullYear();\n            var newDate = new Date(picker.$date);\n\n            if (evt.keyCode === 37) newDate.setYear(actualYear - 1);\n              else if (evt.keyCode === 38) newDate.setYear(actualYear - 4);\n              else if (evt.keyCode === 39) newDate.setYear(actualYear + 1);\n              else if (evt.keyCode === 40) newDate.setYear(actualYear + 4);\n\n            if (!this.isDisabled(newDate)) picker.select(newDate, true);\n          }\n        }];\n\n        return {\n          views: options.minView ? Array.prototype.slice.call(views, options.minView) : views,\n          viewDate: viewDate\n        };\n\n      };\n\n    };\n\n  });\n\n// Source: modal/modal.js\nangular.module('mgcrea.ngStrap.modal', ['mgcrea.ngStrap.core', 'mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$modal', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      backdropAnimation: 'am-fade',\n      customClass: '',\n      prefixClass: 'modal',\n      prefixEvent: 'modal',\n      placement: 'top',\n      templateUrl: 'modal/modal.tpl.html',\n      template: '',\n      contentTemplate: false,\n      container: false,\n      element: null,\n      backdrop: true,\n      keyboard: true,\n      html: false,\n      show: true\n    };\n\n    this.$get = function ($window, $rootScope, $bsCompiler, $animate, $timeout, $sce, dimensions) {\n\n      var forEach = angular.forEach;\n      var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n      var bodyElement = angular.element($window.document.body);\n\n      var backdropCount = 0;\n      var dialogBaseZindex = 1050;\n      var backdropBaseZindex = 1040;\n\n      function ModalFactory(config) {\n\n        var $modal = {};\n\n        // Common vars\n        var options = $modal.$options = angular.extend({}, defaults, config);\n        var promise = $modal.$promise = $bsCompiler.compile(options);\n        var scope = $modal.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n\n        if (!options.element && !options.container) {\n          options.container = 'body';\n        }\n\n        // Store $id to identify the triggering element in events\n        // give priority to options.id, otherwise, try to use\n        // element id if defined\n        $modal.$id = options.id || options.element && options.element.attr('id') || '';\n\n        // Support scope as string options\n        forEach(['title', 'content'], function (key) {\n          if (options[key]) scope[key] = $sce.trustAsHtml(options[key]);\n        });\n\n        // Provide scope helpers\n        scope.$hide = function () {\n          scope.$$postDigest(function () {\n            $modal.hide();\n          });\n        };\n        scope.$show = function () {\n          scope.$$postDigest(function () {\n            $modal.show();\n          });\n        };\n        scope.$toggle = function () {\n          scope.$$postDigest(function () {\n            $modal.toggle();\n          });\n        };\n        // Publish isShown as a protected var on scope\n        $modal.$isShown = scope.$isShown = false;\n\n        // Fetch, compile then initialize modal\n        var compileData;\n        var modalElement;\n        var modalScope;\n        var backdropElement = angular.element('<div class=\"' + options.prefixClass + '-backdrop\"/>');\n        backdropElement.css({position: 'fixed', top: '0px', left: '0px', bottom: '0px', right: '0px'});\n        promise.then(function (data) {\n          compileData = data;\n          $modal.init();\n        });\n\n        $modal.init = function () {\n\n          // Options: show\n          if (options.show) {\n            scope.$$postDigest(function () {\n              $modal.show();\n            });\n          }\n\n        };\n\n        $modal.destroy = function () {\n\n          // Remove element\n          destroyModalElement();\n\n          // remove backdrop element\n          if (backdropElement) {\n            backdropElement.remove();\n            backdropElement = null;\n          }\n\n          // Destroy scope\n          scope.$destroy();\n        };\n\n        $modal.show = function () {\n          if ($modal.$isShown) return;\n          $rootScope.$emit('modal_fired', $modal.$isShown);\n          var parent;\n          var after;\n          if (angular.isElement(options.container)) {\n            parent = options.container;\n            after = options.container[0].lastChild ? angular.element(options.container[0].lastChild) : null;\n          } else {\n            if (options.container) {\n              parent = findElement(options.container);\n              after = parent[0] && parent[0].lastChild ? angular.element(parent[0].lastChild) : null;\n            } else {\n              parent = null;\n              after = options.element;\n            }\n          }\n\n          // destroy any existing modal elements\n          if (modalElement) destroyModalElement();\n\n          // create a new scope, so we can destroy it and all child scopes\n          // when destroying the modal element\n          modalScope = $modal.$scope.$new();\n          // Fetch a cloned element linked from template (noop callback is required)\n          modalElement = $modal.$element = compileData.link(modalScope, function (clonedElement, scope) {});\n\n          if (options.backdrop) {\n            // set z-index\n            modalElement.css({'z-index': dialogBaseZindex + (backdropCount * 20)});\n            backdropElement.css({'z-index': backdropBaseZindex + (backdropCount * 20)});\n\n            // increment number of backdrops\n            backdropCount++;\n          }\n\n          if (scope.$emit(options.prefixEvent + '.show.before', $modal).defaultPrevented) {\n            return;\n          }\n\n          // Set the initial positioning.\n          modalElement.css({display: 'block'}).addClass(options.placement);\n\n          // Options: customClass\n          if (options.customClass) {\n            modalElement.addClass(options.customClass);\n          }\n\n          // Options: animation\n          if (options.animation) {\n            if (options.backdrop) {\n              backdropElement.addClass(options.backdropAnimation);\n            }\n            modalElement.addClass(options.animation);\n          }\n\n          if (options.backdrop) {\n            $animate.enter(backdropElement, bodyElement, null);\n          }\n\n          // Support v1.2+ $animate\n          // https://github.com/angular/angular.js/issues/11713\n          if (angular.version.minor <= 2) {\n            $animate.enter(modalElement, parent, after, enterAnimateCallback);\n          } else {\n            $animate.enter(modalElement, parent, after).then(enterAnimateCallback);\n          }\n\n          $modal.$isShown = scope.$isShown = true;\n          safeDigest(scope);\n          // Focus once the enter-animation has started\n          // Weird PhantomJS bug hack\n          var el = modalElement[0];\n          requestAnimationFrame(function () {\n            el.focus();\n          });\n\n          bodyElement.addClass(options.prefixClass + '-open');\n          if (options.animation) {\n            bodyElement.addClass(options.prefixClass + '-with-' + options.animation);\n          }\n\n          // Bind events\n          bindBackdropEvents();\n          bindKeyboardEvents();\n        };\n\n        function enterAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.show', $modal);\n        }\n\n        $modal.hide = function () {\n          if (!$modal.$isShown) return;\n          $rootScope.$emit('modal_fired', $modal.$isShown);\n          if (options.backdrop) {\n            // decrement number of modals\n            backdropCount--;\n          }\n\n          if (scope.$emit(options.prefixEvent + '.hide.before', $modal).defaultPrevented) {\n            return;\n          }\n\n          // Support v1.2+ $animate\n          // https://github.com/angular/angular.js/issues/11713\n          if (angular.version.minor <= 2) {\n            $animate.leave(modalElement, leaveAnimateCallback);\n          } else {\n            $animate.leave(modalElement).then(leaveAnimateCallback);\n          }\n\n          if (options.backdrop) {\n            $animate.leave(backdropElement);\n          }\n          $modal.$isShown = scope.$isShown = false;\n          safeDigest(scope);\n\n          // Unbind events\n          unbindBackdropEvents();\n          unbindKeyboardEvents();\n        };\n\n        function leaveAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.hide', $modal);\n          bodyElement.removeClass(options.prefixClass + '-open');\n          if (options.animation) {\n            bodyElement.removeClass(options.prefixClass + '-with-' + options.animation);\n          }\n        }\n\n        $modal.toggle = function () {\n          if ($modal.$isShown) {\n            $modal.hide();\n          } else {\n            $modal.show();\n          }\n        };\n\n        $modal.focus = function () {\n          modalElement[0].focus();\n        };\n\n        // Protected methods\n\n        $modal.$onKeyUp = function (evt) {\n\n          if (evt.which === 27 && $modal.$isShown) {\n            $modal.hide();\n            evt.stopPropagation();\n          }\n\n        };\n\n        function bindBackdropEvents() {\n          if (options.backdrop) {\n            modalElement.on('click', hideOnBackdropClick);\n            backdropElement.on('click', hideOnBackdropClick);\n            backdropElement.on('wheel', preventEventDefault);\n          }\n        }\n\n        function unbindBackdropEvents() {\n          if (options.backdrop) {\n            modalElement.off('click', hideOnBackdropClick);\n            backdropElement.off('click', hideOnBackdropClick);\n            backdropElement.off('wheel', preventEventDefault);\n          }\n        }\n\n        function bindKeyboardEvents() {\n          if (options.keyboard) {\n            modalElement.on('keyup', $modal.$onKeyUp);\n          }\n        }\n\n        function unbindKeyboardEvents() {\n          if (options.keyboard) {\n            modalElement.off('keyup', $modal.$onKeyUp);\n          }\n        }\n\n        // Private helpers\n\n        function hideOnBackdropClick(evt) {\n          if (evt.target !== evt.currentTarget) return;\n          if (options.backdrop === 'static') {\n            $modal.focus();\n          } else {\n            $modal.hide();\n          }\n        }\n\n        function preventEventDefault(evt) {\n          evt.preventDefault();\n        }\n\n        function destroyModalElement() {\n          if ($modal.$isShown && modalElement !== null) {\n            // un-bind events\n            unbindBackdropEvents();\n            unbindKeyboardEvents();\n          }\n\n          if (modalScope) {\n            modalScope.$destroy();\n            modalScope = null;\n          }\n\n          if (modalElement) {\n            modalElement.remove();\n            modalElement = $modal.$element = null;\n          }\n        }\n\n        return $modal;\n\n      }\n\n      // Helper functions\n\n      function safeDigest(scope) {\n        /* eslint-disable no-unused-expressions */\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n        /* eslint-enable no-unused-expressions */\n      }\n\n      function findElement(query, element) {\n        return angular.element((element || document).querySelectorAll(query));\n      }\n\n      return ModalFactory;\n\n    };\n\n  })\n\n  .directive('bsModal', function ($window, $sce, $modal) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n\n        // Directive options\n        var options = {scope: scope, element: element, show: false};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'backdrop', 'keyboard', 'html', 'container', 'animation', 'backdropAnimation', 'id', 'prefixEvent', 'prefixClass', 'customClass', 'modalClass'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // Options: alias modalClass to customClass\n        if (options.modalClass) {\n          options.customClass = options.modalClass;\n        }\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['backdrop', 'keyboard', 'html', 'container'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\n        });\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content'], function (key) {\n          if (attr[key]) {\n            attr.$observe(key, function (newValue, oldValue) {\n              scope[key] = $sce.trustAsHtml(newValue);\n            });\n          }\n        });\n\n        // Support scope as an object\n        if (attr.bsModal) {\n          scope.$watch(attr.bsModal, function (newValue, oldValue) {\n            if (angular.isObject(newValue)) {\n              angular.extend(scope, newValue);\n            } else {\n              scope.content = newValue;\n            }\n          }, true);\n        }\n\n        // Initialize modal\n        var modal = $modal(options);\n\n        // Trigger\n        element.on(attr.trigger || 'click', modal.toggle);\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (modal) modal.destroy();\n          options = null;\n          modal = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: navbar/navbar.js\nangular.module('mgcrea.ngStrap.navbar', [])\n\n  .provider('$navbar', function () {\n\n    var defaults = this.defaults = {\n      activeClass: 'active',\n      routeAttr: 'data-match-route',\n      strict: false\n    };\n\n    this.$get = function () {\n      return {defaults: defaults};\n    };\n\n  })\n\n  .directive('bsNavbar', function ($window, $location, $navbar) {\n\n    var defaults = $navbar.defaults;\n\n    return {\n      restrict: 'A',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = angular.copy(defaults);\n        angular.forEach(Object.keys(defaults), function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // Watch for the $location\n        scope.$watch(function () {\n\n          return $location.path();\n\n        }, function (newValue, oldValue) {\n\n          var liElements = element[0].querySelectorAll('li[' + options.routeAttr + ']');\n\n          angular.forEach(liElements, function (li) {\n\n            var liElement = angular.element(li);\n            var pattern = liElement.attr(options.routeAttr).replace('/', '\\\\/');\n            if (options.strict) {\n              pattern = '^' + pattern + '$';\n            }\n            var regexp = new RegExp(pattern, 'i');\n\n            if (regexp.test(newValue)) {\n              liElement.addClass(options.activeClass);\n            } else {\n              liElement.removeClass(options.activeClass);\n            }\n\n          });\n\n        });\n\n      }\n\n    };\n\n  });\n\n// Source: helpers/raf.js\nif (angular.version.minor < 3 && angular.version.dot < 14) {\n  angular.module('ng')\n\n  .factory('$$rAF', function ($window, $timeout) {\n\n    var requestAnimationFrame = $window.requestAnimationFrame ||\n                                $window.webkitRequestAnimationFrame ||\n                                $window.mozRequestAnimationFrame;\n\n    var cancelAnimationFrame = $window.cancelAnimationFrame ||\n                               $window.webkitCancelAnimationFrame ||\n                               $window.mozCancelAnimationFrame ||\n                               $window.webkitCancelRequestAnimationFrame;\n\n    var rafSupported = !!requestAnimationFrame;\n    var raf = rafSupported ?\n      function (fn) {\n        var id = requestAnimationFrame(fn);\n        return function () {\n          cancelAnimationFrame(id);\n        };\n      } :\n      function (fn) {\n        var timer = $timeout(fn, 16.66, false); // 1000 / 60 = 16.666\n        return function () {\n          $timeout.cancel(timer);\n        };\n      };\n\n    raf.supported = rafSupported;\n\n    return raf;\n\n  });\n}\n\n// Source: helpers/parse-options.js\nangular.module('mgcrea.ngStrap.helpers.parseOptions', [])\n\n  .provider('$parseOptions', function () {\n\n    var defaults = this.defaults = {\n      regexp: /^\\s*(.*?)(?:\\s+as\\s+(.*?))?(?:\\s+group\\s+by\\s+(.*))?\\s+for\\s+(?:([\\$\\w][\\$\\w]*)|(?:\\(\\s*([\\$\\w][\\$\\w]*)\\s*,\\s*([\\$\\w][\\$\\w]*)\\s*\\)))\\s+in\\s+(.*?)(?:\\s+track\\s+by\\s+(.*?))?$/\n    };\n\n    this.$get = function ($parse, $q) {\n\n      function ParseOptionsFactory(attr, config) {\n\n        var $parseOptions = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        $parseOptions.$values = [];\n\n        // Private vars\n        var match;\n        var displayFn;\n        var valueName;\n        /* eslint-disable no-unused-vars */\n        var keyName;\n        var groupByFn;\n        /* eslint-enable no-unused-vars */\n        var valueFn;\n        var valuesFn;\n\n        $parseOptions.init = function () {\n          $parseOptions.$match = match = attr.match(options.regexp);\n          displayFn = $parse(match[2] || match[1]);\n          valueName = match[4] || match[6];\n          keyName = match[5];\n          groupByFn = $parse(match[3] || '');\n          valueFn = $parse(match[2] ? match[1] : valueName);\n          valuesFn = $parse(match[7]);\n        };\n\n        $parseOptions.valuesFn = function (scope, controller) {\n          return $q.when(valuesFn(scope, controller))\n          .then(function (values) {\n            if (!angular.isArray(values)) {\n              values = [];\n            }\n            $parseOptions.$values = values.length ? parseValues(values, scope) : [];\n            return $parseOptions.$values;\n          });\n        };\n\n        $parseOptions.displayValue = function (modelValue) {\n          var scope = {};\n          scope[valueName] = modelValue;\n          return displayFn(scope);\n        };\n\n        // Private functions\n\n        function parseValues(values, scope) {\n          return values.map(function (match, index) {\n            var locals = {};\n            var label;\n            var value;\n            locals[valueName] = match;\n            label = displayFn(scope, locals);\n            value = valueFn(scope, locals);\n            return {label: label, value: value, index: index};\n          });\n        }\n\n        $parseOptions.init();\n        return $parseOptions;\n\n      }\n\n      return ParseOptionsFactory;\n\n    };\n\n  });\n\n// Source: helpers/dimensions.js\nangular.module('mgcrea.ngStrap.helpers.dimensions', [])\n\n  .factory('dimensions', function () {\n\n    var fn = {};\n\n    /**\n     * Test the element nodeName\n     * @param element\n     * @param name\n     */\n    var nodeName = fn.nodeName = function (element, name) {\n      return element.nodeName && element.nodeName.toLowerCase() === name.toLowerCase();\n    };\n\n    /**\n     * Returns the element computed style\n     * @param element\n     * @param prop\n     * @param extra\n     */\n    fn.css = function (element, prop, extra) {\n      var value;\n      if (element.currentStyle) { // IE\n        value = element.currentStyle[prop];\n      } else if (window.getComputedStyle) {\n        value = window.getComputedStyle(element)[prop];\n      } else {\n        value = element.style[prop];\n      }\n      return extra === true ? parseFloat(value) || 0 : value;\n    };\n\n    /**\n     * Provides read-only equivalent of jQuery's offset function:\n     * @required-by bootstrap-tooltip, bootstrap-affix\n     * @url http://api.jquery.com/offset/\n     * @param element\n     */\n    fn.offset = function (element) {\n      var boxRect = element.getBoundingClientRect();\n      var docElement = element.ownerDocument;\n      return {\n        width: boxRect.width || element.offsetWidth,\n        height: boxRect.height || element.offsetHeight,\n        top: boxRect.top + (window.pageYOffset || docElement.documentElement.scrollTop) - (docElement.documentElement.clientTop || 0),\n        left: boxRect.left + (window.pageXOffset || docElement.documentElement.scrollLeft) - (docElement.documentElement.clientLeft || 0)\n      };\n    };\n\n    /**\n     * Provides set equivalent of jQuery's offset function:\n     * @required-by bootstrap-tooltip\n     * @url http://api.jquery.com/offset/\n     * @param element\n     * @param options\n     * @param i\n     */\n    fn.setOffset = function (element, options, i) {\n      var curPosition;\n      var curLeft;\n      var curCSSTop;\n      var curTop;\n      var curOffset;\n      var curCSSLeft;\n      var calculatePosition;\n      var position = fn.css(element, 'position');\n      var curElem = angular.element(element);\n      var props = {};\n\n      // Set position first, in-case top/left are set even on static elem\n      if (position === 'static') {\n        element.style.position = 'relative';\n      }\n\n      curOffset = fn.offset(element);\n      curCSSTop = fn.css(element, 'top');\n      curCSSLeft = fn.css(element, 'left');\n      calculatePosition = (position === 'absolute' || position === 'fixed') &&\n                          (curCSSTop + curCSSLeft).indexOf('auto') > -1;\n\n      // Need to be able to calculate position if either\n      // top or left is auto and position is either absolute or fixed\n      if (calculatePosition) {\n        curPosition = fn.position(element);\n        curTop = curPosition.top;\n        curLeft = curPosition.left;\n      } else {\n        curTop = parseFloat(curCSSTop) || 0;\n        curLeft = parseFloat(curCSSLeft) || 0;\n      }\n\n      if (angular.isFunction(options)) {\n        options = options.call(element, i, curOffset);\n      }\n\n      if (options.top !== null) {\n        props.top = (options.top - curOffset.top) + curTop;\n      }\n      if (options.left !== null) {\n        props.left = (options.left - curOffset.left) + curLeft;\n      }\n\n      if ('using' in options) {\n        options.using.call(curElem, props);\n      } else {\n        curElem.css({\n          top: props.top + 'px',\n          left: props.left + 'px'\n        });\n      }\n    };\n\n    /**\n     * Provides read-only equivalent of jQuery's position function\n     * @required-by bootstrap-tooltip, bootstrap-affix\n     * @url http://api.jquery.com/offset/\n     * @param element\n     */\n    fn.position = function (element) {\n\n      var offsetParentRect = {top: 0, left: 0};\n      var offsetParentEl;\n      var offset;\n\n      // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent\n      if (fn.css(element, 'position') === 'fixed') {\n\n        // We assume that getBoundingClientRect is available when computed position is fixed\n        offset = element.getBoundingClientRect();\n\n      } else {\n\n        // Get *real* offsetParentEl\n        offsetParentEl = offsetParentElement(element);\n\n        // Get correct offsets\n        offset = fn.offset(element);\n        if (!nodeName(offsetParentEl, 'html')) {\n          offsetParentRect = fn.offset(offsetParentEl);\n        }\n\n        // Add offsetParent borders\n        offsetParentRect.top += fn.css(offsetParentEl, 'borderTopWidth', true);\n        offsetParentRect.left += fn.css(offsetParentEl, 'borderLeftWidth', true);\n      }\n\n      // Subtract parent offsets and element margins\n      return {\n        width: element.offsetWidth,\n        height: element.offsetHeight,\n        top: offset.top - offsetParentRect.top - fn.css(element, 'marginTop', true),\n        left: offset.left - offsetParentRect.left - fn.css(element, 'marginLeft', true)\n      };\n\n    };\n\n    /**\n     * Returns the closest, non-statically positioned offsetParent of a given element\n     * @required-by fn.position\n     * @param element\n     */\n    function offsetParentElement(element) {\n      var docElement = element.ownerDocument;\n      var offsetParent = element.offsetParent || docElement;\n      if (nodeName(offsetParent, '#document')) return docElement.documentElement;\n      while (offsetParent && !nodeName(offsetParent, 'html') && fn.css(offsetParent, 'position') === 'static') {\n        offsetParent = offsetParent.offsetParent;\n      }\n      return offsetParent || docElement.documentElement;\n    }\n\n    /**\n     * Provides equivalent of jQuery's height function\n     * @required-by bootstrap-affix\n     * @url http://api.jquery.com/height/\n     * @param element\n     * @param outer\n     */\n    fn.height = function (element, outer) {\n      var value = element.offsetHeight;\n      if (outer) {\n        value += fn.css(element, 'marginTop', true) + fn.css(element, 'marginBottom', true);\n      } else {\n        value -= fn.css(element, 'paddingTop', true) + fn.css(element, 'paddingBottom', true) + fn.css(element, 'borderTopWidth', true) + fn.css(element, 'borderBottomWidth', true);\n      }\n      return value;\n    };\n\n    /**\n     * Provides equivalent of jQuery's width function\n     * @required-by bootstrap-affix\n     * @url http://api.jquery.com/width/\n     * @param element\n     * @param outer\n     */\n    fn.width = function (element, outer) {\n      var value = element.offsetWidth;\n      if (outer) {\n        value += fn.css(element, 'marginLeft', true) + fn.css(element, 'marginRight', true);\n      } else {\n        value -= fn.css(element, 'paddingLeft', true) + fn.css(element, 'paddingRight', true) + fn.css(element, 'borderLeftWidth', true) + fn.css(element, 'borderRightWidth', true);\n      }\n      return value;\n    };\n\n    return fn;\n\n  });\n\n// Source: helpers/debounce.js\nangular.module('mgcrea.ngStrap.helpers.debounce', [])\n\n// @source jashkenas/underscore\n// @url https://github.com/jashkenas/underscore/blob/1.5.2/underscore.js#L693\n.factory('debounce', function ($timeout) {\n  return function (func, wait, immediate) {\n    var timeout = null;\n    return function () {\n      var context = this;\n      var args = arguments;\n      var callNow = immediate && !timeout;\n      if (timeout) {\n        $timeout.cancel(timeout);\n      }\n      timeout = $timeout(function later() {\n        timeout = null;\n        if (!immediate) {\n          func.apply(context, args);\n        }\n      }, wait, false);\n      if (callNow) {\n        func.apply(context, args);\n      }\n      return timeout;\n    };\n  };\n})\n\n\n// @source jashkenas/underscore\n// @url https://github.com/jashkenas/underscore/blob/1.5.2/underscore.js#L661\n.factory('throttle', function ($timeout) {\n  return function (func, wait, options) {\n    var timeout = null;\n    if (!options) options = {};\n    return function () {\n      var context = this;\n      var args = arguments;\n      if (!timeout) {\n        if (options.leading !== false) {\n          func.apply(context, args);\n        }\n        timeout = $timeout(function later() {\n          timeout = null;\n          if (options.trailing !== false) {\n            func.apply(context, args);\n          }\n        }, wait, false);\n      }\n    };\n  };\n});\n\n// Source: helpers/date-parser.js\nangular.module('mgcrea.ngStrap.helpers.dateParser', [])\n\n.provider('$dateParser', function ($localeProvider) {\n\n  // define a custom ParseDate object to use instead of native Date\n  // to avoid date values wrapping when setting date component values\n  function ParseDate() {\n    this.year = 1970;\n    this.month = 0;\n    this.day = 1;\n    this.hours = 0;\n    this.minutes = 0;\n    this.seconds = 0;\n    this.milliseconds = 0;\n  }\n\n  ParseDate.prototype.setMilliseconds = function (value) { this.milliseconds = value; };\n  ParseDate.prototype.setSeconds = function (value) { this.seconds = value; };\n  ParseDate.prototype.setMinutes = function (value) { this.minutes = value; };\n  ParseDate.prototype.setHours = function (value) { this.hours = value; };\n  ParseDate.prototype.getHours = function () { return this.hours; };\n  ParseDate.prototype.setDate = function (value) { this.day = value; };\n  ParseDate.prototype.setMonth = function (value) { this.month = value; };\n  ParseDate.prototype.setFullYear = function (value) { this.year = value; };\n  ParseDate.prototype.fromDate = function (value) {\n    this.year = value.getFullYear();\n    this.month = value.getMonth();\n    this.day = value.getDate();\n    this.hours = value.getHours();\n    this.minutes = value.getMinutes();\n    this.seconds = value.getSeconds();\n    this.milliseconds = value.getMilliseconds();\n    return this;\n  };\n\n  ParseDate.prototype.toDate = function () {\n    return new Date(this.year, this.month, this.day, this.hours, this.minutes, this.seconds, this.milliseconds);\n  };\n\n  var proto = ParseDate.prototype;\n\n  function noop() {\n  }\n\n  function isNumeric(n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n  }\n\n  function indexOfCaseInsensitive(array, value) {\n    var len = array.length;\n    var str = value.toString().toLowerCase();\n    for (var i = 0; i < len; i++) {\n      if (array[i].toLowerCase() === str) { return i; }\n    }\n    return -1; // Return -1 per the \"Array.indexOf()\" method.\n  }\n\n  var defaults = this.defaults = {\n    format: 'shortDate',\n    strict: false\n  };\n\n  this.$get = function ($locale, dateFilter) {\n\n    var DateParserFactory = function (config) {\n\n      var options = angular.extend({}, defaults, config);\n\n      var $dateParser = {};\n\n      /* eslint-disable key-spacing, quote-props */\n      var regExpMap = {\n        'sss'   : '[0-9]{3}',\n        'ss'    : '[0-5][0-9]',\n        's'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\n        'mm'    : '[0-5][0-9]',\n        'm'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\n        'HH'    : '[01][0-9]|2[0-3]',\n        'H'     : options.strict ? '1?[0-9]|2[0-3]' : '[01]?[0-9]|2[0-3]',\n        'hh'    : '[0][1-9]|[1][012]',\n        'h'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\n        'a'     : 'AM|PM',\n        'EEEE'  : $locale.DATETIME_FORMATS.DAY.join('|'),\n        'EEE'   : $locale.DATETIME_FORMATS.SHORTDAY.join('|'),\n        'dd'    : '0[1-9]|[12][0-9]|3[01]',\n        'd'     : options.strict ? '[1-9]|[1-2][0-9]|3[01]' : '0?[1-9]|[1-2][0-9]|3[01]',\n        'MMMM'  : $locale.DATETIME_FORMATS.MONTH.join('|'),\n        'MMM'   : $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\n        'MM'    : '0[1-9]|1[012]',\n        'M'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\n        'yyyy'  : '[1]{1}[0-9]{3}|[2]{1}[0-9]{3}',\n        'yy'    : '[0-9]{2}',\n        'y'     : options.strict ? '-?(0|[1-9][0-9]{0,3})' : '-?0*[0-9]{1,4}'\n      };\n\n      var setFnMap = {\n        'sss'   : proto.setMilliseconds,\n        'ss'    : proto.setSeconds,\n        's'     : proto.setSeconds,\n        'mm'    : proto.setMinutes,\n        'm'     : proto.setMinutes,\n        'HH'    : proto.setHours,\n        'H'     : proto.setHours,\n        'hh'    : proto.setHours,\n        'h'     : proto.setHours,\n        'EEEE'  : noop,\n        'EEE'   : noop,\n        'dd'    : proto.setDate,\n        'd'     : proto.setDate,\n        'a'     : function (value) { var hours = this.getHours() % 12; return this.setHours(value.match(/pm/i) ? hours + 12 : hours); },\n        'MMMM'  : function (value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.MONTH, value)); },\n        'MMM'   : function (value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.SHORTMONTH, value)); },\n        'MM'    : function (value) { return this.setMonth(1 * value - 1); },\n        'M'     : function (value) { return this.setMonth(1 * value - 1); },\n        'yyyy'  : proto.setFullYear,\n        'yy'    : function (value) { return this.setFullYear(2000 + 1 * value); },\n        'y'     : function (value) { return (1 * value <= 50 && value.length === 2) ? this.setFullYear(2000 + 1 * value) : this.setFullYear(1 * value); }\n      };\n      /* eslint-enable key-spacing, quote-props */\n\n      var regex;\n      var setMap;\n\n      $dateParser.init = function () {\n        $dateParser.$format = $locale.DATETIME_FORMATS[options.format] || options.format;\n        regex = regExpForFormat($dateParser.$format);\n        setMap = setMapForFormat($dateParser.$format);\n      };\n\n      $dateParser.isValid = function (date) {\n        if (angular.isDate(date)) return !isNaN(date.getTime());\n        return regex.test(date);\n      };\n\n      $dateParser.parse = function (value, baseDate, format, timezone) {\n        // check for date format special names\n        if (format) format = $locale.DATETIME_FORMATS[format] || format;\n        if (angular.isDate(value)) value = dateFilter(value, format || $dateParser.$format, timezone);\n        var formatRegex = format ? regExpForFormat(format) : regex;\n        var formatSetMap = format ? setMapForFormat(format) : setMap;\n        var matches = formatRegex.exec(value);\n        if (!matches) return false;\n        // use custom ParseDate object to set parsed values\n        var date = baseDate && !isNaN(baseDate.getTime()) ? new ParseDate().fromDate(baseDate) : new ParseDate().fromDate(new Date(1970, 0, 1, 0));\n        for (var i = 0; i < matches.length - 1; i++) {\n          if (formatSetMap[i]) formatSetMap[i].call(date, matches[i + 1]);\n        }\n        // convert back to native Date object\n        var newDate = date.toDate();\n\n        // check new native Date object for day values overflow\n        if (parseInt(date.day, 10) !== newDate.getDate()) {\n          return false;\n        }\n\n        return newDate;\n      };\n\n      $dateParser.getDateForAttribute = function (key, value) {\n        var date;\n\n        if (value === 'today') {\n          var today = new Date();\n          date = new Date(today.getFullYear(), today.getMonth(), today.getDate() + (key === 'maxDate' ? 1 : 0), 0, 0, 0, (key === 'minDate' ? 0 : -1));\n        } else if (angular.isString(value) && value.match(/^\".+\"$/)) { // Support {{ dateObj }}\n          date = new Date(value.substr(1, value.length - 2));\n        } else if (isNumeric(value)) {\n          date = new Date(parseInt(value, 10));\n        } else if (angular.isString(value) && value.length === 0) { // Reset date\n          date = key === 'minDate' ? -Infinity : +Infinity;\n        } else {\n          date = new Date(value);\n        }\n\n        return date;\n      };\n\n      $dateParser.getTimeForAttribute = function (key, value) {\n        var time;\n\n        if (value === 'now') {\n          time = new Date().setFullYear(1970, 0, 1);\n        } else if (angular.isString(value) && value.match(/^\".+\"$/)) {\n          time = new Date(value.substr(1, value.length - 2)).setFullYear(1970, 0, 1);\n        } else if (isNumeric(value)) {\n          time = new Date(parseInt(value, 10)).setFullYear(1970, 0, 1);\n        } else if (angular.isString(value) && value.length === 0) { // Reset time\n          time = key === 'minTime' ? -Infinity : +Infinity;\n        } else {\n          time = $dateParser.parse(value, new Date(1970, 0, 1, 0));\n        }\n\n        return time;\n      };\n\n      /* Handle switch to/from daylight saving.\n      * Hours may be non-zero on daylight saving cut-over:\n      * > 12 when midnight changeover, but then cannot generate\n      * midnight datetime, so jump to 1AM, otherwise reset.\n      * @param  date  (Date) the date to check\n      * @return  (Date) the corrected date\n      *\n      * __ copied from jquery ui datepicker __\n      */\n      $dateParser.daylightSavingAdjust = function (date) {\n        if (!date) {\n          return null;\n        }\n        date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);\n        return date;\n      };\n\n      /* Correct the date for timezone offset.\n      * @param  date  (Date) the date to adjust\n      * @param  timezone  (string) the timezone to adjust for\n      * @param  undo  (boolean) to add or subtract timezone offset\n      * @return  (Date) the corrected date\n      */\n      $dateParser.timezoneOffsetAdjust = function (date, timezone, undo) {\n        if (!date) {\n          return null;\n        }\n        // Right now, only 'UTC' is supported.\n        if (timezone && timezone === 'UTC') {\n          date = new Date(date.getTime());\n          date.setMinutes(date.getMinutes() + (undo ? -1 : 1) * date.getTimezoneOffset());\n        }\n        return date;\n      };\n\n      // Private functions\n\n      function regExpForFormat(format) {\n        // `format` string can contain literal values.\n        // These need to be escaped by surrounding with\n        // single quotes (e.g. `\"h 'in the morning'\"`).\n        // In order to output a single quote, escape it - i.e.,\n        // two single quotes in a sequence (e.g. `\"h 'o''clock'\"`).\n\n        var re = buildDateAbstractRegex(format);\n        return buildDateParseRegex(re);\n      }\n\n      function buildDateAbstractRegex(format) {\n        var escapedFormat = escapeReservedSymbols(format);\n        var escapedLiteralFormat = escapedFormat.replace(/''/g, '\\\\\\'');\n        var literalRegex = /('(?:\\\\'|.)*?')/;\n        var formatParts = escapedLiteralFormat.split(literalRegex);\n        var dateElements = Object.keys(regExpMap);\n        var dateRegexParts = [];\n\n        angular.forEach(formatParts, function (part) {\n          if (isFormatStringLiteral(part)) {\n            part = trimLiteralEscapeChars(part);\n          } else {\n            // Abstract replaces to avoid collisions\n            for (var i = 0; i < dateElements.length; i++) {\n              part = part.split(dateElements[i]).join('${' + i + '}');\n            }\n          }\n          dateRegexParts.push(part);\n        });\n\n        return dateRegexParts.join('');\n      }\n\n      function escapeReservedSymbols(text) {\n        return text.replace(/\\\\/g, '[\\\\\\\\]')\n                   .replace(/-/g, '[-]')\n                   .replace(/\\./g, '[.]')\n                   .replace(/\\*/g, '[*]')\n                   .replace(/\\+/g, '[+]')\n                   .replace(/\\?/g, '[?]')\n                   .replace(/\\$/g, '[$]')\n                   .replace(/\\^/g, '[^]')\n                   .replace(/\\//g, '[/]')\n                   .replace(/\\\\s/g, '[\\\\s]');\n      }\n\n      function isFormatStringLiteral(text) {\n        return /^'.*'$/.test(text);\n      }\n\n      function trimLiteralEscapeChars(text) {\n        return text.replace(/^'(.*)'$/, '$1');\n      }\n\n      function buildDateParseRegex(abstractRegex) {\n        var dateElements = Object.keys(regExpMap);\n        var re = abstractRegex;\n\n        // Replace abstracted values\n        for (var i = 0; i < dateElements.length; i++) {\n          re = re.split('${' + i + '}').join('(' + regExpMap[dateElements[i]] + ')');\n        }\n\n        return new RegExp('^' + re + '$', ['i']);\n      }\n\n      function setMapForFormat(format) {\n        var re = buildDateAbstractRegex(format);\n        return buildDateParseValuesMap(re);\n      }\n\n      function buildDateParseValuesMap(abstractRegex) {\n        var dateElements = Object.keys(regExpMap);\n        var valuesRegex = new RegExp('\\\\${(\\\\d+)}', 'g');\n        var valuesMatch;\n        var keyIndex;\n        var valueKey;\n        var valueFunction;\n        var valuesFunctionMap = [];\n\n        /* eslint-disable no-cond-assign */\n        while ((valuesMatch = valuesRegex.exec(abstractRegex)) !== null) {\n          keyIndex = valuesMatch[1];\n          valueKey = dateElements[keyIndex];\n          valueFunction = setFnMap[valueKey];\n\n          valuesFunctionMap.push(valueFunction);\n        }\n\n        return valuesFunctionMap;\n      }\n\n      $dateParser.init();\n      return $dateParser;\n\n    };\n\n    return DateParserFactory;\n\n  };\n\n});\n\n// Source: helpers/date-formatter.js\nangular.module('mgcrea.ngStrap.helpers.dateFormatter', [])\n\n  .service('$dateFormatter', function ($locale, dateFilter) {\n\n    // The unused `lang` arguments are on purpose. The default implementation does not\n    // use them and it always uses the locale loaded into the `$locale` service.\n    // Custom implementations might use it, thus allowing different directives to\n    // have different languages.\n\n    this.getDefaultLocale = function () {\n      return $locale.id;\n    };\n\n    // Format is either a data format name, e.g. \"shortTime\" or \"fullDate\", or a date format\n    // Return either the corresponding date format or the given date format.\n    this.getDatetimeFormat = function (format, lang) {\n      return $locale.DATETIME_FORMATS[format] || format;\n    };\n\n    this.weekdaysShort = function (lang) {\n      return $locale.DATETIME_FORMATS.SHORTDAY;\n    };\n\n    function splitTimeFormat(format) {\n      return /(h+)([:\\.])?(m+)([:\\.])?(s*)[ ]?(a?)/i.exec(format).slice(1);\n    }\n\n    // h:mm a => h\n    this.hoursFormat = function (timeFormat) {\n      return splitTimeFormat(timeFormat)[0];\n    };\n\n    // h:mm a => mm\n    this.minutesFormat = function (timeFormat) {\n      return splitTimeFormat(timeFormat)[2];\n    };\n\n    // h:mm:ss a => ss\n    this.secondsFormat = function (timeFormat) {\n      return splitTimeFormat(timeFormat)[4];\n    };\n\n    // h:mm a => :\n    this.timeSeparator = function (timeFormat) {\n      return splitTimeFormat(timeFormat)[1];\n    };\n\n    // h:mm:ss a => true, h:mm a => false\n    this.showSeconds = function (timeFormat) {\n      return !!splitTimeFormat(timeFormat)[4];\n    };\n\n    // h:mm a => true, H.mm => false\n    this.showAM = function (timeFormat) {\n      return !!splitTimeFormat(timeFormat)[5];\n    };\n\n    this.formatDate = function (date, format, lang, timezone) {\n      return dateFilter(date, format, timezone);\n    };\n\n  });\n\n// Source: helpers/compiler.js\n// NOTICE: This file was forked from the angular-material project (github.com/angular/material)\n// MIT Licensed - Copyright (c) 2014-2015 Google, Inc. http://angularjs.org\n\nangular.module('mgcrea.ngStrap.core', [])\n  .service('$bsCompiler', bsCompilerService);\n\nfunction bsCompilerService($q, $http, $injector, $compile, $controller, $templateCache) {\n\n  /*\n   * @ngdoc service\n   * @name $bsCompiler\n   * @module material.core\n   * @description\n   * The $bsCompiler service is an abstraction of angular's compiler, that allows the developer\n   * to easily compile an element with a templateUrl, controller, and locals.\n   *\n   * @usage\n   * <hljs lang=\"js\">\n   * $bsCompiler.compile({\n   *   templateUrl: 'modal.html',\n   *   controller: 'ModalCtrl',\n   *   locals: {\n   *     modal: myModalInstance;\n   *   }\n   * }).then(function(compileData) {\n   *   compileData.element; // modal.html's template in an element\n   *   compileData.link(myScope); //attach controller & scope to element\n   * });\n   * </hljs>\n   */\n\n   /*\n    * @ngdoc method\n    * @name $bsCompiler#compile\n    * @description A helper to compile an HTML template/templateUrl with a given controller,\n    * locals, and scope.\n    * @param {object} options An options object, with the following properties:\n    *\n    *    - `controller` - `{(string=|function()=}` Controller fn that should be associated with\n    *      newly created scope or the name of a registered controller if passed as a string.\n    *    - `controllerAs` - `{string=}` A controller alias name. If present the controller will be\n    *      published to scope under the `controllerAs` name.\n    *    - `template` - `{string=}` An html template as a string.\n    *    - `templateUrl` - `{string=}` A path to an html template.\n    *    - `transformTemplate` - `{function(template)=}` A function which transforms the template after\n    *      it is loaded. It will be given the template string as a parameter, and should\n    *      return a a new string representing the transformed template.\n    *    - `resolve` - `{Object.<string, function>=}` - An optional map of dependencies which should\n    *      be injected into the controller. If any of these dependencies are promises, the compiler\n    *      will wait for them all to be resolved, or if one is rejected before the controller is\n    *      instantiated `compile()` will fail..\n    *      * `key` - `{string}`: a name of a dependency to be injected into the controller.\n    *      * `factory` - `{string|function}`: If `string` then it is an alias for a service.\n    *        Otherwise if function, then it is injected and the return value is treated as the\n    *        dependency. If the result is a promise, it is resolved before its value is\n    *        injected into the controller.\n    *\n    * @returns {object=} promise A promise, which will be resolved with a `compileData` object.\n    * `compileData` has the following properties:\n    *\n    *   - `element` - `{element}`: an uncompiled element matching the provided template.\n    *   - `link` - `{function(scope)}`: A link function, which, when called, will compile\n    *     the element and instantiate the provided controller (if given).\n    *   - `locals` - `{object}`: The locals which will be passed into the controller once `link` is\n    *     called. If `bindToController` is true, they will be coppied to the ctrl instead\n    *   - `bindToController` - `bool`: bind the locals to the controller, instead of passing them in.\n    */\n  this.compile = function (options) {\n\n    if (options.template && /\\.html$/.test(options.template)) {\n      console.warn('Deprecated use of `template` option to pass a file. Please use the `templateUrl` option instead.');\n      options.templateUrl = options.template;\n      options.template = '';\n    }\n\n    var templateUrl = options.templateUrl;\n    var template = options.template || '';\n    var controller = options.controller;\n    var controllerAs = options.controllerAs;\n    var resolve = angular.copy(options.resolve || {});\n    var locals = angular.copy(options.locals || {});\n    var transformTemplate = options.transformTemplate || angular.identity;\n    var bindToController = options.bindToController;\n\n    // Take resolve values and invoke them.\n    // Resolves can either be a string (value: 'MyRegisteredAngularConst'),\n    // or an invokable 'factory' of sorts: (value: function ValueGetter($dependency) {})\n    angular.forEach(resolve, function (value, key) {\n      if (angular.isString(value)) {\n        resolve[key] = $injector.get(value);\n      } else {\n        resolve[key] = $injector.invoke(value);\n      }\n    });\n    // Add the locals, which are just straight values to inject\n    // eg locals: { three: 3 }, will inject three into the controller\n    angular.extend(resolve, locals);\n\n    if (template) {\n      resolve.$template = $q.when(template);\n    } else if (templateUrl) {\n      resolve.$template = fetchTemplate(templateUrl);\n    } else {\n      throw new Error('Missing `template` / `templateUrl` option.');\n    }\n\n    if (options.titleTemplate) {\n      resolve.$template = $q.all([resolve.$template, fetchTemplate(options.titleTemplate)])\n        .then(function (templates) {\n          var templateEl = angular.element(templates[0]);\n          findElement('[ng-bind=\"title\"]', templateEl[0])\n            .removeAttr('ng-bind')\n            .html(templates[1]);\n          return templateEl[0].outerHTML;\n        });\n    }\n\n    if (options.contentTemplate) {\n      // TODO(mgcrea): deprecate?\n      resolve.$template = $q.all([resolve.$template, fetchTemplate(options.contentTemplate)])\n        .then(function (templates) {\n          var templateEl = angular.element(templates[0]);\n          var contentEl = findElement('[ng-bind=\"content\"]', templateEl[0])\n            .removeAttr('ng-bind')\n            .html(templates[1]);\n          // Drop the default footer as you probably don't want it if you use a custom contentTemplate\n          if (!options.templateUrl) contentEl.next().remove();\n          return templateEl[0].outerHTML;\n        });\n    }\n\n    // Wait for all the resolves to finish if they are promises\n    return $q.all(resolve).then(function (locals) {\n\n      var template = transformTemplate(locals.$template);\n      if (options.html) {\n        template = template.replace(/ng-bind=\"/ig, 'ng-bind-html=\"');\n      }\n      // var element = options.element || angular.element('<div>').html(template.trim()).contents();\n      var element = angular.element('<div>').html(template.trim()).contents();\n      var linkFn = $compile(element);\n\n      // Return a linking function that can be used later when the element is ready\n      return {\n        locals: locals,\n        element: element,\n        link: function link(scope) {\n          locals.$scope = scope;\n\n          // Instantiate controller if it exists, because we have scope\n          if (controller) {\n            var invokeCtrl = $controller(controller, locals, true);\n            if (bindToController) {\n              angular.extend(invokeCtrl.instance, locals);\n            }\n            // Support angular@~1.2 invokeCtrl\n            var ctrl = angular.isObject(invokeCtrl) ? invokeCtrl : invokeCtrl();\n            // See angular-route source for this logic\n            element.data('$ngControllerController', ctrl);\n            element.children().data('$ngControllerController', ctrl);\n\n            if (controllerAs) {\n              scope[controllerAs] = ctrl;\n            }\n          }\n\n          return linkFn.apply(null, arguments);\n        }\n      };\n    });\n\n  };\n\n  function findElement(query, element) {\n    return angular.element((element || document).querySelectorAll(query));\n  }\n\n  var fetchPromises = {};\n  function fetchTemplate(template) {\n    if (fetchPromises[template]) return fetchPromises[template];\n    return (fetchPromises[template] = $http.get(template, {cache: $templateCache})\n      .then(function (res) {\n        return res.data;\n      }));\n  }\n\n}\n\n// Source: collapse/collapse.js\nangular.module('mgcrea.ngStrap.collapse', [])\n\n  .provider('$collapse', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-collapse',\n      disallowToggle: false,\n      activeClass: 'in',\n      startCollapsed: false,\n      allowMultiple: false\n    };\n\n    var controller = this.controller = function ($scope, $element, $attrs) {\n      var self = this;\n\n      // Attributes options\n      self.$options = angular.copy(defaults);\n      angular.forEach(['animation', 'disallowToggle', 'activeClass', 'startCollapsed', 'allowMultiple'], function (key) {\n        if (angular.isDefined($attrs[key])) self.$options[key] = $attrs[key];\n      });\n\n      // use string regex match boolean attr falsy values, leave truthy values be\n      var falseValueRegExp = /^(false|0|)$/i;\n      angular.forEach(['disallowToggle', 'startCollapsed', 'allowMultiple'], function (key) {\n        if (angular.isDefined($attrs[key]) && falseValueRegExp.test($attrs[key])) {\n          self.$options[key] = false;\n        }\n      });\n\n      self.$toggles = [];\n      self.$targets = [];\n\n      self.$viewChangeListeners = [];\n\n      self.$registerToggle = function (element) {\n        self.$toggles.push(element);\n      };\n      self.$registerTarget = function (element) {\n        self.$targets.push(element);\n      };\n\n      self.$unregisterToggle = function (element) {\n        var index = self.$toggles.indexOf(element);\n        // remove toggle from $toggles array\n        self.$toggles.splice(index, 1);\n      };\n      self.$unregisterTarget = function (element) {\n        var index = self.$targets.indexOf(element);\n\n        // remove element from $targets array\n        self.$targets.splice(index, 1);\n\n        if (self.$options.allowMultiple) {\n          // remove target index from $active array values\n          deactivateItem(element);\n        }\n\n        // fix active item indexes\n        fixActiveItemIndexes(index);\n\n        self.$viewChangeListeners.forEach(function (fn) {\n          fn();\n        });\n      };\n\n      // use array to store all the currently open panels\n      self.$targets.$active = !self.$options.startCollapsed ? [0] : [];\n      self.$setActive = $scope.$setActive = function (value) {\n        if (angular.isArray(value)) {\n          self.$targets.$active = value;\n        } else if (!self.$options.disallowToggle && isActive(value)) {\n          deactivateItem(value);\n        } else {\n          activateItem(value);\n        }\n\n        self.$viewChangeListeners.forEach(function (fn) {\n          fn();\n        });\n      };\n\n      self.$activeIndexes = function () {\n        if (self.$options.allowMultiple) {\n          return self.$targets.$active;\n        }\n        return self.$targets.$active.length === 1 ? self.$targets.$active[0] : -1;\n      };\n\n      function fixActiveItemIndexes(index) {\n        // item with index was removed, so we\n        // need to adjust other items index values\n        var activeIndexes = self.$targets.$active;\n        for (var i = 0; i < activeIndexes.length; i++) {\n          if (index < activeIndexes[i]) {\n            activeIndexes[i] = activeIndexes[i] - 1;\n          }\n\n          // the last item is active, so we need to\n          // adjust its index\n          if (activeIndexes[i] === self.$targets.length) {\n            activeIndexes[i] = self.$targets.length - 1;\n          }\n        }\n      }\n\n      function isActive(value) {\n        var activeItems = self.$targets.$active;\n        return activeItems.indexOf(value) === -1 ? false : true;\n      }\n\n      function deactivateItem(value) {\n        var index = self.$targets.$active.indexOf(value);\n        if (index !== -1) {\n          self.$targets.$active.splice(index, 1);\n        }\n      }\n\n      function activateItem(value) {\n        if (!self.$options.allowMultiple) {\n          // remove current selected item\n          self.$targets.$active.splice(0, 1);\n        }\n\n        if (self.$targets.$active.indexOf(value) === -1) {\n          self.$targets.$active.push(value);\n        }\n      }\n\n    };\n\n    this.$get = function () {\n      var $collapse = {};\n      $collapse.defaults = defaults;\n      $collapse.controller = controller;\n      return $collapse;\n    };\n\n  })\n\n  .directive('bsCollapse', function ($window, $animate, $collapse) {\n\n    return {\n      require: ['?ngModel', 'bsCollapse'],\n      controller: ['$scope', '$element', '$attrs', $collapse.controller],\n      link: function postLink(scope, element, attrs, controllers) {\n\n        var ngModelCtrl = controllers[0];\n        var bsCollapseCtrl = controllers[1];\n\n        if (ngModelCtrl) {\n\n          // Update the modelValue following\n          bsCollapseCtrl.$viewChangeListeners.push(function () {\n            ngModelCtrl.$setViewValue(bsCollapseCtrl.$activeIndexes());\n          });\n\n          // modelValue -> $formatters -> viewValue\n          ngModelCtrl.$formatters.push(function (modelValue) {\n            // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n            if (angular.isArray(modelValue)) {\n              // model value is an array, so just replace\n              // the active items directly\n              bsCollapseCtrl.$setActive(modelValue);\n            } else {\n              var activeIndexes = bsCollapseCtrl.$activeIndexes();\n\n              if (angular.isArray(activeIndexes)) {\n                // we have an array of selected indexes\n                if (activeIndexes.indexOf(modelValue * 1) === -1) {\n                  // item with modelValue index is not active\n                  bsCollapseCtrl.$setActive(modelValue * 1);\n                }\n              } else if (activeIndexes !== modelValue * 1) {\n                bsCollapseCtrl.$setActive(modelValue * 1);\n              }\n            }\n            return modelValue;\n          });\n\n        }\n\n      }\n    };\n\n  })\n\n  .directive('bsCollapseToggle', function () {\n\n    return {\n      require: ['^?ngModel', '^bsCollapse'],\n      link: function postLink(scope, element, attrs, controllers) {\n\n        // var ngModelCtrl = controllers[0];\n        var bsCollapseCtrl = controllers[1];\n\n        // Add base attr\n        element.attr('data-toggle', 'collapse');\n\n        // Push pane to parent bsCollapse controller\n        bsCollapseCtrl.$registerToggle(element);\n\n        // remove toggle from collapse controller when toggle is destroyed\n        scope.$on('$destroy', function () {\n          bsCollapseCtrl.$unregisterToggle(element);\n        });\n\n        element.on('click', function () {\n          if (!attrs.disabled) {\n            var index = attrs.bsCollapseToggle && attrs.bsCollapseToggle !== 'bs-collapse-toggle' ? attrs.bsCollapseToggle : bsCollapseCtrl.$toggles.indexOf(element);\n            bsCollapseCtrl.$setActive(index * 1);\n            scope.$apply();\n          }\n        });\n\n      }\n    };\n\n  })\n\n  .directive('bsCollapseTarget', function ($animate) {\n\n    return {\n      require: ['^?ngModel', '^bsCollapse'],\n      // scope: true,\n      link: function postLink(scope, element, attrs, controllers) {\n\n        // var ngModelCtrl = controllers[0];\n        var bsCollapseCtrl = controllers[1];\n\n        // Add base class\n        element.addClass('collapse');\n\n        // Add animation class\n        if (bsCollapseCtrl.$options.animation) {\n          element.addClass(bsCollapseCtrl.$options.animation);\n        }\n\n        // Push pane to parent bsCollapse controller\n        bsCollapseCtrl.$registerTarget(element);\n\n        // remove pane target from collapse controller when target is destroyed\n        scope.$on('$destroy', function () {\n          bsCollapseCtrl.$unregisterTarget(element);\n        });\n\n        function render() {\n          var index = bsCollapseCtrl.$targets.indexOf(element);\n          var active = bsCollapseCtrl.$activeIndexes();\n          var action = 'removeClass';\n          if (angular.isArray(active)) {\n            if (active.indexOf(index) !== -1) {\n              action = 'addClass';\n            }\n          } else if (index === active) {\n            action = 'addClass';\n          }\n\n          $animate[action](element, bsCollapseCtrl.$options.activeClass);\n        }\n\n        bsCollapseCtrl.$viewChangeListeners.push(function () {\n          render();\n        });\n        render();\n\n      }\n    };\n\n  });\n\n// Source: dropdown/dropdown.js\nangular.module('mgcrea.ngStrap.dropdown', ['mgcrea.ngStrap.tooltip'])\n\n  .provider('$dropdown', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'dropdown',\n      prefixEvent: 'dropdown',\n      placement: 'bottom-left',\n      templateUrl: 'dropdown/dropdown.tpl.html',\n      trigger: 'click',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0\n    };\n\n    this.$get = function ($window, $rootScope, $tooltip, $timeout) {\n\n      var bodyEl = angular.element($window.document.body);\n      var matchesSelector = Element.prototype.matchesSelector || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector;\n\n      function DropdownFactory(element, config) {\n\n        var $dropdown = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        /* var scope = */$dropdown.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n\n        $dropdown = $tooltip(element, options);\n        var parentEl = element.parent();\n\n        // Protected methods\n\n        $dropdown.$onKeyDown = function (evt) {\n          if (!/(38|40)/.test(evt.keyCode)) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          // Retrieve focused index\n          var items = angular.element($dropdown.$element[0].querySelectorAll('li:not(.divider) a'));\n          if (!items.length) return;\n          var index;\n          angular.forEach(items, function (el, i) {\n            if (matchesSelector && matchesSelector.call(el, ':focus')) index = i;\n          });\n\n          // Navigate with keyboard\n          if (evt.keyCode === 38 && index > 0) index--;\n          else if (evt.keyCode === 40 && index < items.length - 1) index++;\n          else if (angular.isUndefined(index)) index = 0;\n          items.eq(index)[0].focus();\n\n        };\n\n        // Overrides\n\n        var show = $dropdown.show;\n        $dropdown.show = function () {\n          show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function () {\n            if (options.keyboard && $dropdown.$element) $dropdown.$element.on('keydown', $dropdown.$onKeyDown);\n            bodyEl.on('click', onBodyClick);\n          }, 0, false);\n          if (parentEl.hasClass('dropdown')) parentEl.addClass('open');\n        };\n\n        var hide = $dropdown.hide;\n        $dropdown.hide = function () {\n          if (!$dropdown.$isShown) return;\n          if (options.keyboard && $dropdown.$element) $dropdown.$element.off('keydown', $dropdown.$onKeyDown);\n          bodyEl.off('click', onBodyClick);\n          if (parentEl.hasClass('dropdown')) parentEl.removeClass('open');\n          hide();\n        };\n\n        var destroy = $dropdown.destroy;\n        $dropdown.destroy = function () {\n          bodyEl.off('click', onBodyClick);\n          destroy();\n        };\n\n        // Private functions\n\n        function onBodyClick(evt) {\n          if (evt.target === element[0]) return;\n          return evt.target !== element[0] && $dropdown.hide();\n        }\n\n        return $dropdown;\n\n      }\n\n      return DropdownFactory;\n\n    };\n\n  })\n\n  .directive('bsDropdown', function ($window, $sce, $dropdown) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      compile: function (tElement, tAttrs) {\n\n        // Support for inlined template (next sibling)\n        // It must be fetched before compilation\n        if (!tAttrs.bsDropdown) {\n          var nextSibling = tElement[0].nextSibling;\n          while (nextSibling && nextSibling.nodeType !== 1) {\n            nextSibling = nextSibling.nextSibling;\n          }\n          if (nextSibling && nextSibling.classList.contains('dropdown-menu')) {\n            tAttrs.template = nextSibling.outerHTML;\n            tAttrs.templateUrl = undefined;\n            nextSibling.parentNode.removeChild(nextSibling);\n          }\n        }\n\n        return function postLink(scope, element, attr) {\n\n          // Directive options\n          var options = {scope: scope};\n          angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'id', 'autoClose'], function (key) {\n            if (angular.isDefined(tAttrs[key])) options[key] = tAttrs[key];\n          });\n\n          // use string regex match boolean attr falsy values, leave truthy values be\n          var falseValueRegExp = /^(false|0|)$/i;\n          angular.forEach(['html', 'container'], function (key) {\n            if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\n          });\n\n          // Support scope as an object\n          if (attr.bsDropdown) {\n            scope.$watch(attr.bsDropdown, function (newValue, oldValue) {\n              scope.content = newValue;\n            }, true);\n          }\n\n          // Initialize dropdown\n          var dropdown = $dropdown(element, options);\n\n          // Visibility binding support\n          if (attr.bsShow) {\n            scope.$watch(attr.bsShow, function (newValue, oldValue) {\n              if (!dropdown || !angular.isDefined(newValue)) return;\n              if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(dropdown),?/i);\n              if (newValue === true) {\n                dropdown.show();\n              } else {\n                dropdown.hide();\n              }\n            });\n          }\n\n          // Garbage collection\n          scope.$on('$destroy', function () {\n            if (dropdown) dropdown.destroy();\n            options = null;\n            dropdown = null;\n          });\n\n        };\n      }\n    };\n\n  });\n\n// Source: aside/aside.js\nangular.module('mgcrea.ngStrap.aside', ['mgcrea.ngStrap.modal'])\n\n  .provider('$aside', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade-and-slide-right',\n      prefixClass: 'aside',\n      prefixEvent: 'aside',\n      placement: 'right',\n      templateUrl: 'aside/aside.tpl.html',\n      contentTemplate: false,\n      container: false,\n      element: null,\n      backdrop: true,\n      keyboard: true,\n      html: false,\n      show: true\n    };\n\n    this.$get = function ($modal) {\n\n      function AsideFactory(config) {\n\n        var $aside = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $aside = $modal(options);\n\n        return $aside;\n\n      }\n\n      return AsideFactory;\n\n    };\n\n  })\n\n  .directive('bsAside', function ($window, $sce, $aside) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n        // Directive options\n        var options = {scope: scope, element: element, show: false};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'backdrop', 'keyboard', 'html', 'container', 'animation'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['backdrop', 'keyboard', 'html', 'container'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\n        });\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content'], function (key) {\n          if (attr[key]) {\n            attr.$observe(key, function (newValue, oldValue) {\n              scope[key] = $sce.trustAsHtml(newValue);\n            });\n          }\n        });\n\n        // Support scope as an object\n        if (attr.bsAside) {\n          scope.$watch(attr.bsAside, function (newValue, oldValue) {\n            if (angular.isObject(newValue)) {\n              angular.extend(scope, newValue);\n            } else {\n              scope.content = newValue;\n            }\n          }, true);\n        }\n\n        // Initialize aside\n        var aside = $aside(options);\n\n        // Trigger\n        element.on(attr.trigger || 'click', aside.toggle);\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (aside) aside.destroy();\n          options = null;\n          aside = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: button/button.js\nangular.module('mgcrea.ngStrap.button', [])\n\n  .provider('$button', function () {\n\n    var defaults = this.defaults = {\n      activeClass: 'active',\n      toggleEvent: 'click'\n    };\n\n    this.$get = function () {\n      return {defaults: defaults};\n    };\n\n  })\n\n  .directive('bsCheckboxGroup', function () {\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      compile: function postLink(element, attr) {\n        element.attr('data-toggle', 'buttons');\n        element.removeAttr('ng-model');\n        var children = element[0].querySelectorAll('input[type=\"checkbox\"]');\n        angular.forEach(children, function (child) {\n          var childEl = angular.element(child);\n          childEl.attr('bs-checkbox', '');\n          childEl.attr('ng-model', attr.ngModel + '.' + childEl.attr('value'));\n        });\n      }\n\n    };\n\n  })\n\n  .directive('bsCheckbox', function ($button, $$rAF) {\n\n    var defaults = $button.defaults;\n    var constantValueRegExp = /^(true|false|\\d+)$/;\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        var options = defaults;\n\n        // Support label > input[type=\"checkbox\"]\n        var isInput = element[0].nodeName === 'INPUT';\n        var activeElement = isInput ? element.parent() : element;\n\n        var trueValue = angular.isDefined(attr.trueValue) ? attr.trueValue : true;\n        if (constantValueRegExp.test(attr.trueValue)) {\n          trueValue = scope.$eval(attr.trueValue);\n        }\n        var falseValue = angular.isDefined(attr.falseValue) ? attr.falseValue : false;\n        if (constantValueRegExp.test(attr.falseValue)) {\n          falseValue = scope.$eval(attr.falseValue);\n        }\n\n        // Parse exotic values\n        var hasExoticValues = typeof trueValue !== 'boolean' || typeof falseValue !== 'boolean';\n        if (hasExoticValues) {\n          controller.$parsers.push(function (viewValue) {\n            // console.warn('$parser', element.attr('ng-model'), 'viewValue', viewValue);\n            return viewValue ? trueValue : falseValue;\n          });\n          // modelValue -> $formatters -> viewValue\n          controller.$formatters.push(function (modelValue) {\n             // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n            return angular.equals(modelValue, trueValue);\n          });\n          // Fix rendering for exotic values\n          scope.$watch(attr.ngModel, function (newValue, oldValue) {\n            controller.$render();\n          });\n        }\n\n        // model -> view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          var isActive = angular.equals(controller.$modelValue, trueValue);\n          $$rAF(function () {\n            if (isInput) element[0].checked = isActive;\n            activeElement.toggleClass(options.activeClass, isActive);\n          });\n        };\n\n        // view -> model\n        element.bind(options.toggleEvent, function () {\n          scope.$apply(function () {\n            // console.warn('!click', element.attr('ng-model'), 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue, 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue);\n            if (!isInput) {\n              controller.$setViewValue(!activeElement.hasClass('active'));\n            }\n            if (!hasExoticValues) {\n              controller.$render();\n            }\n          });\n        });\n\n      }\n\n    };\n\n  })\n\n  .directive('bsRadioGroup', function () {\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      compile: function postLink(element, attr) {\n        element.attr('data-toggle', 'buttons');\n        element.removeAttr('ng-model');\n        var children = element[0].querySelectorAll('input[type=\"radio\"]');\n        angular.forEach(children, function (child) {\n          angular.element(child).attr('bs-radio', '');\n          angular.element(child).attr('ng-model', attr.ngModel);\n        });\n      }\n\n    };\n\n  })\n\n  .directive('bsRadio', function ($button, $$rAF) {\n\n    var defaults = $button.defaults;\n    var constantValueRegExp = /^(true|false|\\d+)$/;\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        var options = defaults;\n\n        // Support `label > input[type=\"radio\"]` markup\n        var isInput = element[0].nodeName === 'INPUT';\n        var activeElement = isInput ? element.parent() : element;\n\n        var value;\n        attr.$observe('value', function (v) {\n          value = constantValueRegExp.test(v) ? scope.$eval(v) : v;\n          controller.$render();\n        });\n\n        // model -> view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('value'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          var isActive = angular.equals(controller.$modelValue, value);\n          $$rAF(function () {\n            if (isInput) element[0].checked = isActive;\n            activeElement.toggleClass(options.activeClass, isActive);\n          });\n        };\n\n        // view -> model\n        element.bind(options.toggleEvent, function () {\n          scope.$apply(function () {\n            // console.warn('!click', element.attr('value'), 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue, 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue);\n            controller.$setViewValue(value);\n            controller.$render();\n          });\n        });\n\n      }\n\n    };\n\n  });\n\n// Source: alert/alert.js\n// @BUG: following snippet won't compile correctly\n// @TODO: submit issue to core\n// '<span ng-if=\"title\"><strong ng-bind=\"title\"></strong>&nbsp;</span><span ng-bind-html=\"content\"></span>' +\n\nangular.module('mgcrea.ngStrap.alert', ['mgcrea.ngStrap.modal'])\n\n  .provider('$alert', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'alert',\n      prefixEvent: 'alert',\n      placement: null,\n      templateUrl: 'alert/alert.tpl.html',\n      container: false,\n      element: null,\n      backdrop: false,\n      keyboard: true,\n      show: true,\n      // Specific options\n      duration: false,\n      type: false,\n      dismissable: true\n    };\n\n    this.$get = function ($modal, $timeout) {\n\n      function AlertFactory(config) {\n\n        var $alert = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $alert = $modal(options);\n\n        // Support scope as string options [/*title, content, */ type, dismissable]\n        $alert.$scope.dismissable = !!options.dismissable;\n        if (options.type) {\n          $alert.$scope.type = options.type;\n        }\n\n        // Support auto-close duration\n        var show = $alert.show;\n        if (options.duration) {\n          $alert.show = function () {\n            show();\n            $timeout(function () {\n              $alert.hide();\n            }, options.duration * 1000);\n          };\n        }\n\n        return $alert;\n\n      }\n\n      return AlertFactory;\n\n    };\n\n  })\n\n  .directive('bsAlert', function ($window, $sce, $alert) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n\n        // Directive options\n        var options = {scope: scope, element: element, show: false};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'keyboard', 'html', 'container', 'animation', 'duration', 'dismissable'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['keyboard', 'html', 'container', 'dismissable'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\n        });\n\n        // overwrite inherited title value when no value specified\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\n        if (!scope.hasOwnProperty('title')) {\n          scope.title = '';\n        }\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content', 'type'], function (key) {\n          if (attr[key]) {\n            attr.$observe(key, function (newValue, oldValue) {\n              scope[key] = $sce.trustAsHtml(newValue);\n            });\n          }\n        });\n\n        // Support scope as an object\n        if (attr.bsAlert) {\n          scope.$watch(attr.bsAlert, function (newValue, oldValue) {\n            if (angular.isObject(newValue)) {\n              angular.extend(scope, newValue);\n            } else {\n              scope.content = newValue;\n            }\n          }, true);\n        }\n\n        // Initialize alert\n        var alert = $alert(options);\n\n        // Trigger\n        element.on(attr.trigger || 'click', alert.toggle);\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (alert) alert.destroy();\n          options = null;\n          alert = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: affix/affix.js\nangular.module('mgcrea.ngStrap.affix', ['mgcrea.ngStrap.helpers.dimensions', 'mgcrea.ngStrap.helpers.debounce'])\n\n  .provider('$affix', function () {\n\n    var defaults = this.defaults = {\n      offsetTop: 'auto',\n      inlineStyles: true\n    };\n\n    this.$get = function ($window, debounce, dimensions) {\n\n      var bodyEl = angular.element($window.document.body);\n      var windowEl = angular.element($window);\n\n      function AffixFactory(element, config) {\n\n        var $affix = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        var targetEl = options.target;\n\n        // Initial private vars\n        var reset = 'affix affix-top affix-bottom';\n        var setWidth = false;\n        var initialAffixTop = 0;\n        var initialOffsetTop = 0;\n        var offsetTop = 0;\n        var offsetBottom = 0;\n        var affixed = null;\n        var unpin = null;\n\n        var parent = element.parent();\n        // Options: custom parent\n        if (options.offsetParent) {\n          if (options.offsetParent.match(/^\\d+$/)) {\n            for (var i = 0; i < (options.offsetParent * 1) - 1; i++) {\n              parent = parent.parent();\n            }\n          } else {\n            parent = angular.element(options.offsetParent);\n          }\n        }\n\n        $affix.init = function () {\n\n          this.$parseOffsets();\n          initialOffsetTop = dimensions.offset(element[0]).top + initialAffixTop;\n          setWidth = !element[0].style.width;\n\n          // Bind events\n          targetEl.on('scroll', this.checkPosition);\n          targetEl.on('click', this.checkPositionWithEventLoop);\n          windowEl.on('resize', this.$debouncedOnResize);\n\n          // Both of these checkPosition() calls are necessary for the case where\n          // the user hits refresh after scrolling to the bottom of the page.\n          this.checkPosition();\n          this.checkPositionWithEventLoop();\n\n        };\n\n        $affix.destroy = function () {\n\n          // Unbind events\n          targetEl.off('scroll', this.checkPosition);\n          targetEl.off('click', this.checkPositionWithEventLoop);\n          windowEl.off('resize', this.$debouncedOnResize);\n\n        };\n\n        $affix.checkPositionWithEventLoop = function () {\n\n          // IE 9 throws an error if we use 'this' instead of '$affix'\n          // in this setTimeout call\n          setTimeout($affix.checkPosition, 1);\n\n        };\n\n        $affix.checkPosition = function () {\n          // if (!this.$element.is(':visible')) return\n\n          var scrollTop = getScrollTop();\n          var position = dimensions.offset(element[0]);\n          var elementHeight = dimensions.height(element[0]);\n\n          // Get required affix class according to position\n          var affix = getRequiredAffixClass(unpin, position, elementHeight);\n\n          // Did affix status changed this last check?\n          if (affixed === affix) return;\n          affixed = affix;\n\n          if (affix === 'top') {\n            unpin = null;\n            if (setWidth) {\n              element.css('width', '');\n            }\n            if (options.inlineStyles) {\n              element.css('position', (options.offsetParent) ? '' : 'relative');\n              element.css('top', '');\n            }\n          } else if (affix === 'bottom') {\n            if (options.offsetUnpin) {\n              unpin = -(options.offsetUnpin * 1);\n            } else {\n              // Calculate unpin threshold when affixed to bottom.\n              // Hopefully the browser scrolls pixel by pixel.\n              unpin = position.top - scrollTop;\n            }\n            if (setWidth) {\n              element.css('width', '');\n            }\n            if (options.inlineStyles) {\n              element.css('position', (options.offsetParent) ? '' : 'relative');\n              element.css('top', (options.offsetParent) ? '' : ((bodyEl[0].offsetHeight - offsetBottom - elementHeight - initialOffsetTop) + 'px'));\n            }\n          } else { // affix === 'middle'\n            unpin = null;\n            if (setWidth) {\n              element.css('width', element[0].offsetWidth + 'px');\n            }\n            if (options.inlineStyles) {\n              element.css('position', 'fixed');\n              element.css('top', initialAffixTop + 'px');\n            }\n          }\n\n          // Add proper affix class\n          element.removeClass(reset).addClass('affix' + ((affix !== 'middle') ? '-' + affix : ''));\n\n        };\n\n        $affix.$onResize = function () {\n          $affix.$parseOffsets();\n          $affix.checkPosition();\n        };\n        $affix.$debouncedOnResize = debounce($affix.$onResize, 50);\n\n        $affix.$parseOffsets = function () {\n          var initialPosition = element.css('position');\n          // Reset position to calculate correct offsetTop\n          if (options.inlineStyles) {\n            element.css('position', (options.offsetParent) ? '' : 'relative');\n          }\n\n          if (options.offsetTop) {\n            if (options.offsetTop === 'auto') {\n              options.offsetTop = '+0';\n            }\n            if (options.offsetTop.match(/^[-+]\\d+$/)) {\n              initialAffixTop = - options.offsetTop * 1;\n              if (options.offsetParent) {\n                offsetTop = dimensions.offset(parent[0]).top + (options.offsetTop * 1);\n              } else {\n                offsetTop = dimensions.offset(element[0]).top - dimensions.css(element[0], 'marginTop', true) + (options.offsetTop * 1);\n              }\n            } else {\n              offsetTop = options.offsetTop * 1;\n            }\n          }\n\n          if (options.offsetBottom) {\n            if (options.offsetParent && options.offsetBottom.match(/^[-+]\\d+$/)) {\n              // add 1 pixel due to rounding problems...\n              offsetBottom = getScrollHeight() - (dimensions.offset(parent[0]).top + dimensions.height(parent[0])) + (options.offsetBottom * 1) + 1;\n            } else {\n              offsetBottom = options.offsetBottom * 1;\n            }\n          }\n\n          // Bring back the element's position after calculations\n          if (options.inlineStyles) {\n            element.css('position', initialPosition);\n          }\n        };\n\n        // Private methods\n\n        function getRequiredAffixClass(_unpin, position, elementHeight) {\n          var scrollTop = getScrollTop();\n          var scrollHeight = getScrollHeight();\n\n          if (scrollTop <= offsetTop) {\n            return 'top';\n          } else if (_unpin !== null && (scrollTop + _unpin <= position.top)) {\n            return 'middle';\n          } else if (offsetBottom !== null && (position.top + elementHeight + initialAffixTop >= scrollHeight - offsetBottom)) {\n            return 'bottom';\n          }\n          return 'middle';\n        }\n\n        function getScrollTop() {\n          return targetEl[0] === $window ? $window.pageYOffset : targetEl[0].scrollTop;\n        }\n\n        function getScrollHeight() {\n          return targetEl[0] === $window ? $window.document.body.scrollHeight : targetEl[0].scrollHeight;\n        }\n\n        $affix.init();\n        return $affix;\n\n      }\n\n      return AffixFactory;\n\n    };\n\n  })\n\n  .directive('bsAffix', function ($affix, $window) {\n\n    return {\n      restrict: 'EAC',\n      require: '^?bsAffixTarget',\n      link: function postLink(scope, element, attr, affixTarget) {\n\n        var options = {scope: scope, target: affixTarget ? affixTarget.$element : angular.element($window)};\n        angular.forEach(['offsetTop', 'offsetBottom', 'offsetParent', 'offsetUnpin', 'inlineStyles'], function (key) {\n          if (angular.isDefined(attr[key])) {\n            var option = attr[key];\n            if (/true/i.test(option)) option = true;\n            if (/false/i.test(option)) option = false;\n            options[key] = option;\n          }\n        });\n\n        var affix = $affix(element, options);\n        scope.$on('$destroy', function () {\n          if (affix) affix.destroy();\n          options = null;\n          affix = null;\n        });\n\n      }\n    };\n\n  })\n\n  .directive('bsAffixTarget', function () {\n    return {\n      controller: function ($element) {\n        this.$element = $element;\n      }\n    };\n  });\n\n// Source: module.js\nangular.module('mgcrea.ngStrap', [\n  'mgcrea.ngStrap.modal',\n  'mgcrea.ngStrap.aside',\n  'mgcrea.ngStrap.alert',\n  'mgcrea.ngStrap.button',\n  'mgcrea.ngStrap.select',\n  'mgcrea.ngStrap.datepicker',\n  'mgcrea.ngStrap.timepicker',\n  'mgcrea.ngStrap.navbar',\n  'mgcrea.ngStrap.tooltip',\n  'mgcrea.ngStrap.popover',\n  'mgcrea.ngStrap.dropdown',\n  'mgcrea.ngStrap.typeahead',\n  'mgcrea.ngStrap.scrollspy',\n  'mgcrea.ngStrap.affix',\n  'mgcrea.ngStrap.tab',\n  'mgcrea.ngStrap.collapse'\n]);\n\n})(window, document);\n","'use strict';\n\nangular.module('mgcrea.ngStrap.tooltip', ['mgcrea.ngStrap.core', 'mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$tooltip', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      customClass: '',\n      prefixClass: 'tooltip',\n      prefixEvent: 'tooltip',\n      container: false,\n      target: false,\n      placement: 'top',\n      templateUrl: 'tooltip/tooltip.tpl.html',\n      template: '',\n      titleTemplate: false,\n      trigger: 'hover focus',\n      keyboard: false,\n      html: false,\n      show: false,\n      title: '',\n      type: '',\n      delay: 0,\n      autoClose: false,\n      bsEnabled: true,\n      viewport: {\n        selector: 'body',\n        padding: 0\n      }\n    };\n\n    this.$get = function ($window, $rootScope, $bsCompiler, $q, $templateCache, $http, $animate, $sce, dimensions, $$rAF, $timeout) {\n\n      var isTouch = 'createTouch' in $window.document;\n      var $body = angular.element($window.document);\n\n      function TooltipFactory(element, config) {\n\n        var $tooltip = {};\n\n        // Common vars\n        var options = $tooltip.$options = angular.extend({}, defaults, config);\n        var promise = $tooltip.$promise = $bsCompiler.compile(options);\n        var scope = $tooltip.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n\n        var nodeName = element[0].nodeName.toLowerCase();\n        if (options.delay && angular.isString(options.delay)) {\n          var split = options.delay.split(',').map(parseFloat);\n          options.delay = split.length > 1 ? {show: split[0], hide: split[1]} : split[0];\n        }\n\n        // Store $id to identify the triggering element in events\n        // give priority to options.id, otherwise, try to use\n        // element id if defined\n        $tooltip.$id = options.id || element.attr('id') || '';\n\n        // Support scope as string options\n        if (options.title) {\n          scope.title = $sce.trustAsHtml(options.title);\n        }\n\n        // Provide scope helpers\n        scope.$setEnabled = function (isEnabled) {\n          scope.$$postDigest(function () {\n            $tooltip.setEnabled(isEnabled);\n          });\n        };\n        scope.$hide = function () {\n          scope.$$postDigest(function () {\n            $tooltip.hide();\n          });\n        };\n        scope.$show = function () {\n          scope.$$postDigest(function () {\n            $tooltip.show();\n          });\n        };\n        scope.$toggle = function () {\n          scope.$$postDigest(function () {\n            $tooltip.toggle();\n          });\n        };\n        // Publish isShown as a protected var on scope\n        $tooltip.$isShown = scope.$isShown = false;\n\n        // Private vars\n        var timeout;\n        var hoverState;\n\n        // Fetch, compile then initialize tooltip\n        var compileData;\n        var tipElement;\n        var tipContainer;\n        var tipScope;\n        promise.then(function (data) {\n          compileData = data;\n          $tooltip.init();\n        });\n\n        $tooltip.init = function () {\n\n          // Options: delay\n          if (options.delay && angular.isNumber(options.delay)) {\n            options.delay = {\n              show: options.delay,\n              hide: options.delay\n            };\n          }\n\n          // Replace trigger on touch devices ?\n          // if(isTouch && options.trigger === defaults.trigger) {\n          //   options.trigger.replace(/hover/g, 'click');\n          // }\n\n          // Options : container\n          if (options.container === 'self') {\n            tipContainer = element;\n          } else if (angular.isElement(options.container)) {\n            tipContainer = options.container;\n          } else if (options.container) {\n            tipContainer = findElement(options.container);\n          }\n\n          // Options: trigger\n          bindTriggerEvents();\n\n          // Options: target\n          if (options.target) {\n            options.target = angular.isElement(options.target) ? options.target : findElement(options.target);\n          }\n\n          // Options: show\n          if (options.show) {\n            scope.$$postDigest(function () {\n              if (options.trigger === 'focus') {\n                element[0].focus();\n              } else {\n                $tooltip.show();\n              }\n            });\n          }\n\n        };\n\n        $tooltip.destroy = function () {\n\n          // Unbind events\n          unbindTriggerEvents();\n\n          // Remove element\n          destroyTipElement();\n\n          // Destroy scope\n          scope.$destroy();\n\n        };\n\n        $tooltip.enter = function () {\n\n          clearTimeout(timeout);\n          hoverState = 'in';\n          if (!options.delay || !options.delay.show) {\n            return $tooltip.show();\n          }\n\n          timeout = setTimeout(function () {\n            if (hoverState === 'in') $tooltip.show();\n          }, options.delay.show);\n\n        };\n\n        $tooltip.show = function () {\n          if (!options.bsEnabled || $tooltip.$isShown) return;\n\n          scope.$emit(options.prefixEvent + '.show.before', $tooltip);\n          var parent;\n          var after;\n          if (options.container) {\n            parent = tipContainer;\n            if (tipContainer[0].lastChild) {\n              after = angular.element(tipContainer[0].lastChild);\n            } else {\n              after = null;\n            }\n          } else {\n            parent = null;\n            after = element;\n          }\n\n\n          // Hide any existing tipElement\n          if (tipElement) destroyTipElement();\n          // Fetch a cloned element linked from template\n          tipScope = $tooltip.$scope.$new();\n          tipElement = $tooltip.$element = compileData.link(tipScope, function (clonedElement, scope) {});\n\n          // Set the initial positioning.  Make the tooltip invisible\n          // so IE doesn't try to focus on it off screen.\n          tipElement.css({top: '-9999px', left: '-9999px', right: 'auto', display: 'block', visibility: 'hidden'});\n\n          // Options: animation\n          if (options.animation) tipElement.addClass(options.animation);\n          // Options: type\n          if (options.type) tipElement.addClass(options.prefixClass + '-' + options.type);\n          // Options: custom classes\n          if (options.customClass) tipElement.addClass(options.customClass);\n\n          // Append the element, without any animations.  If we append\n          // using $animate.enter, some of the animations cause the placement\n          // to be off due to the transforms.\n          if (after) {\n            after.after(tipElement);\n          } else {\n            parent.prepend(tipElement);\n          }\n\n          $tooltip.$isShown = scope.$isShown = true;\n          safeDigest(scope);\n\n          // Now, apply placement\n          $tooltip.$applyPlacement();\n\n          // Once placed, animate it.\n          // Support v1.2+ $animate\n          // https://github.com/angular/angular.js/issues/11713\n          if (angular.version.minor <= 2) {\n            $animate.enter(tipElement, parent, after, enterAnimateCallback);\n          } else {\n            $animate.enter(tipElement, parent, after).then(enterAnimateCallback);\n          }\n          safeDigest(scope);\n\n          $$rAF(function () {\n            // Once the tooltip is placed and the animation starts, make the tooltip visible\n            if (tipElement) tipElement.css({visibility: 'visible'});\n\n            // Bind events\n            if (options.keyboard) {\n              if (options.trigger !== 'focus') {\n                $tooltip.focus();\n              }\n              bindKeyboardEvents();\n            }\n          });\n\n          if (options.autoClose) {\n            bindAutoCloseEvents();\n          }\n\n        };\n\n        function enterAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.show', $tooltip);\n        }\n\n        $tooltip.leave = function () {\n\n          clearTimeout(timeout);\n          hoverState = 'out';\n          if (!options.delay || !options.delay.hide) {\n            return $tooltip.hide();\n          }\n          timeout = setTimeout(function () {\n            if (hoverState === 'out') {\n              $tooltip.hide();\n            }\n          }, options.delay.hide);\n\n        };\n\n        var _blur;\n        var _tipToHide;\n        $tooltip.hide = function (blur) {\n\n          if (!$tooltip.$isShown) return;\n          scope.$emit(options.prefixEvent + '.hide.before', $tooltip);\n\n          // store blur value for leaveAnimateCallback to use\n          _blur = blur;\n\n          // store current tipElement reference to use\n          // in leaveAnimateCallback\n          _tipToHide = tipElement;\n\n          // Support v1.2+ $animate\n          // https://github.com/angular/angular.js/issues/11713\n          if (angular.version.minor <= 2) {\n            $animate.leave(tipElement, leaveAnimateCallback);\n          } else {\n            $animate.leave(tipElement).then(leaveAnimateCallback);\n          }\n\n          $tooltip.$isShown = scope.$isShown = false;\n          safeDigest(scope);\n\n          // Unbind events\n          if (options.keyboard && tipElement !== null) {\n            unbindKeyboardEvents();\n          }\n\n          if (options.autoClose && tipElement !== null) {\n            unbindAutoCloseEvents();\n          }\n        };\n\n        function leaveAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.hide', $tooltip);\n\n          // check if current tipElement still references\n          // the same element when hide was called\n          if (tipElement === _tipToHide) {\n            // Allow to blur the input when hidden, like when pressing enter key\n            if (_blur && options.trigger === 'focus') {\n              return element[0].blur();\n            }\n\n            // clean up child scopes\n            destroyTipElement();\n          }\n        }\n\n        $tooltip.toggle = function (evt) {\n          if (evt) { evt.preventDefault(); }\n          if ($tooltip.$isShown) {\n            $tooltip.leave();\n          } else {\n            $tooltip.enter();\n          }\n        };\n\n        $tooltip.focus = function () {\n          tipElement[0].focus();\n        };\n\n        $tooltip.setEnabled = function (isEnabled) {\n          options.bsEnabled = isEnabled;\n        };\n\n        $tooltip.setViewport = function (viewport) {\n          options.viewport = viewport;\n        };\n\n        // Protected methods\n\n        $tooltip.$applyPlacement = function () {\n          if (!tipElement) return;\n\n          // Determine if we're doing an auto or normal placement\n          var placement = options.placement;\n          var autoToken = /\\s?auto?\\s?/i;\n          var autoPlace = autoToken.test(placement);\n\n          if (autoPlace) {\n            placement = placement.replace(autoToken, '') || defaults.placement;\n          }\n\n          // Need to add the position class before we get\n          // the offsets\n          tipElement.addClass(options.placement);\n\n          // Get the position of the target element\n          // and the height and width of the tooltip so we can center it.\n          var elementPosition = getPosition();\n          var tipWidth = tipElement.prop('offsetWidth');\n          var tipHeight = tipElement.prop('offsetHeight');\n\n          // Refresh viewport position\n          $tooltip.$viewport = options.viewport && findElement(options.viewport.selector || options.viewport);\n\n          // If we're auto placing, we need to check the positioning\n          if (autoPlace) {\n            var originalPlacement = placement;\n            var viewportPosition = getPosition($tooltip.$viewport);\n\n            if (/bottom/.test(originalPlacement) && elementPosition.bottom + tipHeight > viewportPosition.bottom) {\n              placement = originalPlacement.replace('bottom', 'top');\n            } else if (/top/.test(originalPlacement) && elementPosition.top - tipHeight < viewportPosition.top) {\n              placement = originalPlacement.replace('top', 'bottom');\n            }\n\n            if (/left/.test(originalPlacement) && elementPosition.left - tipWidth < viewportPosition.left) {\n              placement = placement.replace('left', 'right');\n            } else if (/right/.test(originalPlacement) && elementPosition.right + tipWidth > viewportPosition.width) {\n              placement = placement.replace('right', 'left');\n            }\n\n            tipElement.removeClass(originalPlacement).addClass(placement);\n          }\n\n          // Get the tooltip's top and left coordinates to center it with this directive.\n          var tipPosition = getCalculatedOffset(placement, elementPosition, tipWidth, tipHeight);\n          applyPlacement(tipPosition, placement);\n        };\n\n        $tooltip.$onKeyUp = function (evt) {\n          if (evt.which === 27 && $tooltip.$isShown) {\n            $tooltip.hide();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusKeyUp = function (evt) {\n          if (evt.which === 27) {\n            element[0].blur();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusElementMouseDown = function (evt) {\n          evt.preventDefault();\n          evt.stopPropagation();\n          // Some browsers do not auto-focus buttons (eg. Safari)\n          if ($tooltip.$isShown) {\n            element[0].blur();\n          } else {\n            element[0].focus();\n          }\n        };\n\n        // bind/unbind events\n        function bindTriggerEvents() {\n          var triggers = options.trigger.split(' ');\n          angular.forEach(triggers, function (trigger) {\n            if (trigger === 'click' || trigger === 'contextmenu') {\n              element.on(trigger, $tooltip.toggle);\n            } else if (trigger !== 'manual') {\n              element.on(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.on(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              if (nodeName === 'button' && trigger !== 'hover') {\n                element.on(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n              }\n            }\n          });\n        }\n\n        function unbindTriggerEvents() {\n          var triggers = options.trigger.split(' ');\n          for (var i = triggers.length; i--;) {\n            var trigger = triggers[i];\n            if (trigger === 'click' || trigger === 'contextmenu') {\n              element.off(trigger, $tooltip.toggle);\n            } else if (trigger !== 'manual') {\n              element.off(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.off(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              if (nodeName === 'button' && trigger !== 'hover') {\n                element.off(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n              }\n            }\n          }\n        }\n\n        function bindKeyboardEvents() {\n          if (options.trigger !== 'focus') {\n            tipElement.on('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.on('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        function unbindKeyboardEvents() {\n          if (options.trigger !== 'focus') {\n            tipElement.off('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.off('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        var _autoCloseEventsBinded = false;\n        function bindAutoCloseEvents() {\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function () {\n            // Stop propagation when clicking inside tooltip\n            tipElement.on('click', stopEventPropagation);\n\n            // Hide when clicking outside tooltip\n            $body.on('click', $tooltip.hide);\n\n            _autoCloseEventsBinded = true;\n          }, 0, false);\n        }\n\n        function unbindAutoCloseEvents() {\n          if (_autoCloseEventsBinded) {\n            tipElement.off('click', stopEventPropagation);\n            $body.off('click', $tooltip.hide);\n            _autoCloseEventsBinded = false;\n          }\n        }\n\n        function stopEventPropagation(event) {\n          event.stopPropagation();\n        }\n\n        // Private methods\n\n        function getPosition($element) {\n          $element = $element || (options.target || element);\n\n          var el = $element[0];\n          var isBody = el.tagName === 'BODY';\n\n          var elRect = el.getBoundingClientRect();\n          var rect = {};\n\n          // IE8 has issues with angular.extend and using elRect directly.\n          // By coping the values of elRect into a new object, we can continue to use extend\n          /* eslint-disable guard-for-in */\n          for (var p in elRect) {\n            // DO NOT use hasOwnProperty when inspecting the return of getBoundingClientRect.\n            rect[p] = elRect[p];\n          }\n          /* eslint-enable guard-for-in */\n\n          if (rect.width === null) {\n            // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093\n            rect = angular.extend({}, rect, {width: elRect.right - elRect.left, height: elRect.bottom - elRect.top});\n          }\n          var elOffset = isBody ? {top: 0, left: 0} : dimensions.offset(el);\n          var scroll = {scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.prop('scrollTop') || 0};\n          var outerDims = isBody ? {width: document.documentElement.clientWidth, height: $window.innerHeight} : null;\n\n          return angular.extend({}, rect, scroll, outerDims, elOffset);\n        }\n\n        function getCalculatedOffset(placement, position, actualWidth, actualHeight) {\n          var offset;\n          var split = placement.split('-');\n\n          switch (split[0]) {\n            case 'right':\n              offset = {\n                top: position.top + position.height / 2 - actualHeight / 2,\n                left: position.left + position.width\n              };\n              break;\n            case 'bottom':\n              offset = {\n                top: position.top + position.height,\n                left: position.left + position.width / 2 - actualWidth / 2\n              };\n              break;\n            case 'left':\n              offset = {\n                top: position.top + position.height / 2 - actualHeight / 2,\n                left: position.left - actualWidth\n              };\n              break;\n            default:\n              offset = {\n                top: position.top - actualHeight,\n                left: position.left + position.width / 2 - actualWidth / 2\n              };\n              break;\n          }\n\n          if (!split[1]) {\n            return offset;\n          }\n\n          // Add support for corners @todo css\n          if (split[0] === 'top' || split[0] === 'bottom') {\n            switch (split[1]) {\n              case 'left':\n                offset.left = position.left;\n                break;\n              case 'right':\n                offset.left = position.left + position.width - actualWidth;\n                break;\n              default:\n                break;\n            }\n          } else if (split[0] === 'left' || split[0] === 'right') {\n            switch (split[1]) {\n              case 'top':\n                offset.top = position.top - actualHeight + position.height;\n                break;\n              case 'bottom':\n                offset.top = position.top;\n                break;\n              default:\n                break;\n            }\n          }\n\n          return offset;\n        }\n\n        function applyPlacement(offset, placement) {\n          var tip = tipElement[0];\n          var width = tip.offsetWidth;\n          var height = tip.offsetHeight;\n\n          // manually read margins because getBoundingClientRect includes difference\n          var marginTop = parseInt(dimensions.css(tip, 'margin-top'), 10);\n          var marginLeft = parseInt(dimensions.css(tip, 'margin-left'), 10);\n\n          // we must check for NaN for ie 8/9\n          if (isNaN(marginTop)) marginTop = 0;\n          if (isNaN(marginLeft)) marginLeft = 0;\n\n          offset.top = offset.top + marginTop;\n          offset.left = offset.left + marginLeft;\n\n          // dimensions setOffset doesn't round pixel values\n          // so we use setOffset directly with our own function\n          dimensions.setOffset(tip, angular.extend({\n            using: function (props) {\n              tipElement.css({\n                top: Math.round(props.top) + 'px',\n                left: Math.round(props.left) + 'px',\n                right: ''\n              });\n            }\n          }, offset), 0);\n\n          // check to see if placing tip in new offset caused the tip to resize itself\n          var actualWidth = tip.offsetWidth;\n          var actualHeight = tip.offsetHeight;\n\n          if (placement === 'top' && actualHeight !== height) {\n            offset.top = offset.top + height - actualHeight;\n          }\n\n          // If it's an exotic placement, exit now instead of\n          // applying a delta and changing the arrow\n          if (/top-left|top-right|bottom-left|bottom-right/.test(placement)) return;\n\n          var delta = getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);\n\n          if (delta.left) {\n            offset.left += delta.left;\n          } else {\n            offset.top += delta.top;\n          }\n\n          dimensions.setOffset(tip, offset);\n\n          if (/top|right|bottom|left/.test(placement)) {\n            var isVertical = /top|bottom/.test(placement);\n            var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight;\n            var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';\n\n            replaceArrow(arrowDelta, tip[arrowOffsetPosition], isVertical);\n          }\n        }\n\n        // @source https://github.com/twbs/bootstrap/blob/v3.3.5/js/tooltip.js#L380\n        function getViewportAdjustedDelta(placement, position, actualWidth, actualHeight) {\n          var delta = {top: 0, left: 0};\n          if (!$tooltip.$viewport) return delta;\n\n          var viewportPadding = options.viewport && options.viewport.padding || 0;\n          var viewportDimensions = getPosition($tooltip.$viewport);\n\n          if (/right|left/.test(placement)) {\n            var topEdgeOffset = position.top - viewportPadding - viewportDimensions.scroll;\n            var bottomEdgeOffset = position.top + viewportPadding - viewportDimensions.scroll + actualHeight;\n            if (topEdgeOffset < viewportDimensions.top) { // top overflow\n              delta.top = viewportDimensions.top - topEdgeOffset;\n            } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow\n              delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;\n            }\n          } else {\n            var leftEdgeOffset = position.left - viewportPadding;\n            var rightEdgeOffset = position.left + viewportPadding + actualWidth;\n            if (leftEdgeOffset < viewportDimensions.left) { // left overflow\n              delta.left = viewportDimensions.left - leftEdgeOffset;\n            } else if (rightEdgeOffset > viewportDimensions.right) { // right overflow\n              delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;\n            }\n          }\n\n          return delta;\n        }\n\n        function replaceArrow(delta, dimension, isHorizontal) {\n          var $arrow = findElement('.tooltip-arrow, .arrow', tipElement[0]);\n\n          $arrow.css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')\n                .css(isHorizontal ? 'top' : 'left', '');\n        }\n\n        function destroyTipElement() {\n          // Cancel pending callbacks\n          clearTimeout(timeout);\n\n          if ($tooltip.$isShown && tipElement !== null) {\n            if (options.autoClose) {\n              unbindAutoCloseEvents();\n            }\n\n            if (options.keyboard) {\n              unbindKeyboardEvents();\n            }\n          }\n\n          if (tipScope) {\n            tipScope.$destroy();\n            tipScope = null;\n          }\n\n          if (tipElement) {\n            tipElement.remove();\n            tipElement = $tooltip.$element = null;\n          }\n        }\n\n        return $tooltip;\n\n      }\n\n      // Helper functions\n\n      function safeDigest(scope) {\n        /* eslint-disable no-unused-expressions */\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n        /* eslint-enable no-unused-expressions */\n      }\n\n      function findElement(query, element) {\n        return angular.element((element || document).querySelectorAll(query));\n      }\n\n      return TooltipFactory;\n\n    };\n\n  })\n\n  .directive('bsTooltip', function ($window, $location, $sce, $tooltip, $$rAF) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n\n        var tooltip;\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'titleTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'backdropAnimation', 'type', 'customClass', 'id'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\n            options[key] = false;\n          }\n        });\n\n        // should not parse target attribute (anchor tag), only data-target #1454\n        var dataTarget = element.attr('data-target');\n        if (angular.isDefined(dataTarget)) {\n          if (falseValueRegExp.test(dataTarget)) {\n            options.target = false;\n          } else {\n            options.target = dataTarget;\n          }\n        }\n\n        // overwrite inherited title value when no value specified\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\n        if (!scope.hasOwnProperty('title')) {\n          scope.title = '';\n        }\n\n        // Observe scope attributes for change\n        attr.$observe('title', function (newValue) {\n          if (angular.isDefined(newValue) || !scope.hasOwnProperty('title')) {\n            var oldValue = scope.title;\n            scope.title = $sce.trustAsHtml(newValue);\n            if (angular.isDefined(oldValue)) {\n              $$rAF(function () {\n                if (tooltip) tooltip.$applyPlacement();\n              });\n            }\n          }\n        });\n\n        attr.$observe('disabled', function (newValue) {\n          if (newValue && tooltip.$isShown) {\n            tooltip.hide();\n          }\n        });\n\n        // Support scope as an object\n        if (attr.bsTooltip) {\n          scope.$watch(attr.bsTooltip, function (newValue, oldValue) {\n            if (angular.isObject(newValue)) {\n              angular.extend(scope, newValue);\n            } else {\n              scope.title = newValue;\n            }\n            if (angular.isDefined(oldValue)) {\n              $$rAF(function () {\n                if (tooltip) tooltip.$applyPlacement();\n              });\n            }\n          }, true);\n        }\n\n        // Visibility binding support\n        if (attr.bsShow) {\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\n            if (!tooltip || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(tooltip),?/i);\n            if (newValue === true) {\n              tooltip.show();\n            } else {\n              tooltip.hide();\n            }\n          });\n        }\n\n        // Enabled binding support\n        if (attr.bsEnabled) {\n          scope.$watch(attr.bsEnabled, function (newValue, oldValue) {\n            // console.warn('scope.$watch(%s)', attr.bsEnabled, newValue, oldValue);\n            if (!tooltip || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(tooltip),?/i);\n            if (newValue === false) {\n              tooltip.setEnabled(false);\n            } else {\n              tooltip.setEnabled(true);\n            }\n          });\n        }\n\n        // Viewport support\n        if (attr.viewport) {\n          scope.$watch(attr.viewport, function (newValue) {\n            if (!tooltip || !angular.isDefined(newValue)) return;\n            tooltip.setViewport(newValue);\n          });\n        }\n\n        // Initialize popover\n        tooltip = $tooltip(element, options);\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (tooltip) tooltip.destroy();\n          options = null;\n          tooltip = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\n// NOTICE: This file was forked from the angular-material project (github.com/angular/material)\n// MIT Licensed - Copyright (c) 2014-2015 Google, Inc. http://angularjs.org\n\nangular.module('mgcrea.ngStrap.core', [])\n  .service('$bsCompiler', bsCompilerService);\n\nfunction bsCompilerService($q, $http, $injector, $compile, $controller, $templateCache) {\n\n  /*\n   * @ngdoc service\n   * @name $bsCompiler\n   * @module material.core\n   * @description\n   * The $bsCompiler service is an abstraction of angular's compiler, that allows the developer\n   * to easily compile an element with a templateUrl, controller, and locals.\n   *\n   * @usage\n   * <hljs lang=\"js\">\n   * $bsCompiler.compile({\n   *   templateUrl: 'modal.html',\n   *   controller: 'ModalCtrl',\n   *   locals: {\n   *     modal: myModalInstance;\n   *   }\n   * }).then(function(compileData) {\n   *   compileData.element; // modal.html's template in an element\n   *   compileData.link(myScope); //attach controller & scope to element\n   * });\n   * </hljs>\n   */\n\n   /*\n    * @ngdoc method\n    * @name $bsCompiler#compile\n    * @description A helper to compile an HTML template/templateUrl with a given controller,\n    * locals, and scope.\n    * @param {object} options An options object, with the following properties:\n    *\n    *    - `controller` - `{(string=|function()=}` Controller fn that should be associated with\n    *      newly created scope or the name of a registered controller if passed as a string.\n    *    - `controllerAs` - `{string=}` A controller alias name. If present the controller will be\n    *      published to scope under the `controllerAs` name.\n    *    - `template` - `{string=}` An html template as a string.\n    *    - `templateUrl` - `{string=}` A path to an html template.\n    *    - `transformTemplate` - `{function(template)=}` A function which transforms the template after\n    *      it is loaded. It will be given the template string as a parameter, and should\n    *      return a a new string representing the transformed template.\n    *    - `resolve` - `{Object.<string, function>=}` - An optional map of dependencies which should\n    *      be injected into the controller. If any of these dependencies are promises, the compiler\n    *      will wait for them all to be resolved, or if one is rejected before the controller is\n    *      instantiated `compile()` will fail..\n    *      * `key` - `{string}`: a name of a dependency to be injected into the controller.\n    *      * `factory` - `{string|function}`: If `string` then it is an alias for a service.\n    *        Otherwise if function, then it is injected and the return value is treated as the\n    *        dependency. If the result is a promise, it is resolved before its value is\n    *        injected into the controller.\n    *\n    * @returns {object=} promise A promise, which will be resolved with a `compileData` object.\n    * `compileData` has the following properties:\n    *\n    *   - `element` - `{element}`: an uncompiled element matching the provided template.\n    *   - `link` - `{function(scope)}`: A link function, which, when called, will compile\n    *     the element and instantiate the provided controller (if given).\n    *   - `locals` - `{object}`: The locals which will be passed into the controller once `link` is\n    *     called. If `bindToController` is true, they will be coppied to the ctrl instead\n    *   - `bindToController` - `bool`: bind the locals to the controller, instead of passing them in.\n    */\n  this.compile = function (options) {\n\n    if (options.template && /\\.html$/.test(options.template)) {\n      console.warn('Deprecated use of `template` option to pass a file. Please use the `templateUrl` option instead.');\n      options.templateUrl = options.template;\n      options.template = '';\n    }\n\n    var templateUrl = options.templateUrl;\n    var template = options.template || '';\n    var controller = options.controller;\n    var controllerAs = options.controllerAs;\n    var resolve = angular.copy(options.resolve || {});\n    var locals = angular.copy(options.locals || {});\n    var transformTemplate = options.transformTemplate || angular.identity;\n    var bindToController = options.bindToController;\n\n    // Take resolve values and invoke them.\n    // Resolves can either be a string (value: 'MyRegisteredAngularConst'),\n    // or an invokable 'factory' of sorts: (value: function ValueGetter($dependency) {})\n    angular.forEach(resolve, function (value, key) {\n      if (angular.isString(value)) {\n        resolve[key] = $injector.get(value);\n      } else {\n        resolve[key] = $injector.invoke(value);\n      }\n    });\n    // Add the locals, which are just straight values to inject\n    // eg locals: { three: 3 }, will inject three into the controller\n    angular.extend(resolve, locals);\n\n    if (template) {\n      resolve.$template = $q.when(template);\n    } else if (templateUrl) {\n      resolve.$template = fetchTemplate(templateUrl);\n    } else {\n      throw new Error('Missing `template` / `templateUrl` option.');\n    }\n\n    if (options.titleTemplate) {\n      resolve.$template = $q.all([resolve.$template, fetchTemplate(options.titleTemplate)])\n        .then(function (templates) {\n          var templateEl = angular.element(templates[0]);\n          findElement('[ng-bind=\"title\"]', templateEl[0])\n            .removeAttr('ng-bind')\n            .html(templates[1]);\n          return templateEl[0].outerHTML;\n        });\n    }\n\n    if (options.contentTemplate) {\n      // TODO(mgcrea): deprecate?\n      resolve.$template = $q.all([resolve.$template, fetchTemplate(options.contentTemplate)])\n        .then(function (templates) {\n          var templateEl = angular.element(templates[0]);\n          var contentEl = findElement('[ng-bind=\"content\"]', templateEl[0])\n            .removeAttr('ng-bind')\n            .html(templates[1]);\n          // Drop the default footer as you probably don't want it if you use a custom contentTemplate\n          if (!options.templateUrl) contentEl.next().remove();\n          return templateEl[0].outerHTML;\n        });\n    }\n\n    // Wait for all the resolves to finish if they are promises\n    return $q.all(resolve).then(function (locals) {\n\n      var template = transformTemplate(locals.$template);\n      if (options.html) {\n        template = template.replace(/ng-bind=\"/ig, 'ng-bind-html=\"');\n      }\n      // var element = options.element || angular.element('<div>').html(template.trim()).contents();\n      var element = angular.element('<div>').html(template.trim()).contents();\n      var linkFn = $compile(element);\n\n      // Return a linking function that can be used later when the element is ready\n      return {\n        locals: locals,\n        element: element,\n        link: function link(scope) {\n          locals.$scope = scope;\n\n          // Instantiate controller if it exists, because we have scope\n          if (controller) {\n            var invokeCtrl = $controller(controller, locals, true);\n            if (bindToController) {\n              angular.extend(invokeCtrl.instance, locals);\n            }\n            // Support angular@~1.2 invokeCtrl\n            var ctrl = angular.isObject(invokeCtrl) ? invokeCtrl : invokeCtrl();\n            // See angular-route source for this logic\n            element.data('$ngControllerController', ctrl);\n            element.children().data('$ngControllerController', ctrl);\n\n            if (controllerAs) {\n              scope[controllerAs] = ctrl;\n            }\n          }\n\n          return linkFn.apply(null, arguments);\n        }\n      };\n    });\n\n  };\n\n  function findElement(query, element) {\n    return angular.element((element || document).querySelectorAll(query));\n  }\n\n  var fetchPromises = {};\n  function fetchTemplate(template) {\n    if (fetchPromises[template]) return fetchPromises[template];\n    return (fetchPromises[template] = $http.get(template, {cache: $templateCache})\n      .then(function (res) {\n        return res.data;\n      }));\n  }\n\n}\n","'use strict';\n\nangular.module('mgcrea.ngStrap.collapse', [])\n\n  .provider('$collapse', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-collapse',\n      disallowToggle: false,\n      activeClass: 'in',\n      startCollapsed: false,\n      allowMultiple: false\n    };\n\n    var controller = this.controller = function ($scope, $element, $attrs) {\n      var self = this;\n\n      // Attributes options\n      self.$options = angular.copy(defaults);\n      angular.forEach(['animation', 'disallowToggle', 'activeClass', 'startCollapsed', 'allowMultiple'], function (key) {\n        if (angular.isDefined($attrs[key])) self.$options[key] = $attrs[key];\n      });\n\n      // use string regex match boolean attr falsy values, leave truthy values be\n      var falseValueRegExp = /^(false|0|)$/i;\n      angular.forEach(['disallowToggle', 'startCollapsed', 'allowMultiple'], function (key) {\n        if (angular.isDefined($attrs[key]) && falseValueRegExp.test($attrs[key])) {\n          self.$options[key] = false;\n        }\n      });\n\n      self.$toggles = [];\n      self.$targets = [];\n\n      self.$viewChangeListeners = [];\n\n      self.$registerToggle = function (element) {\n        self.$toggles.push(element);\n      };\n      self.$registerTarget = function (element) {\n        self.$targets.push(element);\n      };\n\n      self.$unregisterToggle = function (element) {\n        var index = self.$toggles.indexOf(element);\n        // remove toggle from $toggles array\n        self.$toggles.splice(index, 1);\n      };\n      self.$unregisterTarget = function (element) {\n        var index = self.$targets.indexOf(element);\n\n        // remove element from $targets array\n        self.$targets.splice(index, 1);\n\n        if (self.$options.allowMultiple) {\n          // remove target index from $active array values\n          deactivateItem(element);\n        }\n\n        // fix active item indexes\n        fixActiveItemIndexes(index);\n\n        self.$viewChangeListeners.forEach(function (fn) {\n          fn();\n        });\n      };\n\n      // use array to store all the currently open panels\n      self.$targets.$active = !self.$options.startCollapsed ? [0] : [];\n      self.$setActive = $scope.$setActive = function (value) {\n        if (angular.isArray(value)) {\n          self.$targets.$active = value;\n        } else if (!self.$options.disallowToggle && isActive(value)) {\n          deactivateItem(value);\n        } else {\n          activateItem(value);\n        }\n\n        self.$viewChangeListeners.forEach(function (fn) {\n          fn();\n        });\n      };\n\n      self.$activeIndexes = function () {\n        if (self.$options.allowMultiple) {\n          return self.$targets.$active;\n        }\n        return self.$targets.$active.length === 1 ? self.$targets.$active[0] : -1;\n      };\n\n      function fixActiveItemIndexes(index) {\n        // item with index was removed, so we\n        // need to adjust other items index values\n        var activeIndexes = self.$targets.$active;\n        for (var i = 0; i < activeIndexes.length; i++) {\n          if (index < activeIndexes[i]) {\n            activeIndexes[i] = activeIndexes[i] - 1;\n          }\n\n          // the last item is active, so we need to\n          // adjust its index\n          if (activeIndexes[i] === self.$targets.length) {\n            activeIndexes[i] = self.$targets.length - 1;\n          }\n        }\n      }\n\n      function isActive(value) {\n        var activeItems = self.$targets.$active;\n        return activeItems.indexOf(value) === -1 ? false : true;\n      }\n\n      function deactivateItem(value) {\n        var index = self.$targets.$active.indexOf(value);\n        if (index !== -1) {\n          self.$targets.$active.splice(index, 1);\n        }\n      }\n\n      function activateItem(value) {\n        if (!self.$options.allowMultiple) {\n          // remove current selected item\n          self.$targets.$active.splice(0, 1);\n        }\n\n        if (self.$targets.$active.indexOf(value) === -1) {\n          self.$targets.$active.push(value);\n        }\n      }\n\n    };\n\n    this.$get = function () {\n      var $collapse = {};\n      $collapse.defaults = defaults;\n      $collapse.controller = controller;\n      return $collapse;\n    };\n\n  })\n\n  .directive('bsCollapse', function ($window, $animate, $collapse) {\n\n    return {\n      require: ['?ngModel', 'bsCollapse'],\n      controller: ['$scope', '$element', '$attrs', $collapse.controller],\n      link: function postLink(scope, element, attrs, controllers) {\n\n        var ngModelCtrl = controllers[0];\n        var bsCollapseCtrl = controllers[1];\n\n        if (ngModelCtrl) {\n\n          // Update the modelValue following\n          bsCollapseCtrl.$viewChangeListeners.push(function () {\n            ngModelCtrl.$setViewValue(bsCollapseCtrl.$activeIndexes());\n          });\n\n          // modelValue -> $formatters -> viewValue\n          ngModelCtrl.$formatters.push(function (modelValue) {\n            // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n            if (angular.isArray(modelValue)) {\n              // model value is an array, so just replace\n              // the active items directly\n              bsCollapseCtrl.$setActive(modelValue);\n            } else {\n              var activeIndexes = bsCollapseCtrl.$activeIndexes();\n\n              if (angular.isArray(activeIndexes)) {\n                // we have an array of selected indexes\n                if (activeIndexes.indexOf(modelValue * 1) === -1) {\n                  // item with modelValue index is not active\n                  bsCollapseCtrl.$setActive(modelValue * 1);\n                }\n              } else if (activeIndexes !== modelValue * 1) {\n                bsCollapseCtrl.$setActive(modelValue * 1);\n              }\n            }\n            return modelValue;\n          });\n\n        }\n\n      }\n    };\n\n  })\n\n  .directive('bsCollapseToggle', function () {\n\n    return {\n      require: ['^?ngModel', '^bsCollapse'],\n      link: function postLink(scope, element, attrs, controllers) {\n\n        // var ngModelCtrl = controllers[0];\n        var bsCollapseCtrl = controllers[1];\n\n        // Add base attr\n        element.attr('data-toggle', 'collapse');\n\n        // Push pane to parent bsCollapse controller\n        bsCollapseCtrl.$registerToggle(element);\n\n        // remove toggle from collapse controller when toggle is destroyed\n        scope.$on('$destroy', function () {\n          bsCollapseCtrl.$unregisterToggle(element);\n        });\n\n        element.on('click', function () {\n          if (!attrs.disabled) {\n            var index = attrs.bsCollapseToggle && attrs.bsCollapseToggle !== 'bs-collapse-toggle' ? attrs.bsCollapseToggle : bsCollapseCtrl.$toggles.indexOf(element);\n            bsCollapseCtrl.$setActive(index * 1);\n            scope.$apply();\n          }\n        });\n\n      }\n    };\n\n  })\n\n  .directive('bsCollapseTarget', function ($animate) {\n\n    return {\n      require: ['^?ngModel', '^bsCollapse'],\n      // scope: true,\n      link: function postLink(scope, element, attrs, controllers) {\n\n        // var ngModelCtrl = controllers[0];\n        var bsCollapseCtrl = controllers[1];\n\n        // Add base class\n        element.addClass('collapse');\n\n        // Add animation class\n        if (bsCollapseCtrl.$options.animation) {\n          element.addClass(bsCollapseCtrl.$options.animation);\n        }\n\n        // Push pane to parent bsCollapse controller\n        bsCollapseCtrl.$registerTarget(element);\n\n        // remove pane target from collapse controller when target is destroyed\n        scope.$on('$destroy', function () {\n          bsCollapseCtrl.$unregisterTarget(element);\n        });\n\n        function render() {\n          var index = bsCollapseCtrl.$targets.indexOf(element);\n          var active = bsCollapseCtrl.$activeIndexes();\n          var action = 'removeClass';\n          if (angular.isArray(active)) {\n            if (active.indexOf(index) !== -1) {\n              action = 'addClass';\n            }\n          } else if (index === active) {\n            action = 'addClass';\n          }\n\n          $animate[action](element, bsCollapseCtrl.$options.activeClass);\n        }\n\n        bsCollapseCtrl.$viewChangeListeners.push(function () {\n          render();\n        });\n        render();\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.typeahead', ['mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions'])\n\n  .provider('$typeahead', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'typeahead',\n      prefixEvent: '$typeahead',\n      placement: 'bottom-left',\n      templateUrl: 'typeahead/typeahead.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      minLength: 1,\n      filter: 'bsAsyncFilter',\n      limit: 6,\n      autoSelect: false,\n      comparator: '',\n      trimValue: true\n    };\n\n    this.$get = function ($window, $rootScope, $tooltip, $$rAF, $timeout) {\n\n      function TypeaheadFactory(element, controller, config) {\n\n        var $typeahead = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $typeahead = $tooltip(element, options);\n        var parentScope = config.scope;\n        var scope = $typeahead.$scope;\n\n        scope.$resetMatches = function () {\n          scope.$matches = [];\n          scope.$activeIndex = options.autoSelect ? 0 : -1; // If set to 0, the first match will be highlighted\n        };\n        scope.$resetMatches();\n\n        scope.$activate = function (index) {\n          scope.$$postDigest(function () {\n            $typeahead.activate(index);\n          });\n        };\n\n        scope.$select = function (index, evt) {\n          scope.$$postDigest(function () {\n            $typeahead.select(index);\n          });\n        };\n\n        scope.$isVisible = function () {\n          return $typeahead.$isVisible();\n        };\n\n        // Public methods\n\n        $typeahead.update = function (matches) {\n          scope.$matches = matches;\n          if (scope.$activeIndex >= matches.length) {\n            scope.$activeIndex = options.autoSelect ? 0 : -1;\n          }\n\n          // wrap in a $timeout so the results are updated\n          // before repositioning\n          safeDigest(scope);\n          $$rAF($typeahead.$applyPlacement);\n        };\n\n        $typeahead.activate = function (index) {\n          scope.$activeIndex = index;\n        };\n\n        $typeahead.select = function (index) {\n          if (index === -1) return;\n          var value = scope.$matches[index].value;\n          // console.log('$setViewValue', value);\n          controller.$setViewValue(value);\n          controller.$render();\n          scope.$resetMatches();\n          if (parentScope) parentScope.$digest();\n          // Emit event\n          scope.$emit(options.prefixEvent + '.select', value, index, $typeahead);\n        };\n\n        // Protected methods\n\n        $typeahead.$isVisible = function () {\n          if (!options.minLength || !controller) {\n            return !!scope.$matches.length;\n          }\n          // minLength support\n          return scope.$matches.length && angular.isString(controller.$viewValue) && controller.$viewValue.length >= options.minLength;\n        };\n\n        $typeahead.$getIndex = function (value) {\n          var index;\n          for (index = scope.$matches.length; index--;) {\n            if (angular.equals(scope.$matches[index].value, value)) break;\n          }\n          return index;\n        };\n\n        $typeahead.$onMouseDown = function (evt) {\n          // Prevent blur on mousedown\n          evt.preventDefault();\n          evt.stopPropagation();\n        };\n\n        $typeahead.$onKeyDown = function (evt) {\n          if (!/(38|40|13)/.test(evt.keyCode)) return;\n\n          // Let ngSubmit pass if the typeahead tip is hidden or no option is selected\n          if ($typeahead.$isVisible() && !(evt.keyCode === 13 && scope.$activeIndex === -1)) {\n            evt.preventDefault();\n            evt.stopPropagation();\n          }\n\n          // Select with enter\n          if (evt.keyCode === 13 && scope.$matches.length) {\n            $typeahead.select(scope.$activeIndex);\n          }\n\n          // Navigate with keyboard\n          else if (evt.keyCode === 38 && scope.$activeIndex > 0) scope.$activeIndex--;\n          else if (evt.keyCode === 40 && scope.$activeIndex < scope.$matches.length - 1) scope.$activeIndex++;\n          else if (angular.isUndefined(scope.$activeIndex)) scope.$activeIndex = 0;\n          scope.$digest();\n        };\n\n        // Overrides\n\n        var show = $typeahead.show;\n        $typeahead.show = function () {\n          show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed immediately.\n          $timeout(function () {\n            if ($typeahead.$element) {\n              $typeahead.$element.on('mousedown', $typeahead.$onMouseDown);\n              if (options.keyboard) {\n                if (element) element.on('keydown', $typeahead.$onKeyDown);\n              }\n            }\n          }, 0, false);\n        };\n\n        var hide = $typeahead.hide;\n        $typeahead.hide = function () {\n          if ($typeahead.$element) $typeahead.$element.off('mousedown', $typeahead.$onMouseDown);\n          if (options.keyboard) {\n            if (element) element.off('keydown', $typeahead.$onKeyDown);\n          }\n          if (!options.autoSelect) {\n            $typeahead.activate(-1);\n          }\n          hide();\n        };\n\n        return $typeahead;\n\n      }\n\n      // Helper functions\n\n      function safeDigest(scope) {\n        /* eslint-disable no-unused-expressions */\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n        /* eslint-enable no-unused-expressions */\n      }\n\n      TypeaheadFactory.defaults = defaults;\n      return TypeaheadFactory;\n\n    };\n\n  })\n\n  .filter('bsAsyncFilter', function ($filter) {\n    return function (array, expression, comparator) {\n      if (array && angular.isFunction(array.then)) {\n        return array.then(function (results) {\n          return $filter('filter')(results, expression, comparator);\n        });\n      }\n      return $filter('filter')(array, expression, comparator);\n    };\n  })\n\n  .directive('bsTypeahead', function ($window, $parse, $q, $typeahead, $parseOptions) {\n\n    var defaults = $typeahead.defaults;\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = {\n          scope: scope\n        };\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'filter', 'limit', 'minLength', 'watchOptions', 'selectMode', 'autoSelect', 'comparator', 'id', 'prefixEvent', 'prefixClass'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'trimValue'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\n        });\n\n        // Disable browser autocompletion\n        if (!element.attr('autocomplete')) element.attr('autocomplete', 'off');\n\n        // Build proper bsOptions\n        var filter = options.filter || defaults.filter;\n        var limit = options.limit || defaults.limit;\n        var comparator = options.comparator || defaults.comparator;\n\n        var bsOptions = attr.bsOptions;\n        if (filter) bsOptions += ' | ' + filter + ':$viewValue';\n        if (comparator) bsOptions += ':' + comparator;\n        if (limit) bsOptions += ' | limitTo:' + limit;\n        var parsedOptions = $parseOptions(bsOptions);\n\n        // Initialize typeahead\n        var typeahead = $typeahead(element, controller, options);\n\n        // Watch options on demand\n        if (options.watchOptions) {\n          // Watch bsOptions values before filtering for changes, drop function calls\n          var watchedOptions = parsedOptions.$match[7].replace(/\\|.+/, '').replace(/\\(.*\\)/g, '').trim();\n          scope.$watchCollection(watchedOptions, function (newValue, oldValue) {\n            // console.warn('scope.$watch(%s)', watchedOptions, newValue, oldValue);\n            parsedOptions.valuesFn(scope, controller).then(function (values) {\n              typeahead.update(values);\n              controller.$render();\n            });\n          });\n        }\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\n          // console.warn('$watch', element.attr('ng-model'), newValue);\n          scope.$modelValue = newValue; // Publish modelValue on scope for custom templates\n          parsedOptions.valuesFn(scope, controller)\n            .then(function (values) {\n              // Prevent input with no future prospect if selectMode is truthy\n              // @TODO test selectMode\n              if (options.selectMode && !values.length && newValue.length > 0) {\n                controller.$setViewValue(controller.$viewValue.substring(0, controller.$viewValue.length - 1));\n                return;\n              }\n              if (values.length > limit) values = values.slice(0, limit);\n              typeahead.update(values);\n              // Queue a new rendering that will leverage collection loading\n              controller.$render();\n            });\n        });\n\n        // modelValue -> $formatters -> viewValue\n        controller.$formatters.push(function (modelValue) {\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n          var displayValue = parsedOptions.displayValue(modelValue);\n\n          // If we can determine the displayValue, use that\n          if (displayValue) {\n            return displayValue;\n          }\n\n          // If there's no display value, attempt to use the modelValue.\n          // If the model is an object not much we can do\n          if (modelValue && typeof modelValue !== 'object') {\n            return modelValue;\n          }\n          return '';\n        });\n\n        // Model rendering in view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          if (controller.$isEmpty(controller.$viewValue)) {\n            return element.val('');\n          }\n          var index = typeahead.$getIndex(controller.$modelValue);\n          var selected = index !== -1 ? typeahead.$scope.$matches[index].label : controller.$viewValue;\n          selected = angular.isObject(selected) ? parsedOptions.displayValue(selected) : selected;\n          var value = selected ? selected.toString().replace(/<(?:.|\\n)*?>/gm, '') : '';\n          element.val(options.trimValue === false ? value : value.trim());\n        };\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (typeahead) typeahead.destroy();\n          options = null;\n          typeahead = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.timepicker', ['mgcrea.ngStrap.helpers.dateParser', 'mgcrea.ngStrap.helpers.dateFormatter', 'mgcrea.ngStrap.tooltip'])\n\n  .provider('$timepicker', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      // uncommenting the following line will break backwards compatability\n      // prefixEvent: 'timepicker',\n      prefixClass: 'timepicker',\n      placement: 'bottom-left',\n      templateUrl: 'timepicker/timepicker.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      // lang: $locale.id,\n      useNative: true,\n      timeType: 'date',\n      timeFormat: 'shortTime',\n      timezone: null,\n      modelTimeFormat: null,\n      autoclose: false,\n      minTime: -Infinity,\n      maxTime: +Infinity,\n      length: 5,\n      hourStep: 1,\n      minuteStep: 5,\n      secondStep: 5,\n      roundDisplay: false,\n      iconUp: 'glyphicon glyphicon-chevron-up',\n      iconDown: 'glyphicon glyphicon-chevron-down',\n      arrowBehavior: 'pager'\n    };\n\n    this.$get = function ($window, $document, $rootScope, $sce, $dateFormatter, $tooltip, $timeout) {\n\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n      if (!defaults.lang) {\n        defaults.lang = $dateFormatter.getDefaultLocale();\n      }\n\n      function timepickerFactory(element, controller, config) {\n\n        var $timepicker = $tooltip(element, angular.extend({}, defaults, config));\n        var parentScope = config.scope;\n        var options = $timepicker.$options;\n        var scope = $timepicker.$scope;\n\n        var lang = options.lang;\n        var formatDate = function (date, format, timezone) {\n          return $dateFormatter.formatDate(date, format, lang, timezone);\n        };\n\n        function floorMinutes(time) {\n          // coeff used to floor current time to nearest minuteStep interval\n          var coeff = 1000 * 60 * options.minuteStep;\n          return new Date(Math.floor(time.getTime() / coeff) * coeff);\n        }\n\n        // View vars\n\n        var selectedIndex = 0;\n        var defaultDate = options.roundDisplay ? floorMinutes(new Date()) : new Date();\n        var startDate = controller.$dateValue || defaultDate;\n        var viewDate = {\n          hour: startDate.getHours(),\n          meridian: startDate.getHours() < 12,\n          minute: startDate.getMinutes(),\n          second: startDate.getSeconds(),\n          millisecond: startDate.getMilliseconds()\n        };\n\n        var format = $dateFormatter.getDatetimeFormat(options.timeFormat, lang);\n\n        var hoursFormat = $dateFormatter.hoursFormat(format);\n        var timeSeparator = $dateFormatter.timeSeparator(format);\n        var minutesFormat = $dateFormatter.minutesFormat(format);\n        var secondsFormat = $dateFormatter.secondsFormat(format);\n        var showSeconds = $dateFormatter.showSeconds(format);\n        var showAM = $dateFormatter.showAM(format);\n\n        scope.$iconUp = options.iconUp;\n        scope.$iconDown = options.iconDown;\n\n        // Scope methods\n\n        scope.$select = function (date, index) {\n          $timepicker.select(date, index);\n        };\n        scope.$moveIndex = function (value, index) {\n          $timepicker.$moveIndex(value, index);\n        };\n        scope.$switchMeridian = function (date) {\n          $timepicker.switchMeridian(date);\n        };\n\n        // Public methods\n\n        $timepicker.update = function (date) {\n          // console.warn('$timepicker.update() newValue=%o', date);\n          if (angular.isDate(date) && !isNaN(date.getTime())) {\n            $timepicker.$date = date;\n            angular.extend(viewDate, {\n              hour: date.getHours(),\n              minute: date.getMinutes(),\n              second: date.getSeconds(),\n              millisecond: date.getMilliseconds()\n            });\n            $timepicker.$build();\n          } else if (!$timepicker.$isBuilt) {\n            $timepicker.$build();\n          }\n        };\n\n        $timepicker.select = function (date, index, keep) {\n          // console.warn('$timepicker.select', date, scope.$mode);\n          if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) controller.$dateValue = new Date(1970, 0, 1);\n          if (!angular.isDate(date)) date = new Date(date);\n          if (index === 0) controller.$dateValue.setHours(date.getHours());\n          else if (index === 1) controller.$dateValue.setMinutes(date.getMinutes());\n          else if (index === 2) controller.$dateValue.setSeconds(date.getSeconds());\n          controller.$setViewValue(angular.copy(controller.$dateValue));\n          controller.$render();\n          if (options.autoclose && !keep) {\n            $timeout(function () {\n              $timepicker.hide(true);\n            });\n          }\n        };\n\n        $timepicker.switchMeridian = function (date) {\n          if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) {\n            return;\n          }\n          var hours = (date || controller.$dateValue).getHours();\n          controller.$dateValue.setHours(hours < 12 ? hours + 12 : hours - 12);\n          controller.$setViewValue(angular.copy(controller.$dateValue));\n          controller.$render();\n        };\n\n        // Protected methods\n\n        $timepicker.$build = function () {\n          // console.warn('$timepicker.$build() viewDate=%o', viewDate);\n          var i;\n          var midIndex = scope.midIndex = parseInt(options.length / 2, 10);\n          var hours = [];\n          var hour;\n          for (i = 0; i < options.length; i++) {\n            hour = new Date(1970, 0, 1, viewDate.hour - (midIndex - i) * options.hourStep);\n            hours.push({\n              date: hour,\n              label: formatDate(hour, hoursFormat),\n              selected: $timepicker.$date && $timepicker.$isSelected(hour, 0),\n              disabled: $timepicker.$isDisabled(hour, 0)\n            });\n          }\n          var minutes = [];\n          var minute;\n          for (i = 0; i < options.length; i++) {\n            minute = new Date(1970, 0, 1, 0, viewDate.minute - (midIndex - i) * options.minuteStep);\n            minutes.push({\n              date: minute,\n              label: formatDate(minute, minutesFormat),\n              selected: $timepicker.$date && $timepicker.$isSelected(minute, 1),\n              disabled: $timepicker.$isDisabled(minute, 1)\n            });\n          }\n          var seconds = [];\n          var second;\n          for (i = 0; i < options.length; i++) {\n            second = new Date(1970, 0, 1, 0, 0, viewDate.second - (midIndex - i) * options.secondStep);\n            seconds.push({\n              date: second,\n              label: formatDate(second, secondsFormat),\n              selected: $timepicker.$date && $timepicker.$isSelected(second, 2),\n              disabled: $timepicker.$isDisabled(second, 2)\n            });\n          }\n\n          var rows = [];\n          for (i = 0; i < options.length; i++) {\n            if (showSeconds) {\n              rows.push([hours[i], minutes[i], seconds[i]]);\n            } else {\n              rows.push([hours[i], minutes[i]]);\n            }\n          }\n          scope.rows = rows;\n          scope.showSeconds = showSeconds;\n          scope.showAM = showAM;\n          scope.isAM = ($timepicker.$date || hours[midIndex].date).getHours() < 12;\n          scope.timeSeparator = timeSeparator;\n          $timepicker.$isBuilt = true;\n        };\n\n        $timepicker.$isSelected = function (date, index) {\n          if (!$timepicker.$date) return false;\n          else if (index === 0) {\n            return date.getHours() === $timepicker.$date.getHours();\n          } else if (index === 1) {\n            return date.getMinutes() === $timepicker.$date.getMinutes();\n          } else if (index === 2) {\n            return date.getSeconds() === $timepicker.$date.getSeconds();\n          }\n        };\n\n        $timepicker.$isDisabled = function (date, index) {\n          var selectedTime;\n          if (index === 0) {\n            selectedTime = date.getTime() + viewDate.minute * 6e4 + viewDate.second * 1e3;\n          } else if (index === 1) {\n            selectedTime = date.getTime() + viewDate.hour * 36e5 + viewDate.second * 1e3;\n          } else if (index === 2) {\n            selectedTime = date.getTime() + viewDate.hour * 36e5 + viewDate.minute * 6e4;\n          }\n          return selectedTime < options.minTime * 1 || selectedTime > options.maxTime * 1;\n        };\n\n        scope.$arrowAction = function (value, index) {\n          if (options.arrowBehavior === 'picker') {\n            $timepicker.$setTimeByStep(value, index);\n          } else {\n            $timepicker.$moveIndex(value, index);\n          }\n        };\n\n        $timepicker.$setTimeByStep = function (value, index) {\n          var newDate = new Date($timepicker.$date || startDate);\n          var hours = newDate.getHours();\n          var minutes = newDate.getMinutes();\n          var seconds = newDate.getSeconds();\n          if (index === 0) {\n            newDate.setHours(hours - (parseInt(options.hourStep, 10) * value));\n          } else if (index === 1) {\n            newDate.setMinutes(minutes - (parseInt(options.minuteStep, 10) * value));\n          } else if (index === 2) {\n            newDate.setSeconds(seconds - (parseInt(options.secondStep, 10) * value));\n          }\n          $timepicker.select(newDate, index, true);\n        };\n\n        $timepicker.$moveIndex = function (value, index) {\n          var targetDate;\n          if (index === 0) {\n            targetDate = new Date(1970, 0, 1, viewDate.hour + (value * options.length), viewDate.minute, viewDate.second);\n            angular.extend(viewDate, {\n              hour: targetDate.getHours()\n            });\n          } else if (index === 1) {\n            targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute + (value * options.length * options.minuteStep), viewDate.second);\n            angular.extend(viewDate, {\n              minute: targetDate.getMinutes()\n            });\n          } else if (index === 2) {\n            targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute, viewDate.second + (value * options.length * options.secondStep));\n            angular.extend(viewDate, {\n              second: targetDate.getSeconds()\n            });\n          }\n          $timepicker.$build();\n        };\n\n        $timepicker.$onMouseDown = function (evt) {\n          // Prevent blur on mousedown on .dropdown-menu\n          if (evt.target.nodeName.toLowerCase() !== 'input') evt.preventDefault();\n          evt.stopPropagation();\n          // Emulate click for mobile devices\n          if (isTouch) {\n            var targetEl = angular.element(evt.target);\n            if (targetEl[0].nodeName.toLowerCase() !== 'button') {\n              targetEl = targetEl.parent();\n            }\n            targetEl.triggerHandler('click');\n          }\n        };\n\n        $timepicker.$onKeyDown = function (evt) {\n          if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          // Close on enter\n          if (evt.keyCode === 13) {\n            $timepicker.hide(true);\n            return;\n          }\n\n          // Navigate with keyboard\n          var newDate = new Date($timepicker.$date);\n          var hours = newDate.getHours();\n          var hoursLength = formatDate(newDate, hoursFormat).length;\n          var minutes = newDate.getMinutes();\n          var minutesLength = formatDate(newDate, minutesFormat).length;\n          var seconds = newDate.getSeconds();\n          var secondsLength = formatDate(newDate, secondsFormat).length;\n          var sepLength = 1;\n          var lateralMove = /(37|39)/.test(evt.keyCode);\n          var count = 2 + showSeconds * 1 + showAM * 1;\n\n          // Navigate indexes (left, right)\n          if (lateralMove) {\n            if (evt.keyCode === 37) selectedIndex = selectedIndex < 1 ? count - 1 : selectedIndex - 1;\n            else if (evt.keyCode === 39) selectedIndex = selectedIndex < count - 1 ? selectedIndex + 1 : 0;\n          }\n\n          // Update values (up, down)\n          var selectRange = [0, hoursLength];\n          var incr = 0;\n          if (evt.keyCode === 38) incr = -1;\n          if (evt.keyCode === 40) incr = +1;\n          var isSeconds = selectedIndex === 2 && showSeconds;\n          var isMeridian = selectedIndex === 2 && !showSeconds || selectedIndex === 3 && showSeconds;\n          if (selectedIndex === 0) {\n            newDate.setHours(hours + incr * parseInt(options.hourStep, 10));\n            // re-calculate hours length because we have changed hours value\n            hoursLength = formatDate(newDate, hoursFormat).length;\n            selectRange = [0, hoursLength];\n          } else if (selectedIndex === 1) {\n            newDate.setMinutes(minutes + incr * parseInt(options.minuteStep, 10));\n            // re-calculate minutes length because we have changes minutes value\n            minutesLength = formatDate(newDate, minutesFormat).length;\n            selectRange = [hoursLength + sepLength, minutesLength];\n          } else if (isSeconds) {\n            newDate.setSeconds(seconds + incr * parseInt(options.secondStep, 10));\n            // re-calculate seconds length because we have changes seconds value\n            secondsLength = formatDate(newDate, secondsFormat).length;\n            selectRange = [hoursLength + sepLength + minutesLength + sepLength, secondsLength];\n          } else if (isMeridian) {\n            if (!lateralMove) $timepicker.switchMeridian();\n            selectRange = [hoursLength + sepLength + minutesLength + sepLength + (secondsLength + sepLength) * showSeconds, 2];\n          }\n          $timepicker.select(newDate, selectedIndex, true);\n          createSelection(selectRange[0], selectRange[1]);\n          parentScope.$digest();\n        };\n\n        // Private\n\n        function createSelection(start, length) {\n          var end = start + length;\n          if (element[0].createTextRange) {\n            var selRange = element[0].createTextRange();\n            selRange.collapse(true);\n            selRange.moveStart('character', start);\n            selRange.moveEnd('character', end);\n            selRange.select();\n          } else if (element[0].setSelectionRange) {\n            element[0].setSelectionRange(start, end);\n          } else if (angular.isUndefined(element[0].selectionStart)) {\n            element[0].selectionStart = start;\n            element[0].selectionEnd = end;\n          }\n        }\n\n        function focusElement() {\n          element[0].focus();\n        }\n\n        // Overrides\n\n        var _init = $timepicker.init;\n        $timepicker.init = function () {\n          if (isNative && options.useNative) {\n            element.prop('type', 'time');\n            element.css('-webkit-appearance', 'textfield');\n            return;\n          } else if (isTouch) {\n            element.prop('type', 'text');\n            element.attr('readonly', 'true');\n            element.on('click', focusElement);\n          }\n          _init();\n        };\n\n        var _destroy = $timepicker.destroy;\n        $timepicker.destroy = function () {\n          if (isNative && options.useNative) {\n            element.off('click', focusElement);\n          }\n          _destroy();\n        };\n\n        var _show = $timepicker.show;\n        $timepicker.show = function () {\n          if ((!isTouch && element.attr('readonly')) || element.attr('disabled')) return;\n          _show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function () {\n            if ($timepicker.$element) $timepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\n            if (options.keyboard) {\n              if (element) element.on('keydown', $timepicker.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var _hide = $timepicker.hide;\n        $timepicker.hide = function (blur) {\n          if (!$timepicker.$isShown) return;\n          if ($timepicker.$element) $timepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\n          if (options.keyboard) {\n            if (element) element.off('keydown', $timepicker.$onKeyDown);\n          }\n          _hide(blur);\n        };\n\n        return $timepicker;\n\n      }\n\n      timepickerFactory.defaults = defaults;\n      return timepickerFactory;\n\n    };\n\n  })\n\n\n  .directive('bsTimepicker', function ($window, $parse, $q, $dateFormatter, $dateParser, $timepicker) {\n\n    var defaults = $timepicker.defaults;\n    var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = {\n          scope: scope\n        };\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'autoclose', 'timeType', 'timeFormat', 'timezone', 'modelTimeFormat', 'useNative', 'hourStep', 'minuteStep', 'secondStep', 'length', 'arrowBehavior', 'iconUp', 'iconDown', 'roundDisplay', 'id', 'prefixClass', 'prefixEvent'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'autoclose', 'useNative', 'roundDisplay'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\n            options[key] = false;\n          }\n        });\n\n\n        // Initialize timepicker\n        if (isNative && (options.useNative || defaults.useNative)) options.timeFormat = 'HH:mm';\n        var timepicker = $timepicker(element, controller, options);\n        options = timepicker.$options;\n\n        var lang = options.lang;\n        var formatDate = function (date, format, timezone) {\n          return $dateFormatter.formatDate(date, format, lang, timezone);\n        };\n\n        // Visibility binding support\n        if (attr.bsShow) {\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\n            if (!timepicker || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(timepicker),?/i);\n            if (newValue === true) {\n              timepicker.show();\n            } else {\n              timepicker.hide();\n            }\n          });\n        }\n\n        // Initialize parser\n        var dateParser = $dateParser({\n          format: options.timeFormat,\n          lang: lang\n        });\n\n        // Observe attributes for changes\n        angular.forEach(['minTime', 'maxTime'], function (key) {\n          // console.warn('attr.$observe(%s)', key, attr[key]);\n          if (angular.isDefined(attr[key])) {\n            attr.$observe(key, function (newValue) {\n              timepicker.$options[key] = dateParser.getTimeForAttribute(key, newValue);\n              if (!isNaN(timepicker.$options[key])) timepicker.$build();\n              validateAgainstMinMaxTime(controller.$dateValue);\n            });\n          }\n        });\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', attr.ngModel, newValue, oldValue, controller.$dateValue);\n          timepicker.update(controller.$dateValue);\n        }, true);\n\n        function validateAgainstMinMaxTime(parsedTime) {\n          if (!angular.isDate(parsedTime)) return;\n          var isMinValid = isNaN(options.minTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) >= options.minTime;\n          var isMaxValid = isNaN(options.maxTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) <= options.maxTime;\n          var isValid = isMinValid && isMaxValid;\n          controller.$setValidity('date', isValid);\n          controller.$setValidity('min', isMinValid);\n          controller.$setValidity('max', isMaxValid);\n          // Only update the model when we have a valid date\n          if (!isValid) {\n            return;\n          }\n          controller.$dateValue = parsedTime;\n        }\n\n        // viewValue -> $parsers -> modelValue\n        controller.$parsers.unshift(function (viewValue) {\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\n          var date;\n          // Null values should correctly reset the model value & validity\n          if (!viewValue) {\n            // BREAKING CHANGE:\n            // return null (not undefined) when input value is empty, so angularjs 1.3\n            // ngModelController can go ahead and run validators, like ngRequired\n            controller.$setValidity('date', true);\n            return null;\n          }\n          var parsedTime = angular.isDate(viewValue) ? viewValue : dateParser.parse(viewValue, controller.$dateValue);\n          if (!parsedTime || isNaN(parsedTime.getTime())) {\n            controller.$setValidity('date', false);\n            // Return undefined, causes ngModelController to\n            // invalidate model value\n            return undefined;\n          }\n          validateAgainstMinMaxTime(parsedTime);\n\n          if (options.timeType === 'string') {\n            date = dateParser.timezoneOffsetAdjust(parsedTime, options.timezone, true);\n            return formatDate(date, options.modelTimeFormat || options.timeFormat);\n          }\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\n          if (options.timeType === 'number') {\n            return date.getTime();\n          } else if (options.timeType === 'unix') {\n            return date.getTime() / 1000;\n          } else if (options.timeType === 'iso') {\n            return date.toISOString();\n          }\n          return new Date(date);\n        });\n\n        // modelValue -> $formatters -> viewValue\n        controller.$formatters.push(function (modelValue) {\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n          var date;\n          if (angular.isUndefined(modelValue) || modelValue === null) {\n            date = NaN;\n          } else if (angular.isDate(modelValue)) {\n            date = modelValue;\n          } else if (options.timeType === 'string') {\n            date = dateParser.parse(modelValue, null, options.modelTimeFormat);\n          } else if (options.timeType === 'unix') {\n            date = new Date(modelValue * 1000);\n          } else {\n            date = new Date(modelValue);\n          }\n          // Setup default value?\n          // if(isNaN(date.getTime())) date = new Date(new Date().setMinutes(0) + 36e5);\n          controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\n          return getTimeFormattedString();\n        });\n\n        // viewValue -> element\n        controller.$render = function () {\n          // console.warn('$render(\"%s\"): viewValue=%o', element.attr('ng-model'), controller.$viewValue);\n          element.val(getTimeFormattedString());\n        };\n\n        function getTimeFormattedString() {\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.timeFormat);\n        }\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (timepicker) timepicker.destroy();\n          options = null;\n          timepicker = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.popover', ['mgcrea.ngStrap.tooltip'])\n\n  .provider('$popover', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      customClass: '',\n      // uncommenting the next two lines will break backwards compatability\n      // prefixClass: 'popover',\n      // prefixEvent: 'popover',\n      container: false,\n      target: false,\n      placement: 'right',\n      templateUrl: 'popover/popover.tpl.html',\n      contentTemplate: false,\n      trigger: 'click',\n      keyboard: true,\n      html: false,\n      title: '',\n      content: '',\n      delay: 0,\n      autoClose: false\n    };\n\n    this.$get = function ($tooltip) {\n\n      function PopoverFactory(element, config) {\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        var $popover = $tooltip(element, options);\n\n        // Support scope as string options [/*title, */content]\n        if (options.content) {\n          $popover.$scope.content = options.content;\n        }\n\n        return $popover;\n\n      }\n\n      return PopoverFactory;\n\n    };\n\n  })\n\n  .directive('bsPopover', function ($window, $sce, $popover) {\n\n    var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr) {\n\n        var popover;\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'customClass', 'autoClose', 'id', 'prefixClass', 'prefixEvent'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'autoClose'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\n        });\n\n        // should not parse target attribute (anchor tag), only data-target #1454\n        var dataTarget = element.attr('data-target');\n        if (angular.isDefined(dataTarget)) {\n          if (falseValueRegExp.test(dataTarget)) {\n            options.target = false;\n          } else {\n            options.target = dataTarget;\n          }\n        }\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content'], function (key) {\n          if (attr[key]) {\n            attr.$observe(key, function (newValue, oldValue) {\n              scope[key] = $sce.trustAsHtml(newValue);\n              if (angular.isDefined(oldValue)) {\n                requestAnimationFrame(function () {\n                  if (popover) popover.$applyPlacement();\n                });\n              }\n            });\n          }\n        });\n\n        // Support scope as an object\n        if (attr.bsPopover) {\n          scope.$watch(attr.bsPopover, function (newValue, oldValue) {\n            if (angular.isObject(newValue)) {\n              angular.extend(scope, newValue);\n            } else {\n              scope.content = newValue;\n            }\n            if (angular.isDefined(oldValue)) {\n              requestAnimationFrame(function () {\n                if (popover) popover.$applyPlacement();\n              });\n            }\n          }, true);\n        }\n\n        // Visibility binding support\n        if (attr.bsShow) {\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\n            if (!popover || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(popover),?/i);\n            if (newValue === true) {\n              popover.show();\n            } else {\n              popover.hide();\n            }\n          });\n        }\n\n        // Viewport support\n        if (attr.viewport) {\n          scope.$watch(attr.viewport, function (newValue) {\n            if (!popover || !angular.isDefined(newValue)) return;\n            popover.setViewport(newValue);\n          });\n        }\n\n        // Initialize popover\n        popover = $popover(element, options);\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (popover) popover.destroy();\n          options = null;\n          popover = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.tab', [])\n\n  .provider('$tab', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      template: 'tab/tab.tpl.html',\n      navClass: 'nav-tabs',\n      activeClass: 'active'\n    };\n\n    var controller = this.controller = function ($scope, $element, $attrs) {\n      var self = this;\n\n      // Attributes options\n      self.$options = angular.copy(defaults);\n      angular.forEach(['animation', 'navClass', 'activeClass'], function (key) {\n        if (angular.isDefined($attrs[key])) self.$options[key] = $attrs[key];\n      });\n\n      // Publish options on scope\n      $scope.$navClass = self.$options.navClass;\n      $scope.$activeClass = self.$options.activeClass;\n\n      self.$panes = $scope.$panes = [];\n\n      // Please use $activePaneChangeListeners if you use `bsActivePane`\n      // Because we removed `ngModel` as default, we rename viewChangeListeners to\n      // activePaneChangeListeners to make more sense.\n      self.$activePaneChangeListeners = self.$viewChangeListeners = [];\n\n      self.$push = function (pane) {\n        if (angular.isUndefined(self.$panes.$active)) {\n          $scope.$setActive(pane.name || 0);\n        }\n        self.$panes.push(pane);\n      };\n\n      self.$remove = function (pane) {\n        var index = self.$panes.indexOf(pane);\n        var active = self.$panes.$active;\n        var activeIndex;\n        if (angular.isString(active)) {\n          activeIndex = self.$panes.map(function (pane) {\n            return pane.name;\n          }).indexOf(active);\n        } else {\n          activeIndex = self.$panes.$active;\n        }\n\n        // remove pane from $panes array\n        self.$panes.splice(index, 1);\n\n        if (index < activeIndex) {\n          // we removed a pane before the active pane, so we need to\n          // decrement the active pane index\n          activeIndex--;\n        } else if (index === activeIndex && activeIndex === self.$panes.length) {\n          // we remove the active pane and it was the one at the end,\n          // so select the previous one\n          activeIndex--;\n        }\n        if (activeIndex >= 0 && activeIndex < self.$panes.length) {\n          self.$setActive(self.$panes[activeIndex].name || activeIndex);\n        } else {\n          self.$setActive();\n        }\n      };\n\n      self.$setActive = $scope.$setActive = function (value) {\n        self.$panes.$active = value;\n        self.$activePaneChangeListeners.forEach(function (fn) {\n          fn();\n        });\n      };\n\n      self.$isActive = $scope.$isActive = function ($pane, $index) {\n        return self.$panes.$active === $pane.name || self.$panes.$active === $index;\n      };\n\n    };\n\n    this.$get = function () {\n      var $tab = {};\n      $tab.defaults = defaults;\n      $tab.controller = controller;\n      return $tab;\n    };\n\n  })\n\n  .directive('bsTabs', function ($window, $animate, $tab, $parse) {\n\n    var defaults = $tab.defaults;\n\n    return {\n      require: ['?ngModel', 'bsTabs'],\n      transclude: true,\n      scope: true,\n      controller: ['$scope', '$element', '$attrs', $tab.controller],\n      templateUrl: function (element, attr) {\n        return attr.template || defaults.template;\n      },\n      link: function postLink(scope, element, attrs, controllers) {\n\n        var ngModelCtrl = controllers[0];\n        var bsTabsCtrl = controllers[1];\n\n        // 'ngModel' does interfere with form validation\n        // and status, use `bsActivePane` instead to avoid it\n        if (ngModelCtrl) {\n\n          // Update the modelValue following\n          bsTabsCtrl.$activePaneChangeListeners.push(function () {\n            ngModelCtrl.$setViewValue(bsTabsCtrl.$panes.$active);\n          });\n\n          // modelValue -> $formatters -> viewValue\n          ngModelCtrl.$formatters.push(function (modelValue) {\n            // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n            bsTabsCtrl.$setActive(modelValue);\n            return modelValue;\n          });\n\n        }\n\n        if (attrs.bsActivePane) {\n          // adapted from angularjs ngModelController bindings\n          // https://github.com/angular/angular.js/blob/v1.3.1/src%2Fng%2Fdirective%2Finput.js#L1730\n          var parsedBsActivePane = $parse(attrs.bsActivePane);\n\n          // Update bsActivePane value with change\n          bsTabsCtrl.$activePaneChangeListeners.push(function () {\n            parsedBsActivePane.assign(scope, bsTabsCtrl.$panes.$active);\n          });\n\n          // watch bsActivePane for value changes\n          scope.$watch(attrs.bsActivePane, function (newValue, oldValue) {\n            bsTabsCtrl.$setActive(newValue);\n          }, true);\n        }\n      }\n    };\n\n  })\n\n  .directive('bsPane', function ($window, $animate, $sce) {\n\n    return {\n      require: ['^?ngModel', '^bsTabs'],\n      scope: true,\n      link: function postLink(scope, element, attrs, controllers) {\n\n        // var ngModelCtrl = controllers[0];\n        var bsTabsCtrl = controllers[1];\n\n        // Add base class\n        element.addClass('tab-pane');\n\n        // Observe title attribute for change\n        attrs.$observe('title', function (newValue, oldValue) {\n          scope.title = $sce.trustAsHtml(newValue);\n        });\n\n        // Save tab name into scope\n        scope.name = attrs.name;\n\n        // Add animation class\n        if (bsTabsCtrl.$options.animation) {\n          element.addClass(bsTabsCtrl.$options.animation);\n        }\n\n        attrs.$observe('disabled', function (newValue, oldValue) {\n          scope.disabled = scope.$eval(newValue);\n        });\n\n        // Push pane to parent bsTabs controller\n        bsTabsCtrl.$push(scope);\n\n        // remove pane from tab controller when pane is destroyed\n        scope.$on('$destroy', function () {\n          bsTabsCtrl.$remove(scope);\n        });\n\n        function render() {\n          var index = bsTabsCtrl.$panes.indexOf(scope);\n          $animate[bsTabsCtrl.$isActive(scope, index) ? 'addClass' : 'removeClass'](element, bsTabsCtrl.$options.activeClass);\n        }\n\n        bsTabsCtrl.$activePaneChangeListeners.push(function () {\n          render();\n        });\n        render();\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.scrollspy', ['mgcrea.ngStrap.helpers.debounce', 'mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$scrollspy', function () {\n\n    // Pool of registered spies\n    var spies = this.$$spies = {};\n\n    var defaults = this.defaults = {\n      debounce: 150,\n      throttle: 100,\n      offset: 100\n    };\n\n    this.$get = function ($window, $document, $rootScope, dimensions, debounce, throttle) {\n\n      var windowEl = angular.element($window);\n      var docEl = angular.element($document.prop('documentElement'));\n      var bodyEl = angular.element($window.document.body);\n\n      // Helper functions\n\n      function nodeName(element, name) {\n        return element[0].nodeName && element[0].nodeName.toLowerCase() === name.toLowerCase();\n      }\n\n      function ScrollSpyFactory(config) {\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        if (!options.element) options.element = bodyEl;\n        var isWindowSpy = nodeName(options.element, 'body');\n        var scrollEl = isWindowSpy ? windowEl : options.element;\n        var scrollId = isWindowSpy ? 'window' : options.id;\n\n        // Use existing spy\n        if (spies[scrollId]) {\n          spies[scrollId].$$count++;\n          return spies[scrollId];\n        }\n\n        var $scrollspy = {};\n\n        // Private vars\n        var unbindViewContentLoaded;\n        var unbindIncludeContentLoaded;\n        var trackedElements = $scrollspy.$trackedElements = [];\n        var sortedElements = [];\n        var activeTarget;\n        var debouncedCheckPosition;\n        var throttledCheckPosition;\n        var debouncedCheckOffsets;\n        /* eslint-disable no-unused-vars */\n        var viewportHeight;\n        /* eslint-enable no-unused-vars */\n        var scrollTop;\n\n        $scrollspy.init = function () {\n\n          // Setup internal ref counter\n          this.$$count = 1;\n\n          // Bind events\n          debouncedCheckPosition = debounce(this.checkPosition, options.debounce);\n          throttledCheckPosition = throttle(this.checkPosition, options.throttle);\n          scrollEl.on('click', this.checkPositionWithEventLoop);\n          windowEl.on('resize', debouncedCheckPosition);\n          scrollEl.on('scroll', throttledCheckPosition);\n\n          debouncedCheckOffsets = debounce(this.checkOffsets, options.debounce);\n          unbindViewContentLoaded = $rootScope.$on('$viewContentLoaded', debouncedCheckOffsets);\n          unbindIncludeContentLoaded = $rootScope.$on('$includeContentLoaded', debouncedCheckOffsets);\n          debouncedCheckOffsets();\n\n          // Register spy for reuse\n          if (scrollId) {\n            spies[scrollId] = $scrollspy;\n          }\n\n        };\n\n        $scrollspy.destroy = function () {\n\n          // Check internal ref counter\n          this.$$count--;\n          if (this.$$count > 0) {\n            return;\n          }\n\n          // Unbind events\n          scrollEl.off('click', this.checkPositionWithEventLoop);\n          windowEl.off('resize', debouncedCheckPosition);\n          scrollEl.off('scroll', throttledCheckPosition);\n          unbindViewContentLoaded();\n          unbindIncludeContentLoaded();\n          if (scrollId) {\n            delete spies[scrollId];\n          }\n        };\n\n        $scrollspy.checkPosition = function () {\n\n          // Not ready yet\n          if (!sortedElements.length) return;\n\n          // Calculate the scroll position\n          scrollTop = (isWindowSpy ? $window.pageYOffset : scrollEl.prop('scrollTop')) || 0;\n\n          // Calculate the viewport height for use by the components\n          viewportHeight = Math.max($window.innerHeight, docEl.prop('clientHeight'));\n\n          // Activate first element if scroll is smaller\n          if (scrollTop < sortedElements[0].offsetTop && activeTarget !== sortedElements[0].target) {\n            return $scrollspy.$activateElement(sortedElements[0]);\n          }\n\n          // Activate proper element\n          for (var i = sortedElements.length; i--;) {\n            if (angular.isUndefined(sortedElements[i].offsetTop) || sortedElements[i].offsetTop === null) continue;\n            if (activeTarget === sortedElements[i].target) continue;\n            if (scrollTop < sortedElements[i].offsetTop) continue;\n            if (sortedElements[i + 1] && scrollTop > sortedElements[i + 1].offsetTop) continue;\n            return $scrollspy.$activateElement(sortedElements[i]);\n          }\n\n        };\n\n        $scrollspy.checkPositionWithEventLoop = function () {\n          // IE 9 throws an error if we use 'this' instead of '$scrollspy'\n          // in this setTimeout call\n          setTimeout($scrollspy.checkPosition, 1);\n        };\n\n        // Protected methods\n\n        $scrollspy.$activateElement = function (element) {\n          if (activeTarget) {\n            var activeElement = $scrollspy.$getTrackedElement(activeTarget);\n            if (activeElement) {\n              activeElement.source.removeClass('active');\n              if (nodeName(activeElement.source, 'li') && nodeName(activeElement.source.parent().parent(), 'li')) {\n                activeElement.source.parent().parent().removeClass('active');\n              }\n            }\n          }\n          activeTarget = element.target;\n          element.source.addClass('active');\n          if (nodeName(element.source, 'li') && nodeName(element.source.parent().parent(), 'li')) {\n            element.source.parent().parent().addClass('active');\n          }\n        };\n\n        $scrollspy.$getTrackedElement = function (target) {\n          return trackedElements.filter(function (obj) {\n            return obj.target === target;\n          })[0];\n        };\n\n        // Track offsets behavior\n\n        $scrollspy.checkOffsets = function () {\n\n          angular.forEach(trackedElements, function (trackedElement) {\n            var targetElement = document.querySelector(trackedElement.target);\n            trackedElement.offsetTop = targetElement ? dimensions.offset(targetElement).top : null;\n            if (options.offset && trackedElement.offsetTop !== null) trackedElement.offsetTop -= options.offset * 1;\n          });\n\n          sortedElements = trackedElements\n          .filter(function (el) {\n            return el.offsetTop !== null;\n          })\n          .sort(function (a, b) {\n            return a.offsetTop - b.offsetTop;\n          });\n\n          debouncedCheckPosition();\n\n        };\n\n        $scrollspy.trackElement = function (target, source) {\n          trackedElements.push({target: target, source: source});\n        };\n\n        $scrollspy.untrackElement = function (target, source) {\n          var toDelete;\n          for (var i = trackedElements.length; i--;) {\n            if (trackedElements[i].target === target && trackedElements[i].source === source) {\n              toDelete = i;\n              break;\n            }\n          }\n          trackedElements.splice(toDelete, 1);\n        };\n\n        $scrollspy.activate = function (i) {\n          trackedElements[i].addClass('active');\n        };\n\n        // Initialize plugin\n\n        $scrollspy.init();\n        return $scrollspy;\n\n      }\n\n      return ScrollSpyFactory;\n\n    };\n\n  })\n\n  .directive('bsScrollspy', function ($rootScope, debounce, dimensions, $scrollspy) {\n\n    return {\n      restrict: 'EAC',\n      link: function postLink(scope, element, attr) {\n\n        var options = {scope: scope};\n        angular.forEach(['offset', 'target'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        var scrollspy = $scrollspy(options);\n        scrollspy.trackElement(options.target, element);\n\n        scope.$on('$destroy', function () {\n          if (scrollspy) {\n            scrollspy.untrackElement(options.target, element);\n            scrollspy.destroy();\n          }\n          options = null;\n          scrollspy = null;\n        });\n\n      }\n    };\n\n  })\n\n\n  .directive('bsScrollspyList', function ($rootScope, debounce, dimensions, $scrollspy) {\n\n    return {\n      restrict: 'A',\n      compile: function postLink(element, attr) {\n        var children = element[0].querySelectorAll('li > a[href]');\n        angular.forEach(children, function (child) {\n          var childEl = angular.element(child);\n          childEl.parent().attr('bs-scrollspy', '').attr('data-target', childEl.attr('href'));\n        });\n      }\n\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.select', ['mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions'])\n\n  .provider('$select', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'select',\n      prefixEvent: '$select',\n      placement: 'bottom-left',\n      templateUrl: 'select/select.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      multiple: false,\n      allNoneButtons: false,\n      sort: true,\n      caretHtml: '&nbsp;<span class=\"caret\"></span>',\n      placeholder: 'Choose among the following...',\n      allText: 'All',\n      noneText: 'None',\n      maxLength: 3,\n      maxLengthHtml: 'selected',\n      iconCheckmark: 'glyphicon glyphicon-ok'\n    };\n\n    this.$get = function ($window, $document, $rootScope, $tooltip, $timeout) {\n\n      // var bodyEl = angular.element($window.document.body);\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n\n      function SelectFactory(element, controller, config) {\n\n        var $select = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $select = $tooltip(element, options);\n        var scope = $select.$scope;\n\n        scope.$matches = [];\n        if (options.multiple) {\n          scope.$activeIndex = [];\n        } else {\n          scope.$activeIndex = -1;\n        }\n        scope.$isMultiple = options.multiple;\n        scope.$showAllNoneButtons = options.allNoneButtons && options.multiple;\n        scope.$iconCheckmark = options.iconCheckmark;\n        scope.$allText = options.allText;\n        scope.$noneText = options.noneText;\n\n        scope.$activate = function (index) {\n          scope.$$postDigest(function () {\n            $select.activate(index);\n          });\n        };\n\n        scope.$select = function (index, evt) {\n          scope.$$postDigest(function () {\n            $select.select(index);\n          });\n        };\n\n        scope.$isVisible = function () {\n          return $select.$isVisible();\n        };\n\n        scope.$isActive = function (index) {\n          return $select.$isActive(index);\n        };\n\n        scope.$selectAll = function () {\n          for (var i = 0; i < scope.$matches.length; i++) {\n            if (!scope.$isActive(i)) {\n              scope.$select(i);\n            }\n          }\n        };\n\n        scope.$selectNone = function () {\n          for (var i = 0; i < scope.$matches.length; i++) {\n            if (scope.$isActive(i)) {\n              scope.$select(i);\n            }\n          }\n        };\n\n        // Public methods\n\n        $select.update = function (matches) {\n          scope.$matches = matches;\n          $select.$updateActiveIndex();\n        };\n\n        $select.activate = function (index) {\n          if (options.multiple) {\n            if ($select.$isActive(index)) {\n              scope.$activeIndex.splice(scope.$activeIndex.indexOf(index), 1);\n            } else {\n              scope.$activeIndex.push(index);\n            }\n            if (options.sort) scope.$activeIndex.sort(function (a, b) { return a - b; }); // use numeric sort instead of default sort\n          } else {\n            scope.$activeIndex = index;\n          }\n          return scope.$activeIndex;\n        };\n\n        $select.select = function (index) {\n          var value = scope.$matches[index].value;\n          scope.$apply(function () {\n            $select.activate(index);\n            if (options.multiple) {\n              controller.$setViewValue(scope.$activeIndex.map(function (index) {\n                if (angular.isUndefined(scope.$matches[index])) {\n                  return null;\n                }\n                return scope.$matches[index].value;\n              }));\n            } else {\n              controller.$setViewValue(value);\n              // Hide if single select\n              $select.hide();\n            }\n          });\n          // Emit event\n          scope.$emit(options.prefixEvent + '.select', value, index, $select);\n        };\n\n        // Protected methods\n\n        $select.$updateActiveIndex = function () {\n          if (options.multiple) {\n            if (angular.isArray(controller.$modelValue)) {\n              scope.$activeIndex = controller.$modelValue.map(function (value) {\n                return $select.$getIndex(value);\n              });\n            } else {\n              scope.$activeIndex = [];\n            }\n          } else {\n            if (angular.isDefined(controller.$modelValue) && scope.$matches.length) {\n              scope.$activeIndex = $select.$getIndex(controller.$modelValue);\n            } else {\n              scope.$activeIndex = -1;\n            }\n          }\n        };\n\n        $select.$isVisible = function () {\n          if (!options.minLength || !controller) {\n            return scope.$matches.length;\n          }\n          // minLength support\n          return scope.$matches.length && controller.$viewValue.length >= options.minLength;\n        };\n\n        $select.$isActive = function (index) {\n          if (options.multiple) {\n            return scope.$activeIndex.indexOf(index) !== -1;\n          }\n          return scope.$activeIndex === index;\n        };\n\n        $select.$getIndex = function (value) {\n          var index;\n          for (index = scope.$matches.length; index--;) {\n            if (angular.equals(scope.$matches[index].value, value)) break;\n          }\n          return index;\n        };\n\n        $select.$onMouseDown = function (evt) {\n          // Prevent blur on mousedown on .dropdown-menu\n          evt.preventDefault();\n          evt.stopPropagation();\n          // Emulate click for mobile devices\n          if (isTouch) {\n            var targetEl = angular.element(evt.target);\n            targetEl.triggerHandler('click');\n          }\n        };\n\n        $select.$onKeyDown = function (evt) {\n          if (!/(9|13|38|40)/.test(evt.keyCode)) return;\n          // Let tab propagate\n          if (evt.keyCode !== 9) {\n            evt.preventDefault();\n            evt.stopPropagation();\n          }\n\n          // release focus on tab\n          if (options.multiple && evt.keyCode === 9) {\n            return $select.hide();\n          }\n\n          // Select with enter\n          if (!options.multiple && (evt.keyCode === 13 || evt.keyCode === 9)) {\n            return $select.select(scope.$activeIndex);\n          }\n\n          if (!options.multiple) {\n            // Navigate with keyboard\n            if (evt.keyCode === 38 && scope.$activeIndex > 0) scope.$activeIndex--;\n            else if (evt.keyCode === 38 && scope.$activeIndex < 0) scope.$activeIndex = scope.$matches.length - 1;\n            else if (evt.keyCode === 40 && scope.$activeIndex < scope.$matches.length - 1) scope.$activeIndex++;\n            else if (angular.isUndefined(scope.$activeIndex)) scope.$activeIndex = 0;\n            scope.$digest();\n          }\n        };\n\n        $select.$isIE = function () {\n          var ua = $window.navigator.userAgent;\n          return ua.indexOf('MSIE ') > 0 || ua.indexOf('Trident/') > 0 || ua.indexOf('Edge/') > 0;\n        };\n\n        $select.$selectScrollFix = function (e) {\n          if ($document[0].activeElement.tagName === 'UL') {\n            e.preventDefault();\n            e.stopImmediatePropagation();\n            e.target.focus();\n          }\n        };\n\n        // Overrides\n\n        var _show = $select.show;\n        $select.show = function () {\n          _show();\n          if (options.multiple) {\n            $select.$element.addClass('select-multiple');\n          }\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function () {\n            $select.$element.on(isTouch ? 'touchstart' : 'mousedown', $select.$onMouseDown);\n            if (options.keyboard) {\n              element.on('keydown', $select.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var _hide = $select.hide;\n        $select.hide = function () {\n          if (!options.multiple && angular.isUndefined(controller.$modelValue)) {\n            scope.$activeIndex = -1;\n          }\n          $select.$element.off(isTouch ? 'touchstart' : 'mousedown', $select.$onMouseDown);\n          if (options.keyboard) {\n            element.off('keydown', $select.$onKeyDown);\n          }\n          _hide(true);\n        };\n\n        return $select;\n\n      }\n\n      SelectFactory.defaults = defaults;\n      return SelectFactory;\n\n    };\n\n  })\n\n  .directive('bsSelect', function ($window, $parse, $q, $select, $parseOptions) {\n\n    var defaults = $select.defaults;\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = {scope: scope, placeholder: defaults.placeholder};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'placeholder', 'allNoneButtons', 'maxLength', 'maxLengthHtml', 'allText', 'noneText', 'iconCheckmark', 'autoClose', 'id', 'sort', 'caretHtml', 'prefixClass', 'prefixEvent'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'allNoneButtons', 'sort'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\n            options[key] = false;\n          }\n        });\n\n        // Only parse data-multiple. Angular sets existence attributes to true (multiple/required/etc), they apply this\n        // to data-multiple as well for some reason, so we'll parse this ourselves and disregard multiple\n        var dataMultiple = element.attr('data-multiple');\n        if (angular.isDefined(dataMultiple)) {\n          if (falseValueRegExp.test(dataMultiple)) {\n            options.multiple = false;\n          } else {\n            options.multiple = dataMultiple;\n          }\n        }\n\n        // Add support for select markup\n        if (element[0].nodeName.toLowerCase() === 'select') {\n          var inputEl = element;\n          inputEl.css('display', 'none');\n          element = angular.element('<button type=\"button\" class=\"btn btn-default\"></button>');\n          inputEl.after(element);\n        }\n\n        // Build proper bsOptions\n        var parsedOptions = $parseOptions(attr.bsOptions);\n\n        // Initialize select\n        var select = $select(element, controller, options);\n\n        if (select.$isIE()) {\n          element[0].addEventListener('blur', select.$selectScrollFix);\n        }\n\n        // Watch bsOptions values before filtering for changes\n        var watchedOptions = parsedOptions.$match[7].replace(/\\|.+/, '').trim();\n        scope.$watch(watchedOptions, function (newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', watchedOptions, newValue, oldValue);\n          parsedOptions.valuesFn(scope, controller)\n          .then(function (values) {\n            select.update(values);\n            controller.$render();\n          });\n        }, true);\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', attr.ngModel, newValue, oldValue);\n          select.$updateActiveIndex();\n          controller.$render();\n        }, true);\n\n        // Model rendering in view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          var selected;\n          var index;\n          if (options.multiple && angular.isArray(controller.$modelValue)) {\n            selected = controller.$modelValue.map(function (value) {\n              index = select.$getIndex(value);\n              return index !== -1 ? select.$scope.$matches[index].label : false;\n            }).filter(angular.isDefined);\n            if (selected.length > (options.maxLength || defaults.maxLength)) {\n              selected = selected.length + ' ' + (options.maxLengthHtml || defaults.maxLengthHtml);\n            } else {\n              selected = selected.join(', ');\n            }\n          } else {\n            index = select.$getIndex(controller.$modelValue);\n            selected = index !== -1 ? select.$scope.$matches[index].label : false;\n          }\n          element.html((selected ? selected : options.placeholder) + (options.caretHtml ? options.caretHtml : defaults.caretHtml));\n        };\n\n        if (options.multiple) {\n          controller.$isEmpty = function (value) {\n            return !value || value.length === 0;\n          };\n        }\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (select) select.destroy();\n          options = null;\n          select = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.datepicker', [\n  'mgcrea.ngStrap.helpers.dateParser',\n  'mgcrea.ngStrap.helpers.dateFormatter',\n  'mgcrea.ngStrap.tooltip'])\n\n  .provider('$datepicker', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      // Uncommenting the following line will break backwards compatability\n      // prefixEvent: 'datepicker',\n      prefixClass: 'datepicker',\n      placement: 'bottom-left',\n      templateUrl: 'datepicker/datepicker.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      // lang: $locale.id,\n      useNative: false,\n      dateType: 'date',\n      dateFormat: 'shortDate',\n      timezone: null,\n      modelDateFormat: null,\n      dayFormat: 'dd',\n      monthFormat: 'MMM',\n      yearFormat: 'yyyy',\n      monthTitleFormat: 'MMMM yyyy',\n      yearTitleFormat: 'yyyy',\n      strictFormat: false,\n      autoclose: false,\n      minDate: -Infinity,\n      maxDate: +Infinity,\n      startView: 0,\n      minView: 0,\n      startWeek: 0,\n      daysOfWeekDisabled: '',\n      iconLeft: 'glyphicon glyphicon-chevron-left',\n      iconRight: 'glyphicon glyphicon-chevron-right'\n    };\n\n    this.$get = function ($window, $document, $rootScope, $sce, $dateFormatter, datepickerViews, $tooltip, $timeout) {\n\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n      if (!defaults.lang) defaults.lang = $dateFormatter.getDefaultLocale();\n\n      function DatepickerFactory(element, controller, config) {\n\n        var $datepicker = $tooltip(element, angular.extend({}, defaults, config));\n        var parentScope = config.scope;\n        var options = $datepicker.$options;\n        var scope = $datepicker.$scope;\n        if (options.startView) options.startView -= options.minView;\n\n        // View vars\n\n        var pickerViews = datepickerViews($datepicker);\n        $datepicker.$views = pickerViews.views;\n        var viewDate = pickerViews.viewDate;\n        scope.$mode = options.startView;\n        scope.$iconLeft = options.iconLeft;\n        scope.$iconRight = options.iconRight;\n        var $picker = $datepicker.$views[scope.$mode];\n\n        // Scope methods\n\n        scope.$select = function (date) {\n          $datepicker.select(date);\n        };\n        scope.$selectPane = function (value) {\n          $datepicker.$selectPane(value);\n        };\n        scope.$toggleMode = function () {\n          $datepicker.setMode((scope.$mode + 1) % $datepicker.$views.length);\n        };\n\n        // Public methods\n\n        $datepicker.update = function (date) {\n          // console.warn('$datepicker.update() newValue=%o', date);\n          if (angular.isDate(date) && !isNaN(date.getTime())) {\n            $datepicker.$date = date;\n            $picker.update.call($picker, date);\n          }\n          // Build only if pristine\n          $datepicker.$build(true);\n        };\n\n        $datepicker.updateDisabledDates = function (dateRanges) {\n          options.disabledDateRanges = dateRanges;\n          for (var i = 0, l = scope.rows.length; i < l; i++) {\n            angular.forEach(scope.rows[i], $datepicker.$setDisabledEl);\n          }\n        };\n\n        $datepicker.select = function (date, keep) {\n          // console.warn('$datepicker.select', date, scope.$mode);\n          if (!angular.isDate(controller.$dateValue)) controller.$dateValue = new Date(date);\n          if (!scope.$mode || keep) {\n            controller.$setViewValue(angular.copy(date));\n            controller.$render();\n            if (options.autoclose && !keep) {\n              $timeout(function () { $datepicker.hide(true); });\n            }\n          } else {\n            angular.extend(viewDate, {year: date.getFullYear(), month: date.getMonth(), date: date.getDate()});\n            $datepicker.setMode(scope.$mode - 1);\n            $datepicker.$build();\n          }\n        };\n\n        $datepicker.setMode = function (mode) {\n          // console.warn('$datepicker.setMode', mode);\n          scope.$mode = mode;\n          $picker = $datepicker.$views[scope.$mode];\n          $datepicker.$build();\n        };\n\n        // Protected methods\n\n        $datepicker.$build = function (pristine) {\n          // console.warn('$datepicker.$build() viewDate=%o', viewDate);\n          if (pristine === true && $picker.built) return;\n          if (pristine === false && !$picker.built) return;\n          $picker.build.call($picker);\n        };\n\n        $datepicker.$updateSelected = function () {\n          for (var i = 0, l = scope.rows.length; i < l; i++) {\n            angular.forEach(scope.rows[i], updateSelected);\n          }\n        };\n\n        $datepicker.$isSelected = function (date) {\n          return $picker.isSelected(date);\n        };\n\n        $datepicker.$setDisabledEl = function (el) {\n          el.disabled = $picker.isDisabled(el.date);\n        };\n\n        $datepicker.$selectPane = function (value) {\n          var steps = $picker.steps;\n          // set targetDate to first day of month to avoid problems with\n          // date values rollover. This assumes the viewDate does not\n          // depend on the day of the month\n          var targetDate = new Date(Date.UTC(viewDate.year + ((steps.year || 0) * value), viewDate.month + ((steps.month || 0) * value), 1));\n          angular.extend(viewDate, {year: targetDate.getUTCFullYear(), month: targetDate.getUTCMonth(), date: targetDate.getUTCDate()});\n          $datepicker.$build();\n        };\n\n        $datepicker.$onMouseDown = function (evt) {\n          // Prevent blur on mousedown on .dropdown-menu\n          evt.preventDefault();\n          evt.stopPropagation();\n          // Emulate click for mobile devices\n          if (isTouch) {\n            var targetEl = angular.element(evt.target);\n            if (targetEl[0].nodeName.toLowerCase() !== 'button') {\n              targetEl = targetEl.parent();\n            }\n            targetEl.triggerHandler('click');\n          }\n        };\n\n        $datepicker.$onKeyDown = function (evt) {\n          if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          if (evt.keyCode === 13) {\n            if (!scope.$mode) {\n              $datepicker.hide(true);\n            } else {\n              scope.$apply(function () { $datepicker.setMode(scope.$mode - 1); });\n            }\n            return;\n          }\n\n          // Navigate with keyboard\n          $picker.onKeyDown(evt);\n          parentScope.$digest();\n        };\n\n        // Private\n\n        function updateSelected(el) {\n          el.selected = $datepicker.$isSelected(el.date);\n        }\n\n        function focusElement() {\n          element[0].focus();\n        }\n\n        // Overrides\n\n        var _init = $datepicker.init;\n        $datepicker.init = function () {\n          if (isNative && options.useNative) {\n            element.prop('type', 'date');\n            element.css('-webkit-appearance', 'textfield');\n            return;\n          } else if (isTouch) {\n            element.prop('type', 'text');\n            element.attr('readonly', 'true');\n            element.on('click', focusElement);\n          }\n          _init();\n        };\n\n        var _destroy = $datepicker.destroy;\n        $datepicker.destroy = function () {\n          if (isNative && options.useNative) {\n            element.off('click', focusElement);\n          }\n          _destroy();\n        };\n\n        var _show = $datepicker.show;\n        $datepicker.show = function () {\n          if ((!isTouch && element.attr('readonly')) || element.attr('disabled')) return;\n          _show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function () {\n            // if $datepicker is no longer showing, don't setup events\n            if (!$datepicker.$isShown) return;\n            $datepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);\n            if (options.keyboard) {\n              element.on('keydown', $datepicker.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var _hide = $datepicker.hide;\n        $datepicker.hide = function (blur) {\n          if (!$datepicker.$isShown) return;\n          $datepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);\n          if (options.keyboard) {\n            element.off('keydown', $datepicker.$onKeyDown);\n          }\n          _hide(blur);\n        };\n\n        return $datepicker;\n\n      }\n\n      DatepickerFactory.defaults = defaults;\n      return DatepickerFactory;\n\n    };\n\n  })\n\n  .directive('bsDatepicker', function ($window, $parse, $q, $dateFormatter, $dateParser, $datepicker) {\n\n    // var defaults = $datepicker.defaults;\n    var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'autoclose', 'dateType', 'dateFormat', 'timezone', 'modelDateFormat', 'dayFormat', 'strictFormat', 'startWeek', 'startDate', 'useNative', 'lang', 'startView', 'minView', 'iconLeft', 'iconRight', 'daysOfWeekDisabled', 'id', 'prefixClass', 'prefixEvent'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'autoclose', 'useNative'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\n            options[key] = false;\n          }\n        });\n\n        // Initialize datepicker\n        var datepicker = $datepicker(element, controller, options);\n        options = datepicker.$options;\n        // Set expected iOS format\n        if (isNative && options.useNative) options.dateFormat = 'yyyy-MM-dd';\n\n        var lang = options.lang;\n\n        var formatDate = function (date, format) {\n          return $dateFormatter.formatDate(date, format, lang);\n        };\n\n        var dateParser = $dateParser({format: options.dateFormat, lang: lang, strict: options.strictFormat});\n\n        // Visibility binding support\n        if (attr.bsShow) {\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\n            if (!datepicker || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(datepicker),?/i);\n            if (newValue === true) {\n              datepicker.show();\n            } else {\n              datepicker.hide();\n            }\n          });\n        }\n\n        // Observe attributes for changes\n        angular.forEach(['minDate', 'maxDate'], function (key) {\n          // console.warn('attr.$observe(%s)', key, attr[key]);\n          if (angular.isDefined(attr[key])) {\n            attr.$observe(key, function (newValue) {\n              // console.warn('attr.$observe(%s)=%o', key, newValue);\n              datepicker.$options[key] = dateParser.getDateForAttribute(key, newValue);\n              // Build only if dirty\n              if (!isNaN(datepicker.$options[key])) datepicker.$build(false);\n              validateAgainstMinMaxDate(controller.$dateValue);\n            });\n          }\n        });\n\n        // Observe date format\n        if (angular.isDefined(attr.dateFormat)) {\n          attr.$observe('dateFormat', function (newValue) {\n            datepicker.$options.dateFormat = newValue;\n          });\n        }\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\n          datepicker.update(controller.$dateValue);\n        }, true);\n\n        // Normalize undefined/null/empty array,\n        // so that we don't treat changing from undefined->null as a change.\n        function normalizeDateRanges(ranges) {\n          if (!ranges || !ranges.length) return null;\n          return ranges;\n        }\n\n        if (angular.isDefined(attr.disabledDates)) {\n          scope.$watch(attr.disabledDates, function (disabledRanges, previousValue) {\n            disabledRanges = normalizeDateRanges(disabledRanges);\n            previousValue = normalizeDateRanges(previousValue);\n\n            if (disabledRanges) {\n              datepicker.updateDisabledDates(disabledRanges);\n            }\n          });\n        }\n\n        function validateAgainstMinMaxDate(parsedDate) {\n          if (!angular.isDate(parsedDate)) return;\n          var isMinValid = isNaN(datepicker.$options.minDate) || parsedDate.getTime() >= datepicker.$options.minDate;\n          var isMaxValid = isNaN(datepicker.$options.maxDate) || parsedDate.getTime() <= datepicker.$options.maxDate;\n          var isValid = isMinValid && isMaxValid;\n          controller.$setValidity('date', isValid);\n          controller.$setValidity('min', isMinValid);\n          controller.$setValidity('max', isMaxValid);\n          // Only update the model when we have a valid date\n          if (isValid) controller.$dateValue = parsedDate;\n        }\n\n        // viewValue -> $parsers -> modelValue\n        controller.$parsers.unshift(function (viewValue) {\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\n          var date;\n          // Null values should correctly reset the model value & validity\n          if (!viewValue) {\n            controller.$setValidity('date', true);\n            // BREAKING CHANGE:\n            // return null (not undefined) when input value is empty, so angularjs 1.3\n            // ngModelController can go ahead and run validators, like ngRequired\n            return null;\n          }\n          var parsedDate = dateParser.parse(viewValue, controller.$dateValue);\n          if (!parsedDate || isNaN(parsedDate.getTime())) {\n            controller.$setValidity('date', false);\n            // return undefined, causes ngModelController to\n            // invalidate model value\n            return;\n          }\n          validateAgainstMinMaxDate(parsedDate);\n\n          if (options.dateType === 'string') {\n            date = dateParser.timezoneOffsetAdjust(parsedDate, options.timezone, true);\n            return formatDate(date, options.modelDateFormat || options.dateFormat);\n          }\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\n          if (options.dateType === 'number') {\n            return date.getTime();\n          } else if (options.dateType === 'unix') {\n            return date.getTime() / 1000;\n          } else if (options.dateType === 'iso') {\n            return date.toISOString();\n          }\n          return new Date(date);\n        });\n\n        // modelValue -> $formatters -> viewValue\n        controller.$formatters.push(function (modelValue) {\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n          var date;\n          if (angular.isUndefined(modelValue) || modelValue === null) {\n            date = NaN;\n          } else if (angular.isDate(modelValue)) {\n            date = modelValue;\n          } else if (options.dateType === 'string') {\n            date = dateParser.parse(modelValue, null, options.modelDateFormat);\n          } else if (options.dateType === 'unix') {\n            date = new Date(modelValue * 1000);\n          } else {\n            date = new Date(modelValue);\n          }\n          // Setup default value?\n          // if (isNaN(date.getTime())) {\n          //   var today = new Date();\n          //   date = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0, 0);\n          // }\n          controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\n          return getDateFormattedString();\n        });\n\n        // viewValue -> element\n        controller.$render = function () {\n          // console.warn('$render(\"%s\"): viewValue=%o', element.attr('ng-model'), controller.$viewValue);\n          element.val(getDateFormattedString());\n        };\n\n        function getDateFormattedString() {\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.dateFormat);\n        }\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (datepicker) datepicker.destroy();\n          options = null;\n          datepicker = null;\n        });\n\n      }\n    };\n\n  })\n\n  .provider('datepickerViews', function () {\n\n    // var defaults = this.defaults = {\n    //   dayFormat: 'dd',\n    //   daySplit: 7\n    // };\n\n    // Split array into smaller arrays\n    function split(arr, size) {\n      var arrays = [];\n      while (arr.length > 0) {\n        arrays.push(arr.splice(0, size));\n      }\n      return arrays;\n    }\n\n    // Modulus operator\n    function mod(n, m) {\n      return ((n % m) + m) % m;\n    }\n\n    this.$get = function ($dateFormatter, $dateParser, $sce) {\n\n      return function (picker) {\n\n        var scope = picker.$scope;\n        var options = picker.$options;\n\n        var lang = options.lang;\n        var formatDate = function (date, format) {\n          return $dateFormatter.formatDate(date, format, lang);\n        };\n        var dateParser = $dateParser({format: options.dateFormat, lang: lang, strict: options.strictFormat});\n\n        var weekDaysMin = $dateFormatter.weekdaysShort(lang);\n        var weekDaysLabels = weekDaysMin.slice(options.startWeek).concat(weekDaysMin.slice(0, options.startWeek));\n        var weekDaysLabelsHtml = $sce.trustAsHtml('<th class=\"dow text-center\">' + weekDaysLabels.join('</th><th class=\"dow text-center\">') + '</th>');\n\n        var startDate = picker.$date || (options.startDate ? dateParser.getDateForAttribute('startDate', options.startDate) : new Date());\n        var viewDate = {year: startDate.getFullYear(), month: startDate.getMonth(), date: startDate.getDate()};\n\n        var views = [{\n          format: options.dayFormat,\n          split: 7,\n          steps: {month: 1},\n          update: function (date, force) {\n            if (!this.built || force || date.getFullYear() !== viewDate.year || date.getMonth() !== viewDate.month) {\n              angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n              picker.$build();\n            } else if (date.getDate() !== viewDate.date || date.getDate() === 1) {\n                // chaging picker current month will cause viewDate.date to be set to first day of the month,\n                // in $datepicker.$selectPane, so picker would not update selected day display if\n                // user picks first day of the new month.\n                // As a workaround, we are always forcing update when picked date is first day of month.\n              viewDate.date = picker.$date.getDate();\n              picker.$updateSelected();\n            }\n          },\n          build: function () {\n            var firstDayOfMonth = new Date(viewDate.year, viewDate.month, 1);\n            var firstDayOfMonthOffset = firstDayOfMonth.getTimezoneOffset();\n            var firstDate = new Date(+firstDayOfMonth - mod(firstDayOfMonth.getDay() - options.startWeek, 7) * 864e5);\n            var firstDateOffset = firstDate.getTimezoneOffset();\n            var today = dateParser.timezoneOffsetAdjust(new Date(), options.timezone).toDateString();\n              // Handle daylight time switch\n            if (firstDateOffset !== firstDayOfMonthOffset) firstDate = new Date(+firstDate + (firstDateOffset - firstDayOfMonthOffset) * 60e3);\n            var days = [];\n            var day;\n            for (var i = 0; i < 42; i++) { // < 7 * 6\n              day = dateParser.daylightSavingAdjust(new Date(firstDate.getFullYear(), firstDate.getMonth(), firstDate.getDate() + i));\n              days.push({date: day, isToday: day.toDateString() === today, label: formatDate(day, this.format), selected: picker.$date && this.isSelected(day), muted: day.getMonth() !== viewDate.month, disabled: this.isDisabled(day)});\n            }\n            scope.title = formatDate(firstDayOfMonth, options.monthTitleFormat);\n            scope.showLabels = true;\n            scope.labels = weekDaysLabelsHtml;\n            scope.rows = split(days, this.split);\n            this.built = true;\n          },\n          isSelected: function (date) {\n            return picker.$date && date.getFullYear() === picker.$date.getFullYear() && date.getMonth() === picker.$date.getMonth() && date.getDate() === picker.$date.getDate();\n          },\n          isDisabled: function (date) {\n            var time = date.getTime();\n\n              // Disabled because of min/max date.\n            if (time < options.minDate || time > options.maxDate) return true;\n\n              // Disabled due to being a disabled day of the week\n            if (options.daysOfWeekDisabled.indexOf(date.getDay()) !== -1) return true;\n\n              // Disabled because of disabled date range.\n            if (options.disabledDateRanges) {\n              for (var i = 0; i < options.disabledDateRanges.length; i++) {\n                if (time >= options.disabledDateRanges[i].start && time <= options.disabledDateRanges[i].end) {\n                  return true;\n                }\n              }\n            }\n\n            return false;\n          },\n          onKeyDown: function (evt) {\n            if (!picker.$date) {\n              return;\n            }\n            var actualTime = picker.$date.getTime();\n            var newDate;\n\n            if (evt.keyCode === 37) newDate = new Date(actualTime - 1 * 864e5);\n              else if (evt.keyCode === 38) newDate = new Date(actualTime - 7 * 864e5);\n              else if (evt.keyCode === 39) newDate = new Date(actualTime + 1 * 864e5);\n              else if (evt.keyCode === 40) newDate = new Date(actualTime + 7 * 864e5);\n\n            if (!this.isDisabled(newDate)) picker.select(newDate, true);\n          }\n        }, {\n          name: 'month',\n          format: options.monthFormat,\n          split: 4,\n          steps: {year: 1},\n          update: function (date, force) {\n            if (!this.built || date.getFullYear() !== viewDate.year) {\n              angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n              picker.$build();\n            } else if (date.getMonth() !== viewDate.month) {\n              angular.extend(viewDate, {month: picker.$date.getMonth(), date: picker.$date.getDate()});\n              picker.$updateSelected();\n            }\n          },\n          build: function () {\n            // var firstMonth = new Date(viewDate.year, 0, 1);\n            var months = [];\n            var month;\n            for (var i = 0; i < 12; i++) {\n              month = new Date(viewDate.year, i, 1);\n              months.push({date: month, label: formatDate(month, this.format), selected: picker.$isSelected(month), disabled: this.isDisabled(month)});\n            }\n            scope.title = formatDate(month, options.yearTitleFormat);\n            scope.showLabels = false;\n            scope.rows = split(months, this.split);\n            this.built = true;\n          },\n          isSelected: function (date) {\n            return picker.$date && date.getFullYear() === picker.$date.getFullYear() && date.getMonth() === picker.$date.getMonth();\n          },\n          isDisabled: function (date) {\n            var lastDate = +new Date(date.getFullYear(), date.getMonth() + 1, 0);\n            return lastDate < options.minDate || date.getTime() > options.maxDate;\n          },\n          onKeyDown: function (evt) {\n            if (!picker.$date) {\n              return;\n            }\n            var actualMonth = picker.$date.getMonth();\n            var newDate = new Date(picker.$date);\n\n            if (evt.keyCode === 37) newDate.setMonth(actualMonth - 1);\n              else if (evt.keyCode === 38) newDate.setMonth(actualMonth - 4);\n              else if (evt.keyCode === 39) newDate.setMonth(actualMonth + 1);\n              else if (evt.keyCode === 40) newDate.setMonth(actualMonth + 4);\n\n            if (!this.isDisabled(newDate)) picker.select(newDate, true);\n          }\n        }, {\n          name: 'year',\n          format: options.yearFormat,\n          split: 4,\n          steps: {year: 12},\n          update: function (date, force) {\n            if (!this.built || force || parseInt(date.getFullYear() / 20, 10) !== parseInt(viewDate.year / 20, 10)) {\n              angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n              picker.$build();\n            } else if (date.getFullYear() !== viewDate.year) {\n              angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n              picker.$updateSelected();\n            }\n          },\n          build: function () {\n            var firstYear = viewDate.year - viewDate.year % (this.split * 3);\n            var years = [];\n            var year;\n            for (var i = 0; i < 12; i++) {\n              year = new Date(firstYear + i, 0, 1);\n              years.push({date: year, label: formatDate(year, this.format), selected: picker.$isSelected(year), disabled: this.isDisabled(year)});\n            }\n            scope.title = years[0].label + '-' + years[years.length - 1].label;\n            scope.showLabels = false;\n            scope.rows = split(years, this.split);\n            this.built = true;\n          },\n          isSelected: function (date) {\n            return picker.$date && date.getFullYear() === picker.$date.getFullYear();\n          },\n          isDisabled: function (date) {\n            var lastDate = +new Date(date.getFullYear() + 1, 0, 0);\n            return lastDate < options.minDate || date.getTime() > options.maxDate;\n          },\n          onKeyDown: function (evt) {\n            if (!picker.$date) {\n              return;\n            }\n            var actualYear = picker.$date.getFullYear();\n            var newDate = new Date(picker.$date);\n\n            if (evt.keyCode === 37) newDate.setYear(actualYear - 1);\n              else if (evt.keyCode === 38) newDate.setYear(actualYear - 4);\n              else if (evt.keyCode === 39) newDate.setYear(actualYear + 1);\n              else if (evt.keyCode === 40) newDate.setYear(actualYear + 4);\n\n            if (!this.isDisabled(newDate)) picker.select(newDate, true);\n          }\n        }];\n\n        return {\n          views: options.minView ? Array.prototype.slice.call(views, options.minView) : views,\n          viewDate: viewDate\n        };\n\n      };\n\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.modal', ['mgcrea.ngStrap.core', 'mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$modal', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      backdropAnimation: 'am-fade',\n      customClass: '',\n      prefixClass: 'modal',\n      prefixEvent: 'modal',\n      placement: 'top',\n      templateUrl: 'modal/modal.tpl.html',\n      template: '',\n      contentTemplate: false,\n      container: false,\n      element: null,\n      backdrop: true,\n      keyboard: true,\n      html: false,\n      show: true\n    };\n\n    this.$get = function ($window, $rootScope, $bsCompiler, $animate, $timeout, $sce, dimensions) {\n\n      var forEach = angular.forEach;\n      var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n      var bodyElement = angular.element($window.document.body);\n\n      var backdropCount = 0;\n      var dialogBaseZindex = 1050;\n      var backdropBaseZindex = 1040;\n\n      function ModalFactory(config) {\n\n        var $modal = {};\n\n        // Common vars\n        var options = $modal.$options = angular.extend({}, defaults, config);\n        var promise = $modal.$promise = $bsCompiler.compile(options);\n        var scope = $modal.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n\n        if (!options.element && !options.container) {\n          options.container = 'body';\n        }\n\n        // Store $id to identify the triggering element in events\n        // give priority to options.id, otherwise, try to use\n        // element id if defined\n        $modal.$id = options.id || options.element && options.element.attr('id') || '';\n\n        // Support scope as string options\n        forEach(['title', 'content'], function (key) {\n          if (options[key]) scope[key] = $sce.trustAsHtml(options[key]);\n        });\n\n        // Provide scope helpers\n        scope.$hide = function () {\n          scope.$$postDigest(function () {\n            $modal.hide();\n          });\n        };\n        scope.$show = function () {\n          scope.$$postDigest(function () {\n            $modal.show();\n          });\n        };\n        scope.$toggle = function () {\n          scope.$$postDigest(function () {\n            $modal.toggle();\n          });\n        };\n        // Publish isShown as a protected var on scope\n        $modal.$isShown = scope.$isShown = false;\n\n        // Fetch, compile then initialize modal\n        var compileData;\n        var modalElement;\n        var modalScope;\n        var backdropElement = angular.element('<div class=\"' + options.prefixClass + '-backdrop\"/>');\n        backdropElement.css({position: 'fixed', top: '0px', left: '0px', bottom: '0px', right: '0px'});\n        promise.then(function (data) {\n          compileData = data;\n          $modal.init();\n        });\n\n        $modal.init = function () {\n\n          // Options: show\n          if (options.show) {\n            scope.$$postDigest(function () {\n              $modal.show();\n            });\n          }\n\n        };\n\n        $modal.destroy = function () {\n\n          // Remove element\n          destroyModalElement();\n\n          // remove backdrop element\n          if (backdropElement) {\n            backdropElement.remove();\n            backdropElement = null;\n          }\n\n          // Destroy scope\n          scope.$destroy();\n        };\n\n        $modal.show = function () {\n          if ($modal.$isShown) return;\n          $rootScope.$emit('modal_fired', $modal.$isShown);\n          var parent;\n          var after;\n          if (angular.isElement(options.container)) {\n            parent = options.container;\n            after = options.container[0].lastChild ? angular.element(options.container[0].lastChild) : null;\n          } else {\n            if (options.container) {\n              parent = findElement(options.container);\n              after = parent[0] && parent[0].lastChild ? angular.element(parent[0].lastChild) : null;\n            } else {\n              parent = null;\n              after = options.element;\n            }\n          }\n\n          // destroy any existing modal elements\n          if (modalElement) destroyModalElement();\n\n          // create a new scope, so we can destroy it and all child scopes\n          // when destroying the modal element\n          modalScope = $modal.$scope.$new();\n          // Fetch a cloned element linked from template (noop callback is required)\n          modalElement = $modal.$element = compileData.link(modalScope, function (clonedElement, scope) {});\n\n          if (options.backdrop) {\n            // set z-index\n            modalElement.css({'z-index': dialogBaseZindex + (backdropCount * 20)});\n            backdropElement.css({'z-index': backdropBaseZindex + (backdropCount * 20)});\n\n            // increment number of backdrops\n            backdropCount++;\n          }\n\n          if (scope.$emit(options.prefixEvent + '.show.before', $modal).defaultPrevented) {\n            return;\n          }\n\n          // Set the initial positioning.\n          modalElement.css({display: 'block'}).addClass(options.placement);\n\n          // Options: customClass\n          if (options.customClass) {\n            modalElement.addClass(options.customClass);\n          }\n\n          // Options: animation\n          if (options.animation) {\n            if (options.backdrop) {\n              backdropElement.addClass(options.backdropAnimation);\n            }\n            modalElement.addClass(options.animation);\n          }\n\n          if (options.backdrop) {\n            $animate.enter(backdropElement, bodyElement, null);\n          }\n\n          // Support v1.2+ $animate\n          // https://github.com/angular/angular.js/issues/11713\n          if (angular.version.minor <= 2) {\n            $animate.enter(modalElement, parent, after, enterAnimateCallback);\n          } else {\n            $animate.enter(modalElement, parent, after).then(enterAnimateCallback);\n          }\n\n          $modal.$isShown = scope.$isShown = true;\n          safeDigest(scope);\n          // Focus once the enter-animation has started\n          // Weird PhantomJS bug hack\n          var el = modalElement[0];\n          requestAnimationFrame(function () {\n            el.focus();\n          });\n\n          bodyElement.addClass(options.prefixClass + '-open');\n          if (options.animation) {\n            bodyElement.addClass(options.prefixClass + '-with-' + options.animation);\n          }\n\n          // Bind events\n          bindBackdropEvents();\n          bindKeyboardEvents();\n        };\n\n        function enterAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.show', $modal);\n        }\n\n        $modal.hide = function () {\n          if (!$modal.$isShown) return;\n          $rootScope.$emit('modal_fired', $modal.$isShown);\n          if (options.backdrop) {\n            // decrement number of modals\n            backdropCount--;\n          }\n\n          if (scope.$emit(options.prefixEvent + '.hide.before', $modal).defaultPrevented) {\n            return;\n          }\n\n          // Support v1.2+ $animate\n          // https://github.com/angular/angular.js/issues/11713\n          if (angular.version.minor <= 2) {\n            $animate.leave(modalElement, leaveAnimateCallback);\n          } else {\n            $animate.leave(modalElement).then(leaveAnimateCallback);\n          }\n\n          if (options.backdrop) {\n            $animate.leave(backdropElement);\n          }\n          $modal.$isShown = scope.$isShown = false;\n          safeDigest(scope);\n\n          // Unbind events\n          unbindBackdropEvents();\n          unbindKeyboardEvents();\n        };\n\n        function leaveAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.hide', $modal);\n          bodyElement.removeClass(options.prefixClass + '-open');\n          if (options.animation) {\n            bodyElement.removeClass(options.prefixClass + '-with-' + options.animation);\n          }\n        }\n\n        $modal.toggle = function () {\n          if ($modal.$isShown) {\n            $modal.hide();\n          } else {\n            $modal.show();\n          }\n        };\n\n        $modal.focus = function () {\n          modalElement[0].focus();\n        };\n\n        // Protected methods\n\n        $modal.$onKeyUp = function (evt) {\n\n          if (evt.which === 27 && $modal.$isShown) {\n            $modal.hide();\n            evt.stopPropagation();\n          }\n\n        };\n\n        function bindBackdropEvents() {\n          if (options.backdrop) {\n            modalElement.on('click', hideOnBackdropClick);\n            backdropElement.on('click', hideOnBackdropClick);\n            backdropElement.on('wheel', preventEventDefault);\n          }\n        }\n\n        function unbindBackdropEvents() {\n          if (options.backdrop) {\n            modalElement.off('click', hideOnBackdropClick);\n            backdropElement.off('click', hideOnBackdropClick);\n            backdropElement.off('wheel', preventEventDefault);\n          }\n        }\n\n        function bindKeyboardEvents() {\n          if (options.keyboard) {\n            modalElement.on('keyup', $modal.$onKeyUp);\n          }\n        }\n\n        function unbindKeyboardEvents() {\n          if (options.keyboard) {\n            modalElement.off('keyup', $modal.$onKeyUp);\n          }\n        }\n\n        // Private helpers\n\n        function hideOnBackdropClick(evt) {\n          if (evt.target !== evt.currentTarget) return;\n          if (options.backdrop === 'static') {\n            $modal.focus();\n          } else {\n            $modal.hide();\n          }\n        }\n\n        function preventEventDefault(evt) {\n          evt.preventDefault();\n        }\n\n        function destroyModalElement() {\n          if ($modal.$isShown && modalElement !== null) {\n            // un-bind events\n            unbindBackdropEvents();\n            unbindKeyboardEvents();\n          }\n\n          if (modalScope) {\n            modalScope.$destroy();\n            modalScope = null;\n          }\n\n          if (modalElement) {\n            modalElement.remove();\n            modalElement = $modal.$element = null;\n          }\n        }\n\n        return $modal;\n\n      }\n\n      // Helper functions\n\n      function safeDigest(scope) {\n        /* eslint-disable no-unused-expressions */\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n        /* eslint-enable no-unused-expressions */\n      }\n\n      function findElement(query, element) {\n        return angular.element((element || document).querySelectorAll(query));\n      }\n\n      return ModalFactory;\n\n    };\n\n  })\n\n  .directive('bsModal', function ($window, $sce, $modal) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n\n        // Directive options\n        var options = {scope: scope, element: element, show: false};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'backdrop', 'keyboard', 'html', 'container', 'animation', 'backdropAnimation', 'id', 'prefixEvent', 'prefixClass', 'customClass', 'modalClass'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // Options: alias modalClass to customClass\n        if (options.modalClass) {\n          options.customClass = options.modalClass;\n        }\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['backdrop', 'keyboard', 'html', 'container'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\n        });\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content'], function (key) {\n          if (attr[key]) {\n            attr.$observe(key, function (newValue, oldValue) {\n              scope[key] = $sce.trustAsHtml(newValue);\n            });\n          }\n        });\n\n        // Support scope as an object\n        if (attr.bsModal) {\n          scope.$watch(attr.bsModal, function (newValue, oldValue) {\n            if (angular.isObject(newValue)) {\n              angular.extend(scope, newValue);\n            } else {\n              scope.content = newValue;\n            }\n          }, true);\n        }\n\n        // Initialize modal\n        var modal = $modal(options);\n\n        // Trigger\n        element.on(attr.trigger || 'click', modal.toggle);\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (modal) modal.destroy();\n          options = null;\n          modal = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.navbar', [])\n\n  .provider('$navbar', function () {\n\n    var defaults = this.defaults = {\n      activeClass: 'active',\n      routeAttr: 'data-match-route',\n      strict: false\n    };\n\n    this.$get = function () {\n      return {defaults: defaults};\n    };\n\n  })\n\n  .directive('bsNavbar', function ($window, $location, $navbar) {\n\n    var defaults = $navbar.defaults;\n\n    return {\n      restrict: 'A',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = angular.copy(defaults);\n        angular.forEach(Object.keys(defaults), function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // Watch for the $location\n        scope.$watch(function () {\n\n          return $location.path();\n\n        }, function (newValue, oldValue) {\n\n          var liElements = element[0].querySelectorAll('li[' + options.routeAttr + ']');\n\n          angular.forEach(liElements, function (li) {\n\n            var liElement = angular.element(li);\n            var pattern = liElement.attr(options.routeAttr).replace('/', '\\\\/');\n            if (options.strict) {\n              pattern = '^' + pattern + '$';\n            }\n            var regexp = new RegExp(pattern, 'i');\n\n            if (regexp.test(newValue)) {\n              liElement.addClass(options.activeClass);\n            } else {\n              liElement.removeClass(options.activeClass);\n            }\n\n          });\n\n        });\n\n      }\n\n    };\n\n  });\n","'use strict';\n\nif (angular.version.minor < 3 && angular.version.dot < 14) {\n  angular.module('ng')\n\n  .factory('$$rAF', function ($window, $timeout) {\n\n    var requestAnimationFrame = $window.requestAnimationFrame ||\n                                $window.webkitRequestAnimationFrame ||\n                                $window.mozRequestAnimationFrame;\n\n    var cancelAnimationFrame = $window.cancelAnimationFrame ||\n                               $window.webkitCancelAnimationFrame ||\n                               $window.mozCancelAnimationFrame ||\n                               $window.webkitCancelRequestAnimationFrame;\n\n    var rafSupported = !!requestAnimationFrame;\n    var raf = rafSupported ?\n      function (fn) {\n        var id = requestAnimationFrame(fn);\n        return function () {\n          cancelAnimationFrame(id);\n        };\n      } :\n      function (fn) {\n        var timer = $timeout(fn, 16.66, false); // 1000 / 60 = 16.666\n        return function () {\n          $timeout.cancel(timer);\n        };\n      };\n\n    raf.supported = rafSupported;\n\n    return raf;\n\n  });\n}\n","'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.parseOptions', [])\n\n  .provider('$parseOptions', function () {\n\n    var defaults = this.defaults = {\n      regexp: /^\\s*(.*?)(?:\\s+as\\s+(.*?))?(?:\\s+group\\s+by\\s+(.*))?\\s+for\\s+(?:([\\$\\w][\\$\\w]*)|(?:\\(\\s*([\\$\\w][\\$\\w]*)\\s*,\\s*([\\$\\w][\\$\\w]*)\\s*\\)))\\s+in\\s+(.*?)(?:\\s+track\\s+by\\s+(.*?))?$/\n    };\n\n    this.$get = function ($parse, $q) {\n\n      function ParseOptionsFactory(attr, config) {\n\n        var $parseOptions = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        $parseOptions.$values = [];\n\n        // Private vars\n        var match;\n        var displayFn;\n        var valueName;\n        /* eslint-disable no-unused-vars */\n        var keyName;\n        var groupByFn;\n        /* eslint-enable no-unused-vars */\n        var valueFn;\n        var valuesFn;\n\n        $parseOptions.init = function () {\n          $parseOptions.$match = match = attr.match(options.regexp);\n          displayFn = $parse(match[2] || match[1]);\n          valueName = match[4] || match[6];\n          keyName = match[5];\n          groupByFn = $parse(match[3] || '');\n          valueFn = $parse(match[2] ? match[1] : valueName);\n          valuesFn = $parse(match[7]);\n        };\n\n        $parseOptions.valuesFn = function (scope, controller) {\n          return $q.when(valuesFn(scope, controller))\n          .then(function (values) {\n            if (!angular.isArray(values)) {\n              values = [];\n            }\n            $parseOptions.$values = values.length ? parseValues(values, scope) : [];\n            return $parseOptions.$values;\n          });\n        };\n\n        $parseOptions.displayValue = function (modelValue) {\n          var scope = {};\n          scope[valueName] = modelValue;\n          return displayFn(scope);\n        };\n\n        // Private functions\n\n        function parseValues(values, scope) {\n          return values.map(function (match, index) {\n            var locals = {};\n            var label;\n            var value;\n            locals[valueName] = match;\n            label = displayFn(scope, locals);\n            value = valueFn(scope, locals);\n            return {label: label, value: value, index: index};\n          });\n        }\n\n        $parseOptions.init();\n        return $parseOptions;\n\n      }\n\n      return ParseOptionsFactory;\n\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.dimensions', [])\n\n  .factory('dimensions', function () {\n\n    var fn = {};\n\n    /**\n     * Test the element nodeName\n     * @param element\n     * @param name\n     */\n    var nodeName = fn.nodeName = function (element, name) {\n      return element.nodeName && element.nodeName.toLowerCase() === name.toLowerCase();\n    };\n\n    /**\n     * Returns the element computed style\n     * @param element\n     * @param prop\n     * @param extra\n     */\n    fn.css = function (element, prop, extra) {\n      var value;\n      if (element.currentStyle) { // IE\n        value = element.currentStyle[prop];\n      } else if (window.getComputedStyle) {\n        value = window.getComputedStyle(element)[prop];\n      } else {\n        value = element.style[prop];\n      }\n      return extra === true ? parseFloat(value) || 0 : value;\n    };\n\n    /**\n     * Provides read-only equivalent of jQuery's offset function:\n     * @required-by bootstrap-tooltip, bootstrap-affix\n     * @url http://api.jquery.com/offset/\n     * @param element\n     */\n    fn.offset = function (element) {\n      var boxRect = element.getBoundingClientRect();\n      var docElement = element.ownerDocument;\n      return {\n        width: boxRect.width || element.offsetWidth,\n        height: boxRect.height || element.offsetHeight,\n        top: boxRect.top + (window.pageYOffset || docElement.documentElement.scrollTop) - (docElement.documentElement.clientTop || 0),\n        left: boxRect.left + (window.pageXOffset || docElement.documentElement.scrollLeft) - (docElement.documentElement.clientLeft || 0)\n      };\n    };\n\n    /**\n     * Provides set equivalent of jQuery's offset function:\n     * @required-by bootstrap-tooltip\n     * @url http://api.jquery.com/offset/\n     * @param element\n     * @param options\n     * @param i\n     */\n    fn.setOffset = function (element, options, i) {\n      var curPosition;\n      var curLeft;\n      var curCSSTop;\n      var curTop;\n      var curOffset;\n      var curCSSLeft;\n      var calculatePosition;\n      var position = fn.css(element, 'position');\n      var curElem = angular.element(element);\n      var props = {};\n\n      // Set position first, in-case top/left are set even on static elem\n      if (position === 'static') {\n        element.style.position = 'relative';\n      }\n\n      curOffset = fn.offset(element);\n      curCSSTop = fn.css(element, 'top');\n      curCSSLeft = fn.css(element, 'left');\n      calculatePosition = (position === 'absolute' || position === 'fixed') &&\n                          (curCSSTop + curCSSLeft).indexOf('auto') > -1;\n\n      // Need to be able to calculate position if either\n      // top or left is auto and position is either absolute or fixed\n      if (calculatePosition) {\n        curPosition = fn.position(element);\n        curTop = curPosition.top;\n        curLeft = curPosition.left;\n      } else {\n        curTop = parseFloat(curCSSTop) || 0;\n        curLeft = parseFloat(curCSSLeft) || 0;\n      }\n\n      if (angular.isFunction(options)) {\n        options = options.call(element, i, curOffset);\n      }\n\n      if (options.top !== null) {\n        props.top = (options.top - curOffset.top) + curTop;\n      }\n      if (options.left !== null) {\n        props.left = (options.left - curOffset.left) + curLeft;\n      }\n\n      if ('using' in options) {\n        options.using.call(curElem, props);\n      } else {\n        curElem.css({\n          top: props.top + 'px',\n          left: props.left + 'px'\n        });\n      }\n    };\n\n    /**\n     * Provides read-only equivalent of jQuery's position function\n     * @required-by bootstrap-tooltip, bootstrap-affix\n     * @url http://api.jquery.com/offset/\n     * @param element\n     */\n    fn.position = function (element) {\n\n      var offsetParentRect = {top: 0, left: 0};\n      var offsetParentEl;\n      var offset;\n\n      // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent\n      if (fn.css(element, 'position') === 'fixed') {\n\n        // We assume that getBoundingClientRect is available when computed position is fixed\n        offset = element.getBoundingClientRect();\n\n      } else {\n\n        // Get *real* offsetParentEl\n        offsetParentEl = offsetParentElement(element);\n\n        // Get correct offsets\n        offset = fn.offset(element);\n        if (!nodeName(offsetParentEl, 'html')) {\n          offsetParentRect = fn.offset(offsetParentEl);\n        }\n\n        // Add offsetParent borders\n        offsetParentRect.top += fn.css(offsetParentEl, 'borderTopWidth', true);\n        offsetParentRect.left += fn.css(offsetParentEl, 'borderLeftWidth', true);\n      }\n\n      // Subtract parent offsets and element margins\n      return {\n        width: element.offsetWidth,\n        height: element.offsetHeight,\n        top: offset.top - offsetParentRect.top - fn.css(element, 'marginTop', true),\n        left: offset.left - offsetParentRect.left - fn.css(element, 'marginLeft', true)\n      };\n\n    };\n\n    /**\n     * Returns the closest, non-statically positioned offsetParent of a given element\n     * @required-by fn.position\n     * @param element\n     */\n    function offsetParentElement(element) {\n      var docElement = element.ownerDocument;\n      var offsetParent = element.offsetParent || docElement;\n      if (nodeName(offsetParent, '#document')) return docElement.documentElement;\n      while (offsetParent && !nodeName(offsetParent, 'html') && fn.css(offsetParent, 'position') === 'static') {\n        offsetParent = offsetParent.offsetParent;\n      }\n      return offsetParent || docElement.documentElement;\n    }\n\n    /**\n     * Provides equivalent of jQuery's height function\n     * @required-by bootstrap-affix\n     * @url http://api.jquery.com/height/\n     * @param element\n     * @param outer\n     */\n    fn.height = function (element, outer) {\n      var value = element.offsetHeight;\n      if (outer) {\n        value += fn.css(element, 'marginTop', true) + fn.css(element, 'marginBottom', true);\n      } else {\n        value -= fn.css(element, 'paddingTop', true) + fn.css(element, 'paddingBottom', true) + fn.css(element, 'borderTopWidth', true) + fn.css(element, 'borderBottomWidth', true);\n      }\n      return value;\n    };\n\n    /**\n     * Provides equivalent of jQuery's width function\n     * @required-by bootstrap-affix\n     * @url http://api.jquery.com/width/\n     * @param element\n     * @param outer\n     */\n    fn.width = function (element, outer) {\n      var value = element.offsetWidth;\n      if (outer) {\n        value += fn.css(element, 'marginLeft', true) + fn.css(element, 'marginRight', true);\n      } else {\n        value -= fn.css(element, 'paddingLeft', true) + fn.css(element, 'paddingRight', true) + fn.css(element, 'borderLeftWidth', true) + fn.css(element, 'borderRightWidth', true);\n      }\n      return value;\n    };\n\n    return fn;\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.debounce', [])\n\n// @source jashkenas/underscore\n// @url https://github.com/jashkenas/underscore/blob/1.5.2/underscore.js#L693\n.factory('debounce', function ($timeout) {\n  return function (func, wait, immediate) {\n    var timeout = null;\n    return function () {\n      var context = this;\n      var args = arguments;\n      var callNow = immediate && !timeout;\n      if (timeout) {\n        $timeout.cancel(timeout);\n      }\n      timeout = $timeout(function later() {\n        timeout = null;\n        if (!immediate) {\n          func.apply(context, args);\n        }\n      }, wait, false);\n      if (callNow) {\n        func.apply(context, args);\n      }\n      return timeout;\n    };\n  };\n})\n\n\n// @source jashkenas/underscore\n// @url https://github.com/jashkenas/underscore/blob/1.5.2/underscore.js#L661\n.factory('throttle', function ($timeout) {\n  return function (func, wait, options) {\n    var timeout = null;\n    if (!options) options = {};\n    return function () {\n      var context = this;\n      var args = arguments;\n      if (!timeout) {\n        if (options.leading !== false) {\n          func.apply(context, args);\n        }\n        timeout = $timeout(function later() {\n          timeout = null;\n          if (options.trailing !== false) {\n            func.apply(context, args);\n          }\n        }, wait, false);\n      }\n    };\n  };\n});\n","'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.dateParser', [])\n\n.provider('$dateParser', function ($localeProvider) {\n\n  // define a custom ParseDate object to use instead of native Date\n  // to avoid date values wrapping when setting date component values\n  function ParseDate() {\n    this.year = 1970;\n    this.month = 0;\n    this.day = 1;\n    this.hours = 0;\n    this.minutes = 0;\n    this.seconds = 0;\n    this.milliseconds = 0;\n  }\n\n  ParseDate.prototype.setMilliseconds = function (value) { this.milliseconds = value; };\n  ParseDate.prototype.setSeconds = function (value) { this.seconds = value; };\n  ParseDate.prototype.setMinutes = function (value) { this.minutes = value; };\n  ParseDate.prototype.setHours = function (value) { this.hours = value; };\n  ParseDate.prototype.getHours = function () { return this.hours; };\n  ParseDate.prototype.setDate = function (value) { this.day = value; };\n  ParseDate.prototype.setMonth = function (value) { this.month = value; };\n  ParseDate.prototype.setFullYear = function (value) { this.year = value; };\n  ParseDate.prototype.fromDate = function (value) {\n    this.year = value.getFullYear();\n    this.month = value.getMonth();\n    this.day = value.getDate();\n    this.hours = value.getHours();\n    this.minutes = value.getMinutes();\n    this.seconds = value.getSeconds();\n    this.milliseconds = value.getMilliseconds();\n    return this;\n  };\n\n  ParseDate.prototype.toDate = function () {\n    return new Date(this.year, this.month, this.day, this.hours, this.minutes, this.seconds, this.milliseconds);\n  };\n\n  var proto = ParseDate.prototype;\n\n  function noop() {\n  }\n\n  function isNumeric(n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n  }\n\n  function indexOfCaseInsensitive(array, value) {\n    var len = array.length;\n    var str = value.toString().toLowerCase();\n    for (var i = 0; i < len; i++) {\n      if (array[i].toLowerCase() === str) { return i; }\n    }\n    return -1; // Return -1 per the \"Array.indexOf()\" method.\n  }\n\n  var defaults = this.defaults = {\n    format: 'shortDate',\n    strict: false\n  };\n\n  this.$get = function ($locale, dateFilter) {\n\n    var DateParserFactory = function (config) {\n\n      var options = angular.extend({}, defaults, config);\n\n      var $dateParser = {};\n\n      /* eslint-disable key-spacing, quote-props */\n      var regExpMap = {\n        'sss'   : '[0-9]{3}',\n        'ss'    : '[0-5][0-9]',\n        's'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\n        'mm'    : '[0-5][0-9]',\n        'm'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\n        'HH'    : '[01][0-9]|2[0-3]',\n        'H'     : options.strict ? '1?[0-9]|2[0-3]' : '[01]?[0-9]|2[0-3]',\n        'hh'    : '[0][1-9]|[1][012]',\n        'h'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\n        'a'     : 'AM|PM',\n        'EEEE'  : $locale.DATETIME_FORMATS.DAY.join('|'),\n        'EEE'   : $locale.DATETIME_FORMATS.SHORTDAY.join('|'),\n        'dd'    : '0[1-9]|[12][0-9]|3[01]',\n        'd'     : options.strict ? '[1-9]|[1-2][0-9]|3[01]' : '0?[1-9]|[1-2][0-9]|3[01]',\n        'MMMM'  : $locale.DATETIME_FORMATS.MONTH.join('|'),\n        'MMM'   : $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\n        'MM'    : '0[1-9]|1[012]',\n        'M'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\n        'yyyy'  : '[1]{1}[0-9]{3}|[2]{1}[0-9]{3}',\n        'yy'    : '[0-9]{2}',\n        'y'     : options.strict ? '-?(0|[1-9][0-9]{0,3})' : '-?0*[0-9]{1,4}'\n      };\n\n      var setFnMap = {\n        'sss'   : proto.setMilliseconds,\n        'ss'    : proto.setSeconds,\n        's'     : proto.setSeconds,\n        'mm'    : proto.setMinutes,\n        'm'     : proto.setMinutes,\n        'HH'    : proto.setHours,\n        'H'     : proto.setHours,\n        'hh'    : proto.setHours,\n        'h'     : proto.setHours,\n        'EEEE'  : noop,\n        'EEE'   : noop,\n        'dd'    : proto.setDate,\n        'd'     : proto.setDate,\n        'a'     : function (value) { var hours = this.getHours() % 12; return this.setHours(value.match(/pm/i) ? hours + 12 : hours); },\n        'MMMM'  : function (value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.MONTH, value)); },\n        'MMM'   : function (value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.SHORTMONTH, value)); },\n        'MM'    : function (value) { return this.setMonth(1 * value - 1); },\n        'M'     : function (value) { return this.setMonth(1 * value - 1); },\n        'yyyy'  : proto.setFullYear,\n        'yy'    : function (value) { return this.setFullYear(2000 + 1 * value); },\n        'y'     : function (value) { return (1 * value <= 50 && value.length === 2) ? this.setFullYear(2000 + 1 * value) : this.setFullYear(1 * value); }\n      };\n      /* eslint-enable key-spacing, quote-props */\n\n      var regex;\n      var setMap;\n\n      $dateParser.init = function () {\n        $dateParser.$format = $locale.DATETIME_FORMATS[options.format] || options.format;\n        regex = regExpForFormat($dateParser.$format);\n        setMap = setMapForFormat($dateParser.$format);\n      };\n\n      $dateParser.isValid = function (date) {\n        if (angular.isDate(date)) return !isNaN(date.getTime());\n        return regex.test(date);\n      };\n\n      $dateParser.parse = function (value, baseDate, format, timezone) {\n        // check for date format special names\n        if (format) format = $locale.DATETIME_FORMATS[format] || format;\n        if (angular.isDate(value)) value = dateFilter(value, format || $dateParser.$format, timezone);\n        var formatRegex = format ? regExpForFormat(format) : regex;\n        var formatSetMap = format ? setMapForFormat(format) : setMap;\n        var matches = formatRegex.exec(value);\n        if (!matches) return false;\n        // use custom ParseDate object to set parsed values\n        var date = baseDate && !isNaN(baseDate.getTime()) ? new ParseDate().fromDate(baseDate) : new ParseDate().fromDate(new Date(1970, 0, 1, 0));\n        for (var i = 0; i < matches.length - 1; i++) {\n          if (formatSetMap[i]) formatSetMap[i].call(date, matches[i + 1]);\n        }\n        // convert back to native Date object\n        var newDate = date.toDate();\n\n        // check new native Date object for day values overflow\n        if (parseInt(date.day, 10) !== newDate.getDate()) {\n          return false;\n        }\n\n        return newDate;\n      };\n\n      $dateParser.getDateForAttribute = function (key, value) {\n        var date;\n\n        if (value === 'today') {\n          var today = new Date();\n          date = new Date(today.getFullYear(), today.getMonth(), today.getDate() + (key === 'maxDate' ? 1 : 0), 0, 0, 0, (key === 'minDate' ? 0 : -1));\n        } else if (angular.isString(value) && value.match(/^\".+\"$/)) { // Support {{ dateObj }}\n          date = new Date(value.substr(1, value.length - 2));\n        } else if (isNumeric(value)) {\n          date = new Date(parseInt(value, 10));\n        } else if (angular.isString(value) && value.length === 0) { // Reset date\n          date = key === 'minDate' ? -Infinity : +Infinity;\n        } else {\n          date = new Date(value);\n        }\n\n        return date;\n      };\n\n      $dateParser.getTimeForAttribute = function (key, value) {\n        var time;\n\n        if (value === 'now') {\n          time = new Date().setFullYear(1970, 0, 1);\n        } else if (angular.isString(value) && value.match(/^\".+\"$/)) {\n          time = new Date(value.substr(1, value.length - 2)).setFullYear(1970, 0, 1);\n        } else if (isNumeric(value)) {\n          time = new Date(parseInt(value, 10)).setFullYear(1970, 0, 1);\n        } else if (angular.isString(value) && value.length === 0) { // Reset time\n          time = key === 'minTime' ? -Infinity : +Infinity;\n        } else {\n          time = $dateParser.parse(value, new Date(1970, 0, 1, 0));\n        }\n\n        return time;\n      };\n\n      /* Handle switch to/from daylight saving.\n      * Hours may be non-zero on daylight saving cut-over:\n      * > 12 when midnight changeover, but then cannot generate\n      * midnight datetime, so jump to 1AM, otherwise reset.\n      * @param  date  (Date) the date to check\n      * @return  (Date) the corrected date\n      *\n      * __ copied from jquery ui datepicker __\n      */\n      $dateParser.daylightSavingAdjust = function (date) {\n        if (!date) {\n          return null;\n        }\n        date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);\n        return date;\n      };\n\n      /* Correct the date for timezone offset.\n      * @param  date  (Date) the date to adjust\n      * @param  timezone  (string) the timezone to adjust for\n      * @param  undo  (boolean) to add or subtract timezone offset\n      * @return  (Date) the corrected date\n      */\n      $dateParser.timezoneOffsetAdjust = function (date, timezone, undo) {\n        if (!date) {\n          return null;\n        }\n        // Right now, only 'UTC' is supported.\n        if (timezone && timezone === 'UTC') {\n          date = new Date(date.getTime());\n          date.setMinutes(date.getMinutes() + (undo ? -1 : 1) * date.getTimezoneOffset());\n        }\n        return date;\n      };\n\n      // Private functions\n\n      function regExpForFormat(format) {\n        // `format` string can contain literal values.\n        // These need to be escaped by surrounding with\n        // single quotes (e.g. `\"h 'in the morning'\"`).\n        // In order to output a single quote, escape it - i.e.,\n        // two single quotes in a sequence (e.g. `\"h 'o''clock'\"`).\n\n        var re = buildDateAbstractRegex(format);\n        return buildDateParseRegex(re);\n      }\n\n      function buildDateAbstractRegex(format) {\n        var escapedFormat = escapeReservedSymbols(format);\n        var escapedLiteralFormat = escapedFormat.replace(/''/g, '\\\\\\'');\n        var literalRegex = /('(?:\\\\'|.)*?')/;\n        var formatParts = escapedLiteralFormat.split(literalRegex);\n        var dateElements = Object.keys(regExpMap);\n        var dateRegexParts = [];\n\n        angular.forEach(formatParts, function (part) {\n          if (isFormatStringLiteral(part)) {\n            part = trimLiteralEscapeChars(part);\n          } else {\n            // Abstract replaces to avoid collisions\n            for (var i = 0; i < dateElements.length; i++) {\n              part = part.split(dateElements[i]).join('${' + i + '}');\n            }\n          }\n          dateRegexParts.push(part);\n        });\n\n        return dateRegexParts.join('');\n      }\n\n      function escapeReservedSymbols(text) {\n        return text.replace(/\\\\/g, '[\\\\\\\\]')\n                   .replace(/-/g, '[-]')\n                   .replace(/\\./g, '[.]')\n                   .replace(/\\*/g, '[*]')\n                   .replace(/\\+/g, '[+]')\n                   .replace(/\\?/g, '[?]')\n                   .replace(/\\$/g, '[$]')\n                   .replace(/\\^/g, '[^]')\n                   .replace(/\\//g, '[/]')\n                   .replace(/\\\\s/g, '[\\\\s]');\n      }\n\n      function isFormatStringLiteral(text) {\n        return /^'.*'$/.test(text);\n      }\n\n      function trimLiteralEscapeChars(text) {\n        return text.replace(/^'(.*)'$/, '$1');\n      }\n\n      function buildDateParseRegex(abstractRegex) {\n        var dateElements = Object.keys(regExpMap);\n        var re = abstractRegex;\n\n        // Replace abstracted values\n        for (var i = 0; i < dateElements.length; i++) {\n          re = re.split('${' + i + '}').join('(' + regExpMap[dateElements[i]] + ')');\n        }\n\n        return new RegExp('^' + re + '$', ['i']);\n      }\n\n      function setMapForFormat(format) {\n        var re = buildDateAbstractRegex(format);\n        return buildDateParseValuesMap(re);\n      }\n\n      function buildDateParseValuesMap(abstractRegex) {\n        var dateElements = Object.keys(regExpMap);\n        var valuesRegex = new RegExp('\\\\${(\\\\d+)}', 'g');\n        var valuesMatch;\n        var keyIndex;\n        var valueKey;\n        var valueFunction;\n        var valuesFunctionMap = [];\n\n        /* eslint-disable no-cond-assign */\n        while ((valuesMatch = valuesRegex.exec(abstractRegex)) !== null) {\n          keyIndex = valuesMatch[1];\n          valueKey = dateElements[keyIndex];\n          valueFunction = setFnMap[valueKey];\n\n          valuesFunctionMap.push(valueFunction);\n        }\n\n        return valuesFunctionMap;\n      }\n\n      $dateParser.init();\n      return $dateParser;\n\n    };\n\n    return DateParserFactory;\n\n  };\n\n});\n","'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.dateFormatter', [])\n\n  .service('$dateFormatter', function ($locale, dateFilter) {\n\n    // The unused `lang` arguments are on purpose. The default implementation does not\n    // use them and it always uses the locale loaded into the `$locale` service.\n    // Custom implementations might use it, thus allowing different directives to\n    // have different languages.\n\n    this.getDefaultLocale = function () {\n      return $locale.id;\n    };\n\n    // Format is either a data format name, e.g. \"shortTime\" or \"fullDate\", or a date format\n    // Return either the corresponding date format or the given date format.\n    this.getDatetimeFormat = function (format, lang) {\n      return $locale.DATETIME_FORMATS[format] || format;\n    };\n\n    this.weekdaysShort = function (lang) {\n      return $locale.DATETIME_FORMATS.SHORTDAY;\n    };\n\n    function splitTimeFormat(format) {\n      return /(h+)([:\\.])?(m+)([:\\.])?(s*)[ ]?(a?)/i.exec(format).slice(1);\n    }\n\n    // h:mm a => h\n    this.hoursFormat = function (timeFormat) {\n      return splitTimeFormat(timeFormat)[0];\n    };\n\n    // h:mm a => mm\n    this.minutesFormat = function (timeFormat) {\n      return splitTimeFormat(timeFormat)[2];\n    };\n\n    // h:mm:ss a => ss\n    this.secondsFormat = function (timeFormat) {\n      return splitTimeFormat(timeFormat)[4];\n    };\n\n    // h:mm a => :\n    this.timeSeparator = function (timeFormat) {\n      return splitTimeFormat(timeFormat)[1];\n    };\n\n    // h:mm:ss a => true, h:mm a => false\n    this.showSeconds = function (timeFormat) {\n      return !!splitTimeFormat(timeFormat)[4];\n    };\n\n    // h:mm a => true, H.mm => false\n    this.showAM = function (timeFormat) {\n      return !!splitTimeFormat(timeFormat)[5];\n    };\n\n    this.formatDate = function (date, format, lang, timezone) {\n      return dateFilter(date, format, timezone);\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.dropdown', ['mgcrea.ngStrap.tooltip'])\n\n  .provider('$dropdown', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'dropdown',\n      prefixEvent: 'dropdown',\n      placement: 'bottom-left',\n      templateUrl: 'dropdown/dropdown.tpl.html',\n      trigger: 'click',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0\n    };\n\n    this.$get = function ($window, $rootScope, $tooltip, $timeout) {\n\n      var bodyEl = angular.element($window.document.body);\n      var matchesSelector = Element.prototype.matchesSelector || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector;\n\n      function DropdownFactory(element, config) {\n\n        var $dropdown = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        /* var scope = */$dropdown.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n\n        $dropdown = $tooltip(element, options);\n        var parentEl = element.parent();\n\n        // Protected methods\n\n        $dropdown.$onKeyDown = function (evt) {\n          if (!/(38|40)/.test(evt.keyCode)) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          // Retrieve focused index\n          var items = angular.element($dropdown.$element[0].querySelectorAll('li:not(.divider) a'));\n          if (!items.length) return;\n          var index;\n          angular.forEach(items, function (el, i) {\n            if (matchesSelector && matchesSelector.call(el, ':focus')) index = i;\n          });\n\n          // Navigate with keyboard\n          if (evt.keyCode === 38 && index > 0) index--;\n          else if (evt.keyCode === 40 && index < items.length - 1) index++;\n          else if (angular.isUndefined(index)) index = 0;\n          items.eq(index)[0].focus();\n\n        };\n\n        // Overrides\n\n        var show = $dropdown.show;\n        $dropdown.show = function () {\n          show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function () {\n            if (options.keyboard && $dropdown.$element) $dropdown.$element.on('keydown', $dropdown.$onKeyDown);\n            bodyEl.on('click', onBodyClick);\n          }, 0, false);\n          if (parentEl.hasClass('dropdown')) parentEl.addClass('open');\n        };\n\n        var hide = $dropdown.hide;\n        $dropdown.hide = function () {\n          if (!$dropdown.$isShown) return;\n          if (options.keyboard && $dropdown.$element) $dropdown.$element.off('keydown', $dropdown.$onKeyDown);\n          bodyEl.off('click', onBodyClick);\n          if (parentEl.hasClass('dropdown')) parentEl.removeClass('open');\n          hide();\n        };\n\n        var destroy = $dropdown.destroy;\n        $dropdown.destroy = function () {\n          bodyEl.off('click', onBodyClick);\n          destroy();\n        };\n\n        // Private functions\n\n        function onBodyClick(evt) {\n          if (evt.target === element[0]) return;\n          return evt.target !== element[0] && $dropdown.hide();\n        }\n\n        return $dropdown;\n\n      }\n\n      return DropdownFactory;\n\n    };\n\n  })\n\n  .directive('bsDropdown', function ($window, $sce, $dropdown) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      compile: function (tElement, tAttrs) {\n\n        // Support for inlined template (next sibling)\n        // It must be fetched before compilation\n        if (!tAttrs.bsDropdown) {\n          var nextSibling = tElement[0].nextSibling;\n          while (nextSibling && nextSibling.nodeType !== 1) {\n            nextSibling = nextSibling.nextSibling;\n          }\n          if (nextSibling && nextSibling.classList.contains('dropdown-menu')) {\n            tAttrs.template = nextSibling.outerHTML;\n            tAttrs.templateUrl = undefined;\n            nextSibling.parentNode.removeChild(nextSibling);\n          }\n        }\n\n        return function postLink(scope, element, attr) {\n\n          // Directive options\n          var options = {scope: scope};\n          angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'id', 'autoClose'], function (key) {\n            if (angular.isDefined(tAttrs[key])) options[key] = tAttrs[key];\n          });\n\n          // use string regex match boolean attr falsy values, leave truthy values be\n          var falseValueRegExp = /^(false|0|)$/i;\n          angular.forEach(['html', 'container'], function (key) {\n            if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\n          });\n\n          // Support scope as an object\n          if (attr.bsDropdown) {\n            scope.$watch(attr.bsDropdown, function (newValue, oldValue) {\n              scope.content = newValue;\n            }, true);\n          }\n\n          // Initialize dropdown\n          var dropdown = $dropdown(element, options);\n\n          // Visibility binding support\n          if (attr.bsShow) {\n            scope.$watch(attr.bsShow, function (newValue, oldValue) {\n              if (!dropdown || !angular.isDefined(newValue)) return;\n              if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(dropdown),?/i);\n              if (newValue === true) {\n                dropdown.show();\n              } else {\n                dropdown.hide();\n              }\n            });\n          }\n\n          // Garbage collection\n          scope.$on('$destroy', function () {\n            if (dropdown) dropdown.destroy();\n            options = null;\n            dropdown = null;\n          });\n\n        };\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.aside', ['mgcrea.ngStrap.modal'])\n\n  .provider('$aside', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade-and-slide-right',\n      prefixClass: 'aside',\n      prefixEvent: 'aside',\n      placement: 'right',\n      templateUrl: 'aside/aside.tpl.html',\n      contentTemplate: false,\n      container: false,\n      element: null,\n      backdrop: true,\n      keyboard: true,\n      html: false,\n      show: true\n    };\n\n    this.$get = function ($modal) {\n\n      function AsideFactory(config) {\n\n        var $aside = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $aside = $modal(options);\n\n        return $aside;\n\n      }\n\n      return AsideFactory;\n\n    };\n\n  })\n\n  .directive('bsAside', function ($window, $sce, $aside) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n        // Directive options\n        var options = {scope: scope, element: element, show: false};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'backdrop', 'keyboard', 'html', 'container', 'animation'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['backdrop', 'keyboard', 'html', 'container'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\n        });\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content'], function (key) {\n          if (attr[key]) {\n            attr.$observe(key, function (newValue, oldValue) {\n              scope[key] = $sce.trustAsHtml(newValue);\n            });\n          }\n        });\n\n        // Support scope as an object\n        if (attr.bsAside) {\n          scope.$watch(attr.bsAside, function (newValue, oldValue) {\n            if (angular.isObject(newValue)) {\n              angular.extend(scope, newValue);\n            } else {\n              scope.content = newValue;\n            }\n          }, true);\n        }\n\n        // Initialize aside\n        var aside = $aside(options);\n\n        // Trigger\n        element.on(attr.trigger || 'click', aside.toggle);\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (aside) aside.destroy();\n          options = null;\n          aside = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.button', [])\n\n  .provider('$button', function () {\n\n    var defaults = this.defaults = {\n      activeClass: 'active',\n      toggleEvent: 'click'\n    };\n\n    this.$get = function () {\n      return {defaults: defaults};\n    };\n\n  })\n\n  .directive('bsCheckboxGroup', function () {\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      compile: function postLink(element, attr) {\n        element.attr('data-toggle', 'buttons');\n        element.removeAttr('ng-model');\n        var children = element[0].querySelectorAll('input[type=\"checkbox\"]');\n        angular.forEach(children, function (child) {\n          var childEl = angular.element(child);\n          childEl.attr('bs-checkbox', '');\n          childEl.attr('ng-model', attr.ngModel + '.' + childEl.attr('value'));\n        });\n      }\n\n    };\n\n  })\n\n  .directive('bsCheckbox', function ($button, $$rAF) {\n\n    var defaults = $button.defaults;\n    var constantValueRegExp = /^(true|false|\\d+)$/;\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        var options = defaults;\n\n        // Support label > input[type=\"checkbox\"]\n        var isInput = element[0].nodeName === 'INPUT';\n        var activeElement = isInput ? element.parent() : element;\n\n        var trueValue = angular.isDefined(attr.trueValue) ? attr.trueValue : true;\n        if (constantValueRegExp.test(attr.trueValue)) {\n          trueValue = scope.$eval(attr.trueValue);\n        }\n        var falseValue = angular.isDefined(attr.falseValue) ? attr.falseValue : false;\n        if (constantValueRegExp.test(attr.falseValue)) {\n          falseValue = scope.$eval(attr.falseValue);\n        }\n\n        // Parse exotic values\n        var hasExoticValues = typeof trueValue !== 'boolean' || typeof falseValue !== 'boolean';\n        if (hasExoticValues) {\n          controller.$parsers.push(function (viewValue) {\n            // console.warn('$parser', element.attr('ng-model'), 'viewValue', viewValue);\n            return viewValue ? trueValue : falseValue;\n          });\n          // modelValue -> $formatters -> viewValue\n          controller.$formatters.push(function (modelValue) {\n             // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n            return angular.equals(modelValue, trueValue);\n          });\n          // Fix rendering for exotic values\n          scope.$watch(attr.ngModel, function (newValue, oldValue) {\n            controller.$render();\n          });\n        }\n\n        // model -> view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          var isActive = angular.equals(controller.$modelValue, trueValue);\n          $$rAF(function () {\n            if (isInput) element[0].checked = isActive;\n            activeElement.toggleClass(options.activeClass, isActive);\n          });\n        };\n\n        // view -> model\n        element.bind(options.toggleEvent, function () {\n          scope.$apply(function () {\n            // console.warn('!click', element.attr('ng-model'), 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue, 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue);\n            if (!isInput) {\n              controller.$setViewValue(!activeElement.hasClass('active'));\n            }\n            if (!hasExoticValues) {\n              controller.$render();\n            }\n          });\n        });\n\n      }\n\n    };\n\n  })\n\n  .directive('bsRadioGroup', function () {\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      compile: function postLink(element, attr) {\n        element.attr('data-toggle', 'buttons');\n        element.removeAttr('ng-model');\n        var children = element[0].querySelectorAll('input[type=\"radio\"]');\n        angular.forEach(children, function (child) {\n          angular.element(child).attr('bs-radio', '');\n          angular.element(child).attr('ng-model', attr.ngModel);\n        });\n      }\n\n    };\n\n  })\n\n  .directive('bsRadio', function ($button, $$rAF) {\n\n    var defaults = $button.defaults;\n    var constantValueRegExp = /^(true|false|\\d+)$/;\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        var options = defaults;\n\n        // Support `label > input[type=\"radio\"]` markup\n        var isInput = element[0].nodeName === 'INPUT';\n        var activeElement = isInput ? element.parent() : element;\n\n        var value;\n        attr.$observe('value', function (v) {\n          value = constantValueRegExp.test(v) ? scope.$eval(v) : v;\n          controller.$render();\n        });\n\n        // model -> view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('value'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          var isActive = angular.equals(controller.$modelValue, value);\n          $$rAF(function () {\n            if (isInput) element[0].checked = isActive;\n            activeElement.toggleClass(options.activeClass, isActive);\n          });\n        };\n\n        // view -> model\n        element.bind(options.toggleEvent, function () {\n          scope.$apply(function () {\n            // console.warn('!click', element.attr('value'), 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue, 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue);\n            controller.$setViewValue(value);\n            controller.$render();\n          });\n        });\n\n      }\n\n    };\n\n  });\n","'use strict';\n\n// @BUG: following snippet won't compile correctly\n// @TODO: submit issue to core\n// '<span ng-if=\"title\"><strong ng-bind=\"title\"></strong>&nbsp;</span><span ng-bind-html=\"content\"></span>' +\n\nangular.module('mgcrea.ngStrap.alert', ['mgcrea.ngStrap.modal'])\n\n  .provider('$alert', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'alert',\n      prefixEvent: 'alert',\n      placement: null,\n      templateUrl: 'alert/alert.tpl.html',\n      container: false,\n      element: null,\n      backdrop: false,\n      keyboard: true,\n      show: true,\n      // Specific options\n      duration: false,\n      type: false,\n      dismissable: true\n    };\n\n    this.$get = function ($modal, $timeout) {\n\n      function AlertFactory(config) {\n\n        var $alert = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $alert = $modal(options);\n\n        // Support scope as string options [/*title, content, */ type, dismissable]\n        $alert.$scope.dismissable = !!options.dismissable;\n        if (options.type) {\n          $alert.$scope.type = options.type;\n        }\n\n        // Support auto-close duration\n        var show = $alert.show;\n        if (options.duration) {\n          $alert.show = function () {\n            show();\n            $timeout(function () {\n              $alert.hide();\n            }, options.duration * 1000);\n          };\n        }\n\n        return $alert;\n\n      }\n\n      return AlertFactory;\n\n    };\n\n  })\n\n  .directive('bsAlert', function ($window, $sce, $alert) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n\n        // Directive options\n        var options = {scope: scope, element: element, show: false};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'keyboard', 'html', 'container', 'animation', 'duration', 'dismissable'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['keyboard', 'html', 'container', 'dismissable'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\n        });\n\n        // overwrite inherited title value when no value specified\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\n        if (!scope.hasOwnProperty('title')) {\n          scope.title = '';\n        }\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content', 'type'], function (key) {\n          if (attr[key]) {\n            attr.$observe(key, function (newValue, oldValue) {\n              scope[key] = $sce.trustAsHtml(newValue);\n            });\n          }\n        });\n\n        // Support scope as an object\n        if (attr.bsAlert) {\n          scope.$watch(attr.bsAlert, function (newValue, oldValue) {\n            if (angular.isObject(newValue)) {\n              angular.extend(scope, newValue);\n            } else {\n              scope.content = newValue;\n            }\n          }, true);\n        }\n\n        // Initialize alert\n        var alert = $alert(options);\n\n        // Trigger\n        element.on(attr.trigger || 'click', alert.toggle);\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (alert) alert.destroy();\n          options = null;\n          alert = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.affix', ['mgcrea.ngStrap.helpers.dimensions', 'mgcrea.ngStrap.helpers.debounce'])\n\n  .provider('$affix', function () {\n\n    var defaults = this.defaults = {\n      offsetTop: 'auto',\n      inlineStyles: true\n    };\n\n    this.$get = function ($window, debounce, dimensions) {\n\n      var bodyEl = angular.element($window.document.body);\n      var windowEl = angular.element($window);\n\n      function AffixFactory(element, config) {\n\n        var $affix = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        var targetEl = options.target;\n\n        // Initial private vars\n        var reset = 'affix affix-top affix-bottom';\n        var setWidth = false;\n        var initialAffixTop = 0;\n        var initialOffsetTop = 0;\n        var offsetTop = 0;\n        var offsetBottom = 0;\n        var affixed = null;\n        var unpin = null;\n\n        var parent = element.parent();\n        // Options: custom parent\n        if (options.offsetParent) {\n          if (options.offsetParent.match(/^\\d+$/)) {\n            for (var i = 0; i < (options.offsetParent * 1) - 1; i++) {\n              parent = parent.parent();\n            }\n          } else {\n            parent = angular.element(options.offsetParent);\n          }\n        }\n\n        $affix.init = function () {\n\n          this.$parseOffsets();\n          initialOffsetTop = dimensions.offset(element[0]).top + initialAffixTop;\n          setWidth = !element[0].style.width;\n\n          // Bind events\n          targetEl.on('scroll', this.checkPosition);\n          targetEl.on('click', this.checkPositionWithEventLoop);\n          windowEl.on('resize', this.$debouncedOnResize);\n\n          // Both of these checkPosition() calls are necessary for the case where\n          // the user hits refresh after scrolling to the bottom of the page.\n          this.checkPosition();\n          this.checkPositionWithEventLoop();\n\n        };\n\n        $affix.destroy = function () {\n\n          // Unbind events\n          targetEl.off('scroll', this.checkPosition);\n          targetEl.off('click', this.checkPositionWithEventLoop);\n          windowEl.off('resize', this.$debouncedOnResize);\n\n        };\n\n        $affix.checkPositionWithEventLoop = function () {\n\n          // IE 9 throws an error if we use 'this' instead of '$affix'\n          // in this setTimeout call\n          setTimeout($affix.checkPosition, 1);\n\n        };\n\n        $affix.checkPosition = function () {\n          // if (!this.$element.is(':visible')) return\n\n          var scrollTop = getScrollTop();\n          var position = dimensions.offset(element[0]);\n          var elementHeight = dimensions.height(element[0]);\n\n          // Get required affix class according to position\n          var affix = getRequiredAffixClass(unpin, position, elementHeight);\n\n          // Did affix status changed this last check?\n          if (affixed === affix) return;\n          affixed = affix;\n\n          if (affix === 'top') {\n            unpin = null;\n            if (setWidth) {\n              element.css('width', '');\n            }\n            if (options.inlineStyles) {\n              element.css('position', (options.offsetParent) ? '' : 'relative');\n              element.css('top', '');\n            }\n          } else if (affix === 'bottom') {\n            if (options.offsetUnpin) {\n              unpin = -(options.offsetUnpin * 1);\n            } else {\n              // Calculate unpin threshold when affixed to bottom.\n              // Hopefully the browser scrolls pixel by pixel.\n              unpin = position.top - scrollTop;\n            }\n            if (setWidth) {\n              element.css('width', '');\n            }\n            if (options.inlineStyles) {\n              element.css('position', (options.offsetParent) ? '' : 'relative');\n              element.css('top', (options.offsetParent) ? '' : ((bodyEl[0].offsetHeight - offsetBottom - elementHeight - initialOffsetTop) + 'px'));\n            }\n          } else { // affix === 'middle'\n            unpin = null;\n            if (setWidth) {\n              element.css('width', element[0].offsetWidth + 'px');\n            }\n            if (options.inlineStyles) {\n              element.css('position', 'fixed');\n              element.css('top', initialAffixTop + 'px');\n            }\n          }\n\n          // Add proper affix class\n          element.removeClass(reset).addClass('affix' + ((affix !== 'middle') ? '-' + affix : ''));\n\n        };\n\n        $affix.$onResize = function () {\n          $affix.$parseOffsets();\n          $affix.checkPosition();\n        };\n        $affix.$debouncedOnResize = debounce($affix.$onResize, 50);\n\n        $affix.$parseOffsets = function () {\n          var initialPosition = element.css('position');\n          // Reset position to calculate correct offsetTop\n          if (options.inlineStyles) {\n            element.css('position', (options.offsetParent) ? '' : 'relative');\n          }\n\n          if (options.offsetTop) {\n            if (options.offsetTop === 'auto') {\n              options.offsetTop = '+0';\n            }\n            if (options.offsetTop.match(/^[-+]\\d+$/)) {\n              initialAffixTop = - options.offsetTop * 1;\n              if (options.offsetParent) {\n                offsetTop = dimensions.offset(parent[0]).top + (options.offsetTop * 1);\n              } else {\n                offsetTop = dimensions.offset(element[0]).top - dimensions.css(element[0], 'marginTop', true) + (options.offsetTop * 1);\n              }\n            } else {\n              offsetTop = options.offsetTop * 1;\n            }\n          }\n\n          if (options.offsetBottom) {\n            if (options.offsetParent && options.offsetBottom.match(/^[-+]\\d+$/)) {\n              // add 1 pixel due to rounding problems...\n              offsetBottom = getScrollHeight() - (dimensions.offset(parent[0]).top + dimensions.height(parent[0])) + (options.offsetBottom * 1) + 1;\n            } else {\n              offsetBottom = options.offsetBottom * 1;\n            }\n          }\n\n          // Bring back the element's position after calculations\n          if (options.inlineStyles) {\n            element.css('position', initialPosition);\n          }\n        };\n\n        // Private methods\n\n        function getRequiredAffixClass(_unpin, position, elementHeight) {\n          var scrollTop = getScrollTop();\n          var scrollHeight = getScrollHeight();\n\n          if (scrollTop <= offsetTop) {\n            return 'top';\n          } else if (_unpin !== null && (scrollTop + _unpin <= position.top)) {\n            return 'middle';\n          } else if (offsetBottom !== null && (position.top + elementHeight + initialAffixTop >= scrollHeight - offsetBottom)) {\n            return 'bottom';\n          }\n          return 'middle';\n        }\n\n        function getScrollTop() {\n          return targetEl[0] === $window ? $window.pageYOffset : targetEl[0].scrollTop;\n        }\n\n        function getScrollHeight() {\n          return targetEl[0] === $window ? $window.document.body.scrollHeight : targetEl[0].scrollHeight;\n        }\n\n        $affix.init();\n        return $affix;\n\n      }\n\n      return AffixFactory;\n\n    };\n\n  })\n\n  .directive('bsAffix', function ($affix, $window) {\n\n    return {\n      restrict: 'EAC',\n      require: '^?bsAffixTarget',\n      link: function postLink(scope, element, attr, affixTarget) {\n\n        var options = {scope: scope, target: affixTarget ? affixTarget.$element : angular.element($window)};\n        angular.forEach(['offsetTop', 'offsetBottom', 'offsetParent', 'offsetUnpin', 'inlineStyles'], function (key) {\n          if (angular.isDefined(attr[key])) {\n            var option = attr[key];\n            if (/true/i.test(option)) option = true;\n            if (/false/i.test(option)) option = false;\n            options[key] = option;\n          }\n        });\n\n        var affix = $affix(element, options);\n        scope.$on('$destroy', function () {\n          if (affix) affix.destroy();\n          options = null;\n          affix = null;\n        });\n\n      }\n    };\n\n  })\n\n  .directive('bsAffixTarget', function () {\n    return {\n      controller: function ($element) {\n        this.$element = $element;\n      }\n    };\n  });\n","\nangular.module('mgcrea.ngStrap', [\n  'mgcrea.ngStrap.modal',\n  'mgcrea.ngStrap.aside',\n  'mgcrea.ngStrap.alert',\n  'mgcrea.ngStrap.button',\n  'mgcrea.ngStrap.select',\n  'mgcrea.ngStrap.datepicker',\n  'mgcrea.ngStrap.timepicker',\n  'mgcrea.ngStrap.navbar',\n  'mgcrea.ngStrap.tooltip',\n  'mgcrea.ngStrap.popover',\n  'mgcrea.ngStrap.dropdown',\n  'mgcrea.ngStrap.typeahead',\n  'mgcrea.ngStrap.scrollspy',\n  'mgcrea.ngStrap.affix',\n  'mgcrea.ngStrap.tab',\n  'mgcrea.ngStrap.collapse'\n]);\n"],"sourceRoot":"/source/"}